diff -Naru src/Makefile.inc src_modified/Makefile.inc
--- src/Makefile.inc	2024-09-06 10:37:30
+++ src_modified/Makefile.inc	2024-09-06 10:37:30
@@ -33,15 +33,17 @@
 
 OBJECTS  = aenet.o aeio.o chebyshev.o constants.o feedforward.o geometry.o \
            input.o io.o lclist.o optimize.o parallel.o potential.o random.o \
-           sfbasis.o sfsetup.o sortlib.o symmfunc.o timing.o trainset.o \
-	   xsflib.o pytorchoutput.o
+           sfbasis.o sfsetup.o sortlib.o symmfunc.o timing.o trainset.o trainset_MPI.o \
+	   xsflib.o pytorchoutput.o sub_generate.o sub_trainbin2ASCII.o sub_nnASCII2bin.o pytorchoutput_MPI.o \
+	   sub_generate_MPI.o
 
 PICOBJECTS  = aenet_pic.o aeio_pic.o chebyshev_pic.o constants_pic.o \
               feedforward_pic.o geometry_pic.o input_pic.o io_pic.o \
               lclist_pic.o optimize_pic.o parallel_pic.o potential_pic.o \
               random_pic.o sfbasis_pic.o sfsetup_pic.o sortlib_pic.o \
-              symmfunc_pic.o timing_pic.o trainset_pic.o xsflib_pic.o \
-	      pytorchoutput_pic.o
+              symmfunc_pic.o timing_pic.o trainset_pic.o xsflib_pic.o trainset_MPI_pic.o \
+	      pytorchoutput_pic.o sub_generate_pic.o sub_trainbin2ASCII_pic.o sub_nnASCII2bin_pic.o pytorchoutput_MPI_pic.o \
+		  sub_generate_MPI_pic.o
 
 #------------------------------ targets -------------------------------#
 
@@ -51,7 +53,9 @@
 TARGET1  = $(BIN)generate.x
 TARGET2  = $(BIN)train.x
 TARGET3  = $(BIN)predict.x
-TARGETS  = $(TARGET1) $(TARGET2) $(TARGET3)
+TARGET1_mpi  = $(BIN)generate_MPI.x
+TARGET_train = $(BIN)trainbin2ASCII_modified.x
+TARGETS  = $(TARGET1) $(TARGET2) $(TARGET3) $(TARGET1_mpi) $(TARGET_train)
 
 #----------------------------- versioning -----------------------------#
 
@@ -135,4 +139,8 @@
 sfbasis.o     : io.o chebyshev.o
 sfsetup.o     : aeio.o io.o sfbasis.o symmfunc.o
 trainset.o    : aeio.o io.o sfsetup.o
+trainset_MPI.o    : aeio.o io.o sfsetup.o parallel.o
 xsflib.o      : io.o
+pytorchoutput_MPI.o : io.o
+sub_generate.o :aeio.o chebyshev.o geometry.o io.o lclist.o potential.o sfbasis.o sfsetup.o timing.o sub_trainbin2ASCII.o
+trainbin2ASCII_modified.o: sub_trainbin2ASCII.o
\ No newline at end of file
diff -Naru src/aenet.f90 src_modified/aenet.f90
--- src/aenet.f90	2024-09-06 10:37:30
+++ src_modified/aenet.f90	2024-09-06 10:37:30
@@ -74,7 +74,12 @@
 
   use timing,      only: tng_timing, tng_timing2
 
-  implicit none
+ implicit none
+  interface 
+   module subroutine generate_subroutine()
+   end
+  end interface
+
   private
   save
 
@@ -93,7 +98,8 @@
             aenet_sfb_init,                 &
             aenet_sfb_final,                &
             aenet_sfb_eval,                 &
-            aenet_sfb_reconstruct_radial
+            aenet_sfb_reconstruct_radial,    &
+            aenet_atomic_energy_and_forces_novirial
 
   !---------------------------- constants -----------------------------!
 
@@ -407,10 +413,48 @@
 
   end subroutine aenet_atomic_energy
 
+  subroutine aenet_memory_allocation(dE_dG,sfval,sfderiv_i, &
+                        sfderiv_j, &
+                        values, &
+                        derivs, &
+                        jacobian,nvalues,nweights,stat,ok)
+      implicit none
+      double precision, dimension(:),     allocatable,intent(out) :: sfval
+      double precision, dimension(:,:),   allocatable,intent(out)  :: sfderiv_i
+      double precision, dimension(:,:,:), allocatable,intent(out)  :: sfderiv_j
+      double precision, dimension(:),     allocatable,intent(out)  :: values
+      double precision, dimension(:),     allocatable,intent(out)  :: derivs
+      double precision, dimension(:),     allocatable,intent(out)  :: jacobian
+      double precision, dimension(:),     allocatable,intent(out)  :: dE_dG   
+      integer,intent(in) ::nvalues,nweights
+      integer(kind=c_int),                      intent(out)   :: stat
+      integer,intent(out)                                         :: ok
+      
+                                       
+      allocate(dE_dG(aenet_nsf_max),        &
+         sfval(aenet_nsf_max),        &
+         sfderiv_i(3, aenet_nsf_max), &
+         sfderiv_j(3, aenet_nsf_max, aenet_nnb_max), &
+         values(nvalues), &
+         derivs(nvalues), &
+         jacobian(nweights), stat=ok)
+
+      !if (ok /= 0) then
+      !!   stat = AENET_ERR_MALLOC
+      !   return
+      !end if
+      !sfval(:) = 0.0d0
+      !sfderiv_i(:,:) = 0.0d0
+      !sfderiv_j(:,:,:) = 0.0d0
+
+      
+  end subroutine
+
+
   subroutine aenet_atomic_energy_and_forces( &
        coo_i, type_i, index_i, n_j, coo_j, type_j, index_j, natoms, &
-       E_i, F, stat) bind(C)
-
+       E_i, F, S, stat) bind(C)
+    !coo_i, type_i, iatom, nnb, nbcoo, nbtype, nblist, nAtoms, E_i, forCart, stat
     implicit none
 
     real(kind=c_double), dimension(3),        intent(in)    :: coo_i
@@ -423,6 +467,7 @@
     integer(kind=c_int), value,               intent(in)    :: natoms
     real(kind=c_double),                      intent(out)   :: E_i
     real(kind=c_double), dimension(3,natoms), intent(inout) :: F
+    real(kind=c_double), dimension(3,3), intent(inout) :: S
     integer(kind=c_int),                      intent(out)   :: stat
 
     double precision, dimension(1)                  :: E_i_arr
@@ -436,7 +481,9 @@
     integer                                         :: nsf, j
     double precision, dimension(:),     allocatable :: dE_dG
     integer                                         :: ok
+    integer                                         :: x1,x2,d
 
+    
     stat = AENET_OK
     if (.not. (aenet_is_init .and. aenet_is_loaded)) then
        stat = aenet_ERR_INIT
@@ -445,6 +492,13 @@
 
     nvalues = aenet_pot(type_i)%net%nvalues
     nweights = aenet_pot(type_i)%net%Wsize
+
+    !call  aenet_memory_allocation(dE_dG,sfval,sfderiv_i, &
+    !     sfderiv_j, &
+    !     values, &
+    !     derivs, &
+    !     jacobian,nvalues,nweights,stat,ok)
+
     allocate(dE_dG(aenet_nsf_max),        &
              sfval(aenet_nsf_max),        &
              sfderiv_i(3, aenet_nsf_max), &
@@ -452,11 +506,119 @@
              values(nvalues), &
              derivs(nvalues), &
              jacobian(nweights), stat=ok)
+    
+   if (ok /= 0) then
+       stat = AENET_ERR_MALLOC
+       return
+   end if
+    sfval(:) = 0.0d0
+    !sfderiv_i(:,:) = 0.0d0
+    !sfderiv_j(:,:,:) = 0.0d0
+
+    nsf = aenet_pot(type_i)%stp%nsf
+    call stp_eval(type_i, coo_i, n_j, coo_j, type_j, &
+                  aenet_pot(type_i)%stp, sfval=sfval, &
+                  sfderiv_i=sfderiv_i, sfderiv_j=sfderiv_j, scaled=.true.)
+
+    call ff_eval(aenet_pot(type_i)%net, nsf, sfval, 1, values, derivs, E_i_arr)
+    call ff_deriv(aenet_pot(type_i)%net, nsf, 1, derivs, jacobian, dE_dG(1:nsf))
+
+    E_i = aenet_pot(type_i)%E_scale*E_i_arr(1) + aenet_pot(type_i)%E_shift
+    E_i = E_i + aenet_pot(type_i)%E_atom
+
+    F(1:3, index_i) = F(1:3, index_i) - aenet_pot(type_i)%E_scale &
+                    * matmul(sfderiv_i(1:3,1:nsf), dE_dG(1:nsf))
+
+    do j = 1, n_j
+       F(1:3, index_j(j)) = F(1:3, index_j(j)) - aenet_pot(type_i)%E_scale &
+                          * matmul(sfderiv_j(1:3,1:nsf,j), dE_dG(1:nsf))
+    end do
+
+    !stress tensor
+    do x1=1,3
+       do x2 = x1,3
+          do j =1, n_j
+             do d = 1, nsf
+                S(x2,x1) = S(x2,x1) + (coo_i(x2)-coo_j(x2,j))*aenet_pot(type_i)%E_scale&
+                     * sfderiv_j(x1,d,j)*dE_dG(d)
+             end do
+          end do
+       end do
+    end do
+
+
+    deallocate(dE_dG, sfval, sfderiv_i, sfderiv_j, &
+               values, derivs, jacobian, stat=ok)
     if (ok /= 0) then
        stat = AENET_ERR_MALLOC
        return
     end if
 
+  end subroutine aenet_atomic_energy_and_forces
+
+ subroutine aenet_atomic_energy_and_forces_novirial( &
+       coo_i, type_i, index_i, n_j, coo_j, type_j, index_j, natoms, &
+       E_i, F, stat) bind(C)
+    !coo_i, type_i, iatom, nnb, nbcoo, nbtype, nblist, nAtoms, E_i, forCart, stat
+    implicit none
+
+    real(kind=c_double), dimension(3),        intent(in)    :: coo_i
+    integer(kind=c_int), value,               intent(in)    :: type_i
+    integer(kind=c_int), value,               intent(in)    :: index_i
+    integer(kind=c_int), value,               intent(in)    :: n_j
+    real(kind=c_double), dimension(3,n_j),    intent(in)    :: coo_j
+    integer(kind=c_int), dimension(n_j),      intent(in)    :: type_j
+    integer(kind=c_int), dimension(n_j),      intent(in)    :: index_j
+    integer(kind=c_int), value,               intent(in)    :: natoms
+    real(kind=c_double),                      intent(out)   :: E_i
+    real(kind=c_double), dimension(3,natoms), intent(inout) :: F
+    integer(kind=c_int),                      intent(out)   :: stat
+
+    double precision, dimension(1)                  :: E_i_arr
+    double precision, dimension(:),     allocatable :: sfval
+    double precision, dimension(:,:),   allocatable :: sfderiv_i
+    double precision, dimension(:,:,:), allocatable :: sfderiv_j
+    double precision, dimension(:),     allocatable :: values
+    double precision, dimension(:),     allocatable :: derivs
+    double precision, dimension(:),     allocatable :: jacobian
+    integer                                         :: nvalues, nweights
+    integer                                         :: nsf, j
+    double precision, dimension(:),     allocatable :: dE_dG
+    integer                                         :: ok
+    integer                                         :: x1,x2,d
+
+    
+    stat = AENET_OK
+    if (.not. (aenet_is_init .and. aenet_is_loaded)) then
+       stat = aenet_ERR_INIT
+       return
+    end if
+
+    nvalues = aenet_pot(type_i)%net%nvalues
+    nweights = aenet_pot(type_i)%net%Wsize
+
+    !call  aenet_memory_allocation(dE_dG,sfval,sfderiv_i, &
+    !     sfderiv_j, &
+    !     values, &
+    !     derivs, &
+    !     jacobian,nvalues,nweights,stat,ok)
+
+    allocate(dE_dG(aenet_nsf_max),        &
+             sfval(aenet_nsf_max),        &
+             sfderiv_i(3, aenet_nsf_max), &
+             sfderiv_j(3, aenet_nsf_max, aenet_nnb_max), &
+             values(nvalues), &
+             derivs(nvalues), &
+             jacobian(nweights), stat=ok)
+    
+   if (ok /= 0) then
+       stat = AENET_ERR_MALLOC
+       return
+   end if
+    sfval(:) = 0.0d0
+    !sfderiv_i(:,:) = 0.0d0
+    !sfderiv_j(:,:,:) = 0.0d0
+
     nsf = aenet_pot(type_i)%stp%nsf
     call stp_eval(type_i, coo_i, n_j, coo_j, type_j, &
                   aenet_pot(type_i)%stp, sfval=sfval, &
@@ -476,6 +638,7 @@
                           * matmul(sfderiv_j(1:3,1:nsf,j), dE_dG(1:nsf))
     end do
 
+
     deallocate(dE_dG, sfval, sfderiv_i, sfderiv_j, &
                values, derivs, jacobian, stat=ok)
     if (ok /= 0) then
@@ -483,7 +646,8 @@
        return
     end if
 
-  end subroutine aenet_atomic_energy_and_forces
+  end subroutine aenet_atomic_energy_and_forces_novirial
+
 
   !--------------------------------------------------------------------!
   !                       convert atom type IDs                        !
diff -Naru src/aenet.h src_modified/aenet.h
--- src/aenet.h	2024-09-06 10:37:30
+++ src_modified/aenet.h	2024-09-06 10:37:30
@@ -1,40 +1,40 @@
 #ifndef AENET_H_INCLUDED
 #define AENET_H_INCLUDED
 
-void aenet_init(int ntypes, char* atom_types[], int* stat);
-void aenet_final(int* stat);
+void aenet_init(int ntypes, char *atom_types[], int *stat);
+void aenet_final(int *stat);
 void aenet_print_info(void);
-void aenet_load_potential(int type_id, char* filename, int* stat);
+void aenet_load_potential(int type_id, char *filename, int *stat);
 _Bool aenet_all_loaded(void);
 
 double aenet_free_atom_energy(int type_id);
 
 void aenet_atomic_energy(double coo_i[3], int type_i, int n_j,
-                         double coo_j[], int type_j[], double* E_i,
-                         int* stat);
+                         double coo_j[], int type_j[], double *E_i,
+                         int *stat);
 
 void aenet_atomic_energy_and_forces(double coo_i[3], int type_i, int index_i,
                                     int n_j, double coo_j[], int type_j[],
-                                    int index_j[], int natoms, double* E_i,
-                                    double F[], int* stat);
+                                    int index_j[], int natoms, double *E_i,
+                                    double F[], double S[], int *stat);
 
-void aenet_convert_atom_types(int ntypes_in, char* atom_types[],
+void aenet_convert_atom_types(int ntypes_in, char *atom_types[],
                               int natoms_in, int type_id_in[],
-                              int type_id_out[], int* stat);
+                              int type_id_out[], int *stat);
 
-void aenet_sfb_init(int ntypes, char* atom_types[], int radial_order,
+void aenet_sfb_init(int ntypes, char *atom_types[], int radial_order,
                     int angular_order, double radial_Rc, double angular_Rc,
-                    int* stat);
+                    int *stat);
 
-void aenet_sfb_final(int* stat);
+void aenet_sfb_final(int *stat);
 
 int aenet_sfb_nvalues(void);
 
 void aenet_sfb_eval(int itype0, double coo0[3], int nat, int itype1[],
-                    double coo1[], int nv, double values[], int* stat);
+                    double coo1[], int nv, double values[], int *stat);
 
 void aenet_sfb_reconstruct_radial(int nv, double values[], int nx,
-                                  double x[], double y[], int* stat);
+                                  double x[], double y[], int *stat);
 
 extern int AENET_OK;
 extern int AENET_ERR_INIT;
diff -Naru src/aenet_mpimodule.mod src_modified/aenet_mpimodule.mod
--- src/aenet_mpimodule.mod	1970-01-01 09:00:00
+++ src_modified/aenet_mpimodule.mod	2024-09-06 15:33:03
@@ -0,0 +1,5 @@
+‹      swó
+	rôSÈÍO)ÍIU(K-*ÎÌÏSP74UWH.JM,IMQH+ÊÏU(H,JÌÉIÍÑs³4àÒĞĞT â‚14¹€L,ØHA=15/µ$>· âDul"ê
+†
+¾ş.¡>®
+¡~Ş~şá~º~!®~!\0n@¿3LN(@\€$ †0>Ği`>Ä­Çƒtrœˆé#M. %;›óZ  
\ No newline at end of file
diff -Naru src/aenet_nnascii2bin.mod src_modified/aenet_nnascii2bin.mod
--- src/aenet_nnascii2bin.mod	1970-01-01 09:00:00
+++ src_modified/aenet_nnascii2bin.mod	2024-09-10 10:45:39
@@ -0,0 +1 @@
+‹      ÍÓMo‚0ğ{?Ås+¶àê:×ÊRaËNÄ—š4Ñ’ îó¯ĞáË†Ü%ô)!ùõß‡éc,A8lóÕ~#áC;•kÀ]Ã²óR®`]ä[Øí™Ödæ3Ö[(}¿~p‘ãtà/j&d¦-wğ\jYÁ|·Tªàö5]pœ(ÒBÊŸyüÆïO(OPS¾ˆØoŞ.¸Vq²P_Mmxum½îqÕ—¨ø’™¸Š|_*-¯:+	RAÑ9ì¬4 ~xÊ„Y:qš0NˆÑwñ ’z0„Œ¿´çp°Òkµ‘5ÊŒq½ÁÈÄ$È]L‚4ŠŞí!úOD?¡ÂìÎ¦w\1İrH°2lû’à2Ïšsú%$Œ§Ì'a}ÕÕÔÎUÂ¸&Ôs+YÜ¨~½¶æu¡w¹Û]èwĞ'põRäX  
\ No newline at end of file
diff -Naru src/ext/KAN.f90 src_modified/ext/KAN.f90
--- src/ext/KAN.f90	1970-01-01 09:00:00
+++ src_modified/ext/KAN.f90	2024-09-10 11:37:14
@@ -0,0 +1,654 @@
+module KAN
+    use feedforward,only: ff_activate
+    implicit none
+    type, public :: KAN_descriptor
+        integer::npoints
+        integer::nk
+        real(8),allocatable   ::b_KAN(:)
+        real(8),allocatable::values_r1(:,:),values_r2(:,:),values_a1(:,:),values_a2(:,:)
+        real(8),allocatable::bk_r1(:),bk_r2(:),bk_a1(:),bk_a2(:)
+        real(8),allocatable::points_r(:),points_a(:)
+        real(8)::a_Rc,r_Rc
+        integer::a_Nc,r_Nc
+        real(8)::rc_min
+        integer,          dimension(:),   allocatable :: typeid
+        double precision, dimension(:),   allocatable :: typespin
+        logical ::multi
+        integer::first_fun
+        integer::ntypes
+    end type
+
+    interface KAN_descriptor
+        module procedure init_KAN_descriptor
+        module procedure copy_KAN_descriptor
+    end interface KAN_descriptor
+
+    double precision, parameter, private :: PI     = 3.14159265358979d0
+    double precision, parameter, private :: PI_INV = 1.0d0/PI
+    double precision, parameter, private :: PI2    = 2.0d0*PI
+    double precision, parameter, private :: EPS    = 1.0d-12
+
+
+    contains
+
+    type(KAN_descriptor) function copy_KAN_descriptor(kan) result(param)
+        implicit none
+        type(KAN_descriptor),intent(in)::kan
+        integer::ntypes
+        param%npoints = kan%npoints
+        param%nk = kan%nk
+        allocate(param%b_KAN(param%nk))
+        allocate(param%bk_r1(param%nk))
+        allocate(param%bk_a1(param%nk))
+
+        param%multi = kan%multi
+
+        if (param%multi) then
+            allocate(param%bk_r2(param%nk))
+            allocate(param%bk_a2(param%nk))
+            allocate(param%values_r2(param%npoints,param%nk))
+            allocate(param%values_a2(param%npoints,param%nk))
+        end if
+
+        allocate(param%values_r1(param%npoints,param%nk))
+        allocate(param%values_a1(param%npoints,param%nk))
+
+        param%b_KAN = kan%b_KAN(:)
+        param%values_r1 = kan%values_r1(:,:)
+
+        if (param%multi) then
+            param%values_r2 = kan%values_r2(:,:)
+        end if
+        param%values_a1 = kan%values_a1(:,:)
+        if (param%multi) then
+            param%values_a2 = kan%values_a2(:,:)
+        end if
+        param%bk_r1 = kan%bk_r1(:)
+        if (param%multi) then
+            param%bk_r2 = kan%bk_r2(:)
+        end if
+        param%bk_a1 = kan%bk_a1(:)
+        if (param%multi) then
+            param%bk_a2 = kan%bk_a2(:)
+        end if
+        allocate(param%points_r(param%npoints),param%points_a(param%npoints))
+        param%points_r = kan%points_r(:)
+        param%points_a = kan%points_a(:)
+
+        param%r_Rc = kan%r_Rc
+        param%r_Nc = kan%r_Nc
+        param%a_Rc = kan%a_Rc
+        param%rc_min = kan%rc_min
+        param%first_fun = kan%first_fun
+        ntypes = ubound(kan%typeid,1)
+        param%ntypes = ntypes
+    
+        allocate(param%typeid(ntypes),          &
+                  param%typespin(ntypes))
+        param%typeid =  kan%typeid
+        param%typespin = kan%typespin
+
+    end
+
+
+    type(KAN_descriptor) function init_KAN_descriptor(ntypes,u) result(param)
+        implicit none
+        integer,intent(in) ::ntypes
+        integer,          optional, intent(in) :: u
+        integer::i
+        !real(8)::x0,y0,r
+        integer ::  s
+
+
+        read(u) param%npoints
+        read(u) param%nk
+        allocate(param%b_KAN(param%nk))
+        allocate(param%bk_r1(param%nk))
+        allocate(param%bk_a1(param%nk))
+        
+
+        param%ntypes = ntypes
+
+        if (ntypes > 1) then
+            allocate(param%bk_r2(param%nk))
+            allocate(param%bk_a2(param%nk))
+            allocate(param%values_r2(param%npoints,param%nk))
+            allocate(param%values_a2(param%npoints,param%nk))
+        end if
+
+        allocate(param%values_r1(param%npoints,param%nk))
+        allocate(param%values_a1(param%npoints,param%nk))
+
+
+        read(u) param%b_KAN
+        read(u) param%values_r1
+        if (ntypes > 1) then
+            read(u) param%values_r2
+        end if
+        read(u) param%values_a1
+        if (ntypes > 1) then
+            read(u) param%values_a2
+        end if
+        read(u) param%bk_r1
+        if (ntypes > 1) then
+            read(u) param%bk_r2
+        end if
+        read(u) param%bk_a1
+        if (ntypes > 1) then
+            read(u) param%bk_a2
+        end if
+        allocate(param%points_r(param%npoints),param%points_a(param%npoints))
+
+
+        read(u) param%r_Rc,param%r_Nc,param%a_Rc,param%a_Nc
+        read(u) param%rc_min
+        read(u) param%first_fun
+        do i=1,param%npoints
+            param%points_r(i) = dble(i-1)*(param%r_Rc-param%rc_min)/dble(param%npoints-1) + param%rc_min
+            param%points_a(i) = dble(i-1)*2/dble(param%npoints-1) -1d0 
+        end do
+
+        if (ntypes > 1) then
+            param%multi = .true.
+         else
+            param%multi = .false.
+         end if
+     
+         allocate(param%typeid(ntypes),          &
+                  param%typespin(ntypes))
+
+        do i = 1, ntypes
+            param%typeid(i) = i
+         end do
+     
+         s = -ntypes/2
+         do i = 1,  ntypes
+            if ((s == 0) .and. (mod(ntypes, 2) == 0)) s = s + 1
+            param%typespin(i) = dble(s)
+            s = s + 1
+         end do
+
+        !for debug
+        !open(101,file="test.txt")
+        !open(102,file="test_true.txt")
+        !do i=1,param%npoints
+        !    call random_number(r)
+        !    x0 = r*(param%r_Rc-param%rc_min) + param%rc_min
+            !x0 = dble(i-1)*(param%r_Rc-param%rc_min)/dble(2*param%npoints-1) + param%rc_min
+        !    call linear_interpolation(param%points_r,  param%values_r1(:,1), param%npoints, x0, y0)
+        !    write(101,*) x0,y0
+        !    write(102,*) param%points_r(i),param%values_r1(i,1)
+        !end do
+        !close(101)
+        !close(102)
+        !stop
+    end 
+
+
+    subroutine linear_interpolation(x, y, n, x0, y0)
+        integer, intent(in) :: n           
+        real(8), intent(in) :: x(n)        
+        real(8), intent(in) :: y(n)        
+        real(8), intent(in) :: x0          
+        real(8), intent(out) :: y0         
+        
+        integer :: low, high, mid
+        real(8) :: t
+
+        low = 1
+        high = n
+
+        do while (high - low > 1)
+            mid = (low + high) / 2
+            if (x(mid) > x0) then
+                high = mid
+            else
+                low = mid
+            end if
+        end do
+
+        t = (x0 - x(low)) / (x(high) - x(low))
+        y0 = y(low) + t * (y(high) - y(low))
+    end subroutine linear_interpolation
+
+    subroutine linear_interpolation_get_highlow(x, n, x0,high,low)
+        implicit none
+        integer, intent(in) :: n         
+        real(8), intent(in) :: x(n)          
+        real(8), intent(in) :: x0   
+        integer,intent(out) ::high,low    
+        integer :: mid
+
+        low = 1
+        high = n
+
+        do while (high - low > 1)
+            mid = (low + high) / 2
+            if (x(mid) > x0) then
+                high = mid
+            else
+                low = mid
+            end if
+        end do
+    end
+
+    subroutine linear_interpolation_multi_highlow(high,low,x, y, n, nk,x0, y0)
+        implicit none
+        integer, intent(in) :: n,nk           
+        real(8), intent(in) :: x(n)        
+        real(8), intent(in) :: y(n,nk)        
+        real(8), intent(in) :: x0          
+        real(8), intent(out) :: y0(nk)   
+        integer,intent(in)::high,low      
+        
+        integer ::  mid,ik
+        real(8) :: t
+        t = (x0 - x(low)) / (x(high) - x(low))
+        do ik = 1,nk
+            y0(ik) = y(low,ik) + t * (y(high,ik) - y(low,ik))
+        end do
+    end
+
+
+    subroutine linear_interpolation_multi_highlow_df(high,low,x, y, n, nk,x0, y0,dy0)
+        implicit none
+        integer, intent(in) :: n,nk           
+        real(8), intent(in) :: x(n)        
+        real(8), intent(in) :: y(n,nk)        
+        real(8), intent(in) :: x0          
+        real(8), intent(out) :: y0(nk),dy0(nk)   
+        integer,intent(in)::high,low      
+        
+        integer ::  ik
+        real(8) :: t
+        t = (x0 - x(low)) / (x(high) - x(low))
+        do ik = 1,nk
+            y0(ik) = y(low,ik) + t * (y(high,ik) - y(low,ik))
+            dy0(ik) =  (y(high,ik) - y(low,ik))/(x(high) - x(low))
+        end do
+    end
+
+    subroutine linear_interpolation_multi_highlow_dfonly(high,low,x, y, n, nk,dy0)
+        implicit none
+        integer, intent(in) :: n,nk           
+        real(8), intent(in) :: x(n)        
+        real(8), intent(in) :: y(n,nk)       
+        real(8), intent(out) :: dy0(nk)   
+        integer,intent(in)::high,low      
+        
+        integer ::  ik
+        do ik = 1,nk
+            dy0(ik) =  (y(high,ik) - y(low,ik))/(x(high) - x(low))
+        end do
+    end
+
+    subroutine linear_interpolation_multi(x, y, n, nk,x0, y0)
+        implicit none
+        integer, intent(in) :: n,nk           
+        real(8), intent(in) :: x(n)        
+        real(8), intent(in) :: y(n,nk)        
+        real(8), intent(in) :: x0          
+        real(8), intent(out) :: y0(nk)         
+        
+        integer :: low, high, mid,ik
+        real(8) :: t
+
+        low = 1
+        high = n
+
+        do while (high - low > 1)
+            mid = (low + high) / 2
+            if (x(mid) > x0) then
+                high = mid
+            else
+                low = mid
+            end if
+        end do
+
+        t = (x0 - x(low)) / (x(high) - x(low))
+        do ik = 1,nk
+            y0(ik) = y(low,ik) + t * (y(high,ik) - y(low,ik))
+        end do
+    end subroutine linear_interpolation_multi
+
+  subroutine kan_radial(kan,high,low, R_ij, d_ij,points_r,values_r,values, deriv_i, deriv_j)
+    implicit none
+
+    type(KAN_descriptor),                     intent(in) :: kan
+    integer,intent(in)::high,low
+    double precision, dimension(3),             intent(in)    :: R_ij
+    double precision,                           intent(in)    :: d_ij
+    double precision, dimension(:,:),           intent(in)   :: values_r
+    double precision, dimension(:),             intent(in)   ::points_r
+    double precision, dimension(:),             intent(out)   :: values
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_i
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_j
+
+    !double precision                     :: w_ij, dw_ij
+    double precision, dimension(kan%nk) :: f, df
+    integer                              :: i
+
+
+    call linear_interpolation_multi_highlow_df(high,low,points_r, values_r,&
+            kan%npoints,kan%nk,d_ij, f,df)
+    
+    if (present(deriv_i) .and. present(deriv_j)) then   
+        do i=1,kan%nk
+            deriv_i(:,i) = -df(i)*R_ij/d_ij
+        end do
+        deriv_j(1:3,1:kan%nk) = - deriv_i(1:3,1:kan%nk)
+    end if   
+
+    values(1:kan%nk) = f(1:kan%nk)
+  end subroutine kan_radial    
+
+  subroutine kan_angular(kan,high,low, R_ij, R_ik, d_ij, d_ik, cos_ijk, points_a,values_a,values, &
+                         deriv_i, deriv_j, deriv_k)
+
+    implicit none
+
+    type(KAN_descriptor),                     intent(in) :: kan
+    integer,intent(in)::high,low
+    double precision, dimension(3),             intent(in)    :: R_ij, R_ik
+    double precision,                           intent(in)    :: d_ij, d_ik
+    double precision, dimension(:,:),           intent(in)   :: values_a
+    double precision, dimension(:),              intent(in)   :: points_a
+    double precision,                           intent(in)    :: cos_ijk
+    double precision, dimension(:),             intent(out)   :: values
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_i
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_j
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_k
+
+    double precision                     :: w_ijk
+    double precision                     :: fc_j, dfc_j, fc_k, dfc_k
+    double precision, dimension(kan%nk) :: f, df
+    double precision                     :: id_ij2, id_ik2, id_ij_ik
+    double precision, dimension(3)       :: di_cos_ikj, dj_cos_ikj, dk_cos_ikj
+    double precision, dimension(3)       :: di_w_ijk, dj_w_ijk, dk_w_ijk
+    integer                              :: i
+
+
+    fc_j = sfb_fc(d_ij, kan%a_Rc)
+    fc_k = sfb_fc(d_ik, kan%a_Rc)
+    w_ijk = fc_j*fc_k
+
+    call linear_interpolation_multi_highlow_df(high,low,points_a, values_a,&
+            kan%npoints,kan%nk,cos_ijk, f,df)
+
+    values(1:kan%nk) = w_ijk*f
+
+    if (present(deriv_i) .and. present(deriv_j) .and. present(deriv_k)) then
+       dfc_j = sfb_fc_d1(d_ij, kan%a_Rc)
+       dfc_k = sfb_fc_d1(d_ik, kan%a_Rc)
+       
+       id_ij2 = 1.0d0/(d_ij*d_ij)
+       id_ik2 = 1.0d0/(d_ik*d_ik)
+       id_ij_ik = 1.0d0/(d_ij*d_ik)
+       ! d/dR_i (cos_ijk)
+       di_cos_ikj = cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
+       ! d/dR_j (cos_ijk)
+       dj_cos_ikj = -cos_ijk*R_ij*id_ij2 + R_ik*id_ij_ik
+       ! d/dR_k (cos_ijk)
+       dk_cos_ikj = -cos_ijk*R_ik*id_ik2 + R_ij*id_ij_ik
+       ! d/dR_i (w_ijk)
+       di_w_ijk = -(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
+       ! d/dR_j (w_ijk)
+       dj_w_ijk = dfc_j*fc_k*R_ij/d_ij
+       ! d/dR_k (w_ijk)
+       dk_w_ijk = fc_j*dfc_k*R_ik/d_ik
+       forall (i=1:kan%nk)
+          ! d/dR_i (w_ijk*f)
+          deriv_i(:,i) = di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+          ! d/dR_j (w_ijk*f)
+          deriv_j(:,i) = dj_w_ijk(:)*f(i) + w_ijk*df(i)*dj_cos_ikj(:)
+          ! d/dR_k (w_ijk*f)
+          deriv_k(:,i) = dk_w_ijk(:)*f(i) + w_ijk*df(i)*dk_cos_ikj(:)
+       end forall
+    end if
+
+  end subroutine kan_angular  
+
+
+subroutine sfb_eval_kan(kan, coo0, nat, itype1, coo1, nv,&
+                      values, deriv0, deriv1)
+
+    implicit none
+
+    type(KAN_descriptor),                          intent(inout) :: kan
+    !integer,                                         intent(in)    :: itype0
+    double precision, dimension(3),                  intent(in)    :: coo0
+    integer,                                         intent(in)    :: nat
+    integer,          dimension(nat),                intent(in)    :: itype1
+    double precision, dimension(3,nat),              intent(in)    :: coo1
+    integer,                                         intent(in)    :: nv
+    double precision, dimension(nv),                 intent(out)   :: values
+    double precision, dimension(3,nv),     optional, intent(out)   :: deriv0
+    double precision, dimension(3,nv,nat), optional, intent(out)   :: deriv1
+    !logical,intent(in) ::multi
+    !integer,          dimension(:),intent(in) :: typeid
+    !double precision, dimension(:),intent(in) :: typespin
+
+    double precision, dimension(kan%nk)   :: sfb_values,work1,work2
+    double precision, dimension(:,:), allocatable :: sfb_deriv_i
+    double precision, dimension(:,:), allocatable :: sfb_deriv_j
+    double precision, dimension(:,:), allocatable :: sfb_deriv_k
+
+    logical                        :: do_deriv
+    double precision, dimension(3) :: R_ij, R_ik
+    double precision               :: d_ij, d_ik
+    double precision               :: cos_ijk
+    double precision               :: s_j, s_k
+    integer                        :: j, k
+    real(8)::fc_j,fc_k,w_ijk 
+    integer::high,low
+
+    !write(*,* ) "in sfb_eval_kan"
+
+    if (present(deriv0) .and. present(deriv1)) then
+       do_deriv = .true.
+       deriv0(:,:) = 0.0d0
+       deriv1(:,:,:) = 0.0d0
+       allocate(sfb_deriv_i(3, kan%nk), &
+                sfb_deriv_j(3, kan%nk), &
+                sfb_deriv_k(3, kan%nk))
+    else
+       do_deriv = .false.
+    end if
+
+    values= kan%b_KAN + kan%bk_r1 + kan%bk_a1
+    if (kan%multi) then
+        values = values + kan%bk_r2 + kan%bk_a2
+    end if
+
+    
+
+    s_j = 1.0d0
+    for_j : do j = 1, nat
+       R_ij = coo1(1:3, j) - coo0(1:3)
+       d_ij = sqrt(dot_product(R_ij, R_ij))
+       if ((d_ij <= kan%r_Rc) .and. (d_ij > EPS)) then
+            !write(*,*) j,d_ij
+          ! evaluate radial basis functions
+          !i1 = sfb%r_i1
+          !i2 = sfb%r_f1
+          !N = sfb%r_N
+          call linear_interpolation_get_highlow(kan%points_r, kan%npoints, d_ij,high,low)
+          if (do_deriv) then
+            
+            call kan_radial(kan,high,low, R_ij, d_ij,kan%points_r,kan%values_r1,sfb_values, &
+                    deriv_i=sfb_deriv_i, deriv_j=sfb_deriv_j)
+            !call linear_interpolation_multi_highlow(high,low,kan%points_r, kan%values_r1,kan%npoints,kan%nk,d_ij,sfb_values)
+
+            !call linear_interpolation_multi(kan%points_r, kan%values_r1,kan%npoints,kan%nk,d_ij,sfb_values)
+            values = values +  sfb_values
+            !write(*,*) "v1",sfb_values
+             !call sfb_radial(sfb, R_ij, d_ij, sfb_values, &
+             !                deriv_i=sfb_deriv_i, deriv_j=sfb_deriv_j)
+             !values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+             deriv0(1:3, :) = deriv0(1:3, :) + sfb_deriv_i(1:3, :)
+             deriv1(1:3, :, j) = deriv1(1:3, :, j) + sfb_deriv_j(1:3, :)
+          else
+            call kan_radial(kan,high,low, R_ij, d_ij,kan%points_r,kan%values_r1,sfb_values)
+             !call sfb_radial(sfb, R_ij, d_ij, sfb_values)
+             values = values +  sfb_values
+             !values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+          end if
+
+          ! redundant radial basis in case of multi-component systems
+          !i1 = sfb%r_i2
+          !i2 = sfb%r_f2
+          !N = sfb%r_N
+          if (kan%multi) then
+             s_j = kan%typespin(kan%typeid(itype1(j)))
+             !s_j = 0 !debug
+             !write(*,*) j ,s_j 
+             !call linear_interpolation_multi_highlow(high,low,kan%points_r, kan%values_r2,kan%npoints,kan%nk,d_ij,sfb_values)
+             !call linear_interpolation_multi(kan%points_r, kan%values_r2,kan%npoints,kan%nk,d_ij,sfb_values)
+             call kan_radial(kan,high,low, R_ij, d_ij,kan%points_r,kan%values_r2,sfb_values, &
+                    deriv_i=sfb_deriv_i, deriv_j=sfb_deriv_j)
+             values = values + s_j*sfb_values
+             !write(*,*) "v2", s_j*sfb_values
+             if (do_deriv) then
+                deriv0(1:3, :) = deriv0(1:3, :) &
+                                   + s_j*sfb_deriv_i(1:3, :)
+                deriv1(1:3, :, j) = deriv1(1:3, :, j) &
+                                      + s_j*sfb_deriv_j(1:3, :)
+             end if
+          end if
+
+       end if  ! within radial cutoff
+
+       if (d_ij > kan%a_Rc) cycle for_j
+       for_k : do k = j+1, nat
+          R_ik = coo1(1:3, k) - coo0(1:3)
+          d_ik = sqrt(dot_product(R_ik, R_ik))
+
+          !write(*,*) j,k,d_ik
+          
+          if ((d_ik > kan%a_Rc) .or. (d_ik < EPS)) cycle for_k
+          cos_ijk = dot_product(R_ij, R_ik)/(d_ij*d_ik)
+          !if (cos_ijk > 1d0) cos_ijk = 1d0
+          !if (cos_ijk < -1d0) cos_ijk = -1d0
+
+          fc_j = sfb_fc(d_ij, kan%a_Rc)
+          fc_k = sfb_fc(d_ik, kan%a_Rc)
+          w_ijk = fc_j*fc_k
+
+          ! evaluate angular basis functions
+          !i1 = sfb%a_i1
+          !i2 = sfb%a_f1
+          !N = sfb%a_N
+          call linear_interpolation_get_highlow(kan%points_a, kan%npoints, cos_ijk,high,low)
+          if (do_deriv) then
+            
+            call kan_angular(kan,high,low, R_ij, R_ik, d_ij, d_ik, cos_ijk,kan%points_a, &
+                    kan%values_a1,sfb_values, deriv_i=sfb_deriv_i,      &
+                    deriv_j=sfb_deriv_j, deriv_k=sfb_deriv_k)
+            !call linear_interpolation_multi_highlow(high,low,kan%points_a, kan%values_a1,kan%npoints,kan%nk,cos_ijk,sfb_values)
+            !write(*,*) "--------------"
+            !write(*,*) w_ijk,cos_ijk,high,low
+            !write(*,*) sfb_values
+            !write(*,*) "--------------"
+            !stop
+             !call linear_interpolation_multi(kan%points_a, kan%values_a1,kan%npoints,kan%nk,cos_ijk,sfb_values)
+             !sfb_values = sfb_values*w_ijk
+             values = values + sfb_values
+            ! write(*,*) "a1",sfb_values*w_ijk
+             !call sfb_angular(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, &
+             !                 sfb_values, deriv_i=sfb_deriv_i,      &
+             !                 deriv_j=sfb_deriv_j, deriv_k=sfb_deriv_k)
+             !values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+              deriv0(1:3, :) = deriv0(1:3, :) + sfb_deriv_i(1:3, :)
+              deriv1(1:3, :, j) = deriv1(1:3, :, j) + sfb_deriv_j(1:3, :)
+              deriv1(1:3, :, k) = deriv1(1:3, :, k) + sfb_deriv_k(1:3, :)
+          else
+            call kan_angular(kan,high,low, R_ij, R_ik, d_ij, d_ik, cos_ijk,kan%points_a, &
+                    kan%values_a1,sfb_values)
+             !call sfb_angular(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, sfb_values)
+             values = values + sfb_values
+          end if
+
+          ! redundant angular basis in case of multi-component systems
+          !i1 = sfb%a_i2
+          !i2 = sfb%a_f2
+          !N = sfb%a_N
+          if (kan%multi) then
+             s_k = kan%typespin(kan%typeid(itype1(k)))
+             !s_k = 0 !debug
+             !s_j = 0 !debug
+             !write(*,*) j ,k,s_j,s_k 
+             !call linear_interpolation_multi_highlow(high,low,kan%points_a, kan%values_a2,kan%npoints,kan%nk,cos_ijk,sfb_values)
+             
+             !call linear_interpolation_multi(kan%points_a, kan%values_a2,kan%npoints,kan%nk,cos_ijk,sfb_values)
+             !sfb_values = sfb_values*w_ijk
+
+             
+
+             !write(*,*) "a2",s_j*s_k*sfb_values*w_ijk
+             if (do_deriv) then
+                call kan_angular(kan,high,low, R_ij, R_ik, d_ij, d_ik, cos_ijk,kan%points_a, &
+                    kan%values_a2,sfb_values, deriv_i=sfb_deriv_i,      &
+                    deriv_j=sfb_deriv_j, deriv_k=sfb_deriv_k)
+                values = values + s_j*s_k*sfb_values!*w_ijk
+
+                deriv0(1:3, :) = deriv0(1:3, :) &
+                                   + s_j*s_k*sfb_deriv_i(1:3, :)
+                deriv1(1:3, :, j) = deriv1(1:3, :, j) &
+                                      + s_j*s_k*sfb_deriv_j(1:3, :)
+                deriv1(1:3, :, k) = deriv1(1:3, :, k) &
+                                      + s_j*s_k*sfb_deriv_k(1:3, :)
+             else
+                call kan_angular(kan,high,low, R_ij, R_ik, d_ij, d_ik, cos_ijk,kan%points_a, &
+                    kan%values_a2,sfb_values)
+                values = values + s_j*s_k*sfb_values!*w_ijk
+             end if
+             
+          end if
+       end do for_k
+    end do for_j
+
+    !write(*,*) values
+    call ff_activate(kan%first_fun, values, work1, work2)
+    values = work1 
+    do k =1,kan%nk
+        deriv0(1:3,k) = deriv0(1:3,k)*work2(k)
+        deriv1(1:3,k,:) = deriv1(1:3,k,:)*work2(k)
+    end do
+
+    if (do_deriv) deallocate(sfb_deriv_i, sfb_deriv_j, sfb_deriv_k)
+
+  end subroutine sfb_eval_kan
+
+  function sfb_fc(Rij, Rc) result(fc)
+
+    implicit none
+
+    double precision, intent(in) :: Rij, Rc
+    double precision             :: fc
+
+    if (Rij >= Rc) then
+       fc  = 0.0d0
+    else
+       fc  =  0.5d0*(cos(PI/Rc*Rij) + 1.0d0)
+    end if
+
+  end function sfb_fc
+
+  function sfb_fc_d1(Rij, Rc) result(dfc)
+    implicit none
+
+    double precision, intent(in) :: Rij, Rc
+    double precision             :: dfc
+
+    double precision :: a
+
+    if (Rij >= Rc) then
+       dfc = 0.0d0
+    else
+       a = PI/Rc
+       dfc = -0.5d0*a*sin(a*Rij)
+    end if
+
+  end function sfb_fc_d1
+
+end module 
\ No newline at end of file
diff -Naru src/ext/chebyshev.f90 src_modified/ext/chebyshev.f90
--- src/ext/chebyshev.f90	2024-09-06 10:37:30
+++ src_modified/ext/chebyshev.f90	2024-09-06 10:37:30
@@ -38,7 +38,7 @@
   !                   Evaluate Chebyshev polynomials                   !
   !--------------------------------------------------------------------!
 
-  function chebyshev_polynomial(r, r0, r1, n) result(T)
+  pure function chebyshev_polynomial(r, r0, r1, n) result(T)
     ! Arguments:
     !    r        function argument
     !    r0, r1   the Chebyshev polynomials will be rescaled from [-1,1]
@@ -78,7 +78,7 @@
   !             First derivative of Chebyshev polynomials              !
   !--------------------------------------------------------------------!
 
-  function chebyshev_polynomial_d1(r, r0, r1, n) result(dT)
+  pure function chebyshev_polynomial_d1(r, r0, r1, n) result(dT)
     ! Arguments:
     !    r        function argument
     !    r0, r1   the Chebyshev polynomials will be rescaled from [-1,1]
diff -Naru src/ext/feedforward.mod src_modified/ext/feedforward.mod
--- src/ext/feedforward.mod	2024-09-06 15:36:47
+++ src_modified/ext/feedforward.mod	1970-01-01 09:00:00
@@ -1,9 +0,0 @@
-‹      åœ[sâ¸Çßõ)ôfò0§,ßıè'K-Ê@æäÉÅ€™øœÄ¤€	“ıôÛ’1X|å–Ù­IjbĞ¯[İÿ–d)w·oì9}ü²œÿ|ğ[°Z‡ËKD—ğlL7Á/VË¼‚ùb¹ÚNWóÿ,lµZ7ø_(ùáÁğİ’¢`³]®ş/a)Õ¨„•ıK’oK}ñk%	Üju\¯ûàvğ¤ÿgğ­ÿ¥Û»ıñşrèÚhw‘ÜÄ2üsz½AÛoî‡@ÖR±FáFÂ­Şà®ÛvzXc¯’qrMé6%Û+j¾Ih¾8í¶;áV{ĞxkQÛìş‡¶5$½/ëğ¯ pi«w®·KrMß"ÂEuqq—~°¤èyú‘t5¢å<(% p£ãŞºQ‡aÂ„šwc?ÎØùÚsQ§{ïöGİA_Œjâªÿ2ıUŒ{¦£ä?­é-”òVs ”r.q–¥-@z.Ä½µ#dÌ;Y/_ªá”‚¢¦A×<r8…½Mø±–F‘9 İáÛ§8Ú½MŸŠ¤•‰Y2”v•€á'_{İöşsw~’÷&í
-ÀN ¤ªkò}½%+¶fÆ"–|¶Œ ÜoüPóCJf+Œ6«0Z‡³›}¥¤ngâ¹SPi8ŞNúí1ø»=\<†$ÂçÄ@‰ã,ô±ÓãZF¿ ³•2 ¸uÊ=>­Ç~ªâûÅã€Çë21®*İû!ø»;ş2rÜ8µ¼q÷ncÇ»sÇ±'£e×!É5o…œ5Â F¼m¦ß/g@L æwùœ°³¼Ã¿¿5èwŸ][ÒÆC1-õÉš®ŸJµµ<KC2p±›}¥>¨~’[ÒnF Rù…µ„¼¨‘jğ»ã…OQ€Å~m‚hN«°—O¢îx8 ¯ô8(/û,•Šóä4‡E	Nñ@­µ{}—Ò"ª¨Tô40£ÉWo0wû.âµJô7çqä»ÿóÓğ³À‡Pˆ‹ <@ıëvX¹:PFC·MÍÅÃa›¦˜LÑªé‹0š>óVê,\ÅV6¯TiIÌ±"‘¬²ÜÂ¤Teª_™á(6Ü`Ñ6}~^Î`º*ÊƒñûÒV[–ÌÛrz°ÔÚƒ‡I%õ^¨ĞTĞèyğìçL£Ë*ûı 3é¹±õ·İË3=©2ş¡¬sÄˆ'V¨üµ[XVT9)BÉêàhœ‰b.P²LŒf›ğÅÖy\Y,q‰(2@¥ÊÚRU¬jXÕ±jˆl2cfOÓèGØ.£3YUêw¤²Pm¬ÉX#BfMaÌó`E'µ8qŠÃ‰5Z)Zš†5iÖL¬YXG².3ààêğ•xu:mjé
-ÖU¤kX×±n`İÄº%F¶ò`ãGÛ üñ´YŸ4$’™ ?ô­o,8%Ãi¨Œ“ıÏÁY't‘êØ0°a
-İjXw¿wŠ4¸¨Ø6¥4cI4IØŒsíæ€0)ŒËsÉ]Vß²ŞFÙ€6Yš6u¡«Mƒ‘¯¦Ñ|ùR+@²µ¿¢	Èñ<çÑ‡×ó;îĞíwÜ~û±<5M“YrHD”6#NÄŸ¯s¨5Wq‹%£E°¥`KúİÒğöºòléÔÀ–‰,[6¶ell+Bhdäy9Ÿe|´ÏLaŒs!ÄO„l¦(¶í¸zÛf–Ûâ¹ıéz†Ÿ…)‘eLäX¾‰œÕo"ÓÅ´FNçyùÜwn ÚU‡|H´Â!k”r{Şğà„[änT8k&²ûÛØù:,D†hYOß‚sÏjk9‘ãP!*„À·8K	]yMp†p?Ê¢Åfèğ£ßâA€¢Æ+­¯ïU—ËˆUTŸ¸¹éƒR“òÊ‹s:ÄÆD‘ÅV²uY¶øPÕL¥°W63I(ä¹í‰7‚ÛW´fÈì#ŠP*"ŠÆŞ‘¬Jl´™x1zøR¬Ôª,|øºüÁCgrÿ(S\uù¦xÒf}BùÂÅ¾}Tîqû ¿NÒ¾ğ^QËbïâ–«¸ş¨¦at9?¾m6Ò«İ6uêU¢N£5Ùı<ZÍBO£K1ô¹Cc†t?´ÿp<§£wLv‡;-¶„_@¢q}¢©WéÈ‡èWÃ¤@ƒ¬ˆŞ¯	À–9aâ±nqØ›SRœ£4^öø-”û„(c…DØ£¡Üeq”}DY«Ew ú´"BuRÙòõÀ0Öûßt¶üN#±/ªÅäïä’ë;­Ö—qƒr)7±¥7O&Åm üÇ1Ù6’Ç1‚…B…>\Cøt5-|Y†è5h?	/Ô0Ë=_ø$¼<¼o@ñÀµ¹]¯§Õş^‡r“ìÃAüî
-§+•å^ÿPøş½®°R³‚˜ò“Ñ œòáf"lĞJ°Må30(öğhÒ«:MÓè¼?´kÔ%Ãà\¢]\!…Ã3ƒfŸ9!Œdğ#xş#ó`_<!LHÉÃ“>E…¬àö×“ñŞ“Ÿ¦šghÇ8òò-X}_®ƒÆh0¤ë{s©€,?
-!Ä±x‡˜×	‹×nK¾
-'ßY†h•ƒø-}ĞÙ˜á3+•¥ä*•eğİ¯_¥ûM®ûõËw¿•M\ÀÎÎ&jC|ê 4* m9;™ø×z‚|\Eû‡û"wÍVè"š?Ï‰ß}ô'è3®£Yfn°a\´Ÿ÷ƒ"»ö0]4(jğHí‰ ,ıd›õOIÔL›m“+‘<J³Ée…ı,ùÅñxtß{ug'ï="“L÷©Y÷Ñ}?\ÿ`Ô¨ÿPÄút5{J é^šSˆ|wzúp4šÜ»ô‡3,:b”'r;AAœM|ÎdLúN'rğòStºÛˆKÜú§Ï\z6¹'bj˜º„_H£{œ.ßKF¦—jCœ¡—ÌL/†©i/Áäe½š`joÆHm :j2‰(=r8_orq*OK¤P…_M÷3Ìx·Ù1L{Á¹wï&ƒÉ¨2(ŠéıDû=§ÿ§ génÁïï›À_oVá<ÈÁ/sñ08Øñàô&®(3gSQIÒÃ†‹0
-ıÙ²ÈÑ§$MÖø’ôİ]—Ò¿sø12VÊË˜è¨ğ„6¼Â(9/1
-73!e¬Ê™fp‹ œcZğ;3}JÆ»ãQñi#ë2úx’nÛ‚ƒ32Ş§Ù/[ÃeO€Èxw,Dx¸~kÏ,ÈÉa†í•à÷İË8»?Ùä¿”Ôw{Ç·>wOËîq¦7á¢}Ãt»±zƒşéF<rñH  
\ No newline at end of file
diff -Naru src/ext/sfbasis.f90 src_modified/ext/sfbasis.f90
--- src/ext/sfbasis.f90	2024-09-06 10:37:30
+++ src_modified/ext/sfbasis.f90	2024-09-06 10:37:30
@@ -433,10 +433,316 @@
 
   end function load_SFBasis_ASCII
 
+  subroutine cleararray(nv,nat,deriv0,deriv1)
+   implicit none
+   integer,intent(in) :: nv,nat
+   double precision, dimension(3,nv),     intent(out)   :: deriv0
+   double precision, dimension(3,nv,nat), intent(out)   :: deriv1
+   deriv0(:,:) = 0.0d0
+   deriv1(:,:,:) = 0.0d0
+  end subroutine
 
+  subroutine update_deriv_r(i1,i2,j,N,sfb_values,sfb_deriv_i,sfb_deriv_j,&
+      values,deriv0,deriv1)
+   implicit none
+   integer::i1,i2,j,k,N
+   double precision, dimension(:),     intent(in)   ::sfb_values
+   double precision, dimension(:,:),     intent(in)   :: sfb_deriv_i
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_j
+   double precision, dimension(:),     intent(inout)   ::values
+   double precision, dimension(:,:),     intent(inout)   :: deriv0
+   double precision, dimension(:,:,:), intent(inout)   :: deriv1
+
+
+   values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+   deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
+   deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
+
+   return
+  end subroutine
+
+  subroutine update_deriv_r_multi(i1,i2,j,N,sfb_values,sfb_deriv_i,sfb_deriv_j,&
+      values,deriv0,deriv1,s_j,do_deriv)
+   implicit none
+   integer::i1,i2,j,k,N
+   double precision, dimension(:),     intent(in)   ::sfb_values
+   double precision, dimension(:,:),     intent(in)   :: sfb_deriv_i
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_j
+   double precision, dimension(:),     intent(inout)   ::values
+   double precision, dimension(:,:),     intent(inout)   :: deriv0
+   double precision, dimension(:,:,:), intent(inout)   :: deriv1
+   double precision,intent(in):: s_j
+   logical,intent(in)::do_deriv
+
+   values(i1:i2) = values(i1:i2) + s_j*sfb_values(1:N)
+   if (do_deriv) then
+      deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
+                         + s_j*sfb_deriv_i(1:3, 1:N)
+      deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) &
+                            + s_j*sfb_deriv_j(1:3, 1:N)
+   end if
+
+   return
+  end subroutine
+
+  subroutine update_deriv(i1,i2,j,k,N,sfb_values,sfb_deriv_i,sfb_deriv_j,sfb_deriv_k,&
+      values,deriv0,deriv1)
+   implicit none
+   integer::i1,i2,j,k,N
+   double precision, dimension(:),     intent(in)   ::sfb_values
+   double precision, dimension(:,:),     intent(in)   :: sfb_deriv_i
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_j
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_k
+   double precision, dimension(:),     intent(inout)   ::values
+   double precision, dimension(:,:),     intent(inout)   :: deriv0
+   double precision, dimension(:,:,:), intent(inout)   :: deriv1
+
+
+   values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+   deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
+   deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
+   deriv1(1:3, i1:i2, k) = deriv1(1:3, i1:i2, k) + sfb_deriv_k(1:3, 1:N)
+
+   return
+  end subroutine
+
+  subroutine update_deriv_multi(i1,i2,j,k,N,sfb_values,sfb_deriv_i,sfb_deriv_j,sfb_deriv_k,&
+      values,deriv0,deriv1,do_deriv,s_j,s_k)
+   implicit none
+   integer::i1,i2,j,k,N
+   double precision, dimension(:),     intent(in)   ::sfb_values
+   double precision, dimension(:,:),     intent(in)   :: sfb_deriv_i
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_j
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_k
+   double precision, dimension(:),     intent(inout)   ::values
+   double precision, dimension(:,:),     intent(inout)   :: deriv0
+   double precision, dimension(:,:,:), intent(inout)   :: deriv1
+   logical,intent(in)::do_deriv
+   double precision,intent(in) ::s_j,s_k
+
+   values(i1:i2) = values(i1:i2) + s_j*s_k*sfb_values(1:N)
+   if (do_deriv) then
+      deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
+                         + s_j*s_k*sfb_deriv_i(1:3, 1:N)
+      deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) &
+                            + s_j*s_k*sfb_deriv_j(1:3, 1:N)
+      deriv1(1:3, i1:i2, k) = deriv1(1:3, i1:i2, k) &
+                            + s_j*s_k*sfb_deriv_k(1:3, 1:N)
+   end if
+   
+
+   return
+  end subroutine
+
+
   !========================= basis evaluation =========================!
 
+    subroutine sfb_eval_deriv(sfb, itype0, coo0, nat, itype1, coo1, nv, &
+                      values, deriv0, deriv1)
 
+    implicit none
+
+    type(FingerprintBasis),                          intent(inout) :: sfb
+    integer,                                         intent(in)    :: itype0
+    double precision, dimension(3),                  intent(in)    :: coo0
+    integer,                                         intent(in)    :: nat
+    integer,          dimension(nat),                intent(in)    :: itype1
+    double precision, dimension(3,nat),              intent(in)    :: coo1
+    integer,                                         intent(in)    :: nv
+    double precision, dimension(nv),                 intent(out)   :: values
+    double precision, dimension(3,nv),      intent(out)   :: deriv0
+    double precision, dimension(3,nv,nat),  intent(out)   :: deriv1
+
+    double precision, dimension(sfb%num_values)   :: sfb_values
+    double precision, dimension(:,:), allocatable :: sfb_deriv_i
+    double precision, dimension(:,:), allocatable :: sfb_deriv_j
+    double precision, dimension(:,:), allocatable :: sfb_deriv_k
+
+    logical                        :: do_deriv
+    double precision, dimension(3) :: R_ij, R_ik
+    double precision               :: d_ij, d_ik
+    double precision               :: cos_ijk
+    double precision               :: s_j, s_k
+    integer                        :: j, k, i1, i2, N
+    integer ::ii,kk
+    double precision::fc_j,dfc_j,id_ij2
+
+    call sfb_assert_init(sfb)
+
+    if (nv /= sfb%N) then
+       write(0,*) "Error: wrong number of basis functions in `sfb_eval'."
+       stop
+    end if
+
+    !if (present(deriv0) .and. present(deriv1)) then
+    !   do_deriv = .true.
+       deriv0(:,:) = 0.0d0
+       deriv1(:,:,:) = 0.0d0
+       !call cleararray(nv,nat,deriv0,deriv1)
+       allocate(sfb_deriv_i(3, sfb%num_values), &
+                sfb_deriv_j(3, sfb%num_values), &
+                sfb_deriv_k(3, sfb%num_values))
+    !else
+    !   do_deriv = .false.
+    !end if
+
+    values(1:sfb%N) = 0.0d0
+    s_j = 1.0d0
+
+    for_j : do j = 1, nat
+       R_ij = coo1(1:3, j) - coo0(1:3)
+       d_ij = sqrt(dot_product(R_ij, R_ij))
+       if ((d_ij <= sfb%r_Rc) .and. (d_ij > EPS)) then
+
+          ! evaluate radial basis functions
+          i1 = sfb%r_i1
+          i2 = sfb%r_f1
+          N = sfb%r_N
+          !if (do_deriv) then
+             call sfb_radial(sfb, R_ij, d_ij, sfb_values, &
+                             deriv_i=sfb_deriv_i, deriv_j=sfb_deriv_j)
+            !call update_deriv_r(i1,i2,j,N,sfb_values,sfb_deriv_i,sfb_deriv_j,&
+            !   values,deriv0,deriv1)
+            
+            !values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+            do concurrent (ii=1:N)
+               values(i1+ii-1) = values(i1+ii-1) + sfb_values(ii)
+            end do
+
+            do concurrent (kk=1:3,ii=1:N)
+               deriv0(kk, i1+ii-1) = deriv0(kk, i1+ii-1) + sfb_deriv_i(kk, ii)
+               deriv1(kk, i1+ii-1, j) = deriv1(kk, i1+ii-1, j) + sfb_deriv_j(kk, ii)
+            end do
+             !deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
+             !deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
+          !else
+          !   call sfb_radial(sfb, R_ij, d_ij, sfb_values)
+          !   values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+          !end if
+
+          ! redundant radial basis in case of multi-component systems
+          i1 = sfb%r_i2
+          i2 = sfb%r_f2
+          N = sfb%r_N
+          if (sfb%multi) then
+             s_j = sfb%typespin(sfb%typeid(itype1(j)))
+             !call update_deriv_r_multi(i1,i2,j,N,sfb_values,&
+             !  sfb_deriv_i,sfb_deriv_j,&
+             !  values,deriv0,deriv1,s_j,do_deriv)
+            do concurrent (ii=1:N)
+               values(i1+ii-1) = values(i1+ii-1) + s_j*sfb_values(ii)
+            end do
+            do concurrent (kk=1:3,ii=1:N)
+               deriv0(kk, i1+ii-1) = deriv0(kk, i1+ii-1) + s_j*sfb_deriv_i(kk, ii)
+               deriv1(kk, i1+ii-1, j) = deriv1(kk, i1+ii-1, j) + s_j*sfb_deriv_j(kk, ii)
+            end do
+
+             !values(i1:i2) = values(i1:i2) + s_j*sfb_values(1:N)
+             !if (do_deriv) then
+               
+                !deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
+                !                   + s_j*sfb_deriv_i(1:3, 1:N)
+                !deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) &
+                !                      + s_j*sfb_deriv_j(1:3, 1:N)
+             !end if
+          end if
+
+       end if  ! within radial cutoff
+
+       if (d_ij > sfb%a_Rc) cycle for_j
+       id_ij2 = 1.0d0/(d_ij*d_ij)
+       fc_j = sfb_fc(d_ij, sfb%a_Rc)
+       dfc_j = sfb_fc_d1(d_ij, sfb%a_Rc)
+
+       for_k : do k = j+1, nat
+          R_ik = coo1(1:3, k) - coo0(1:3)
+          d_ik = sqrt(dot_product(R_ik, R_ik))
+          if ((d_ik > sfb%a_Rc) .or. (d_ik < EPS)) cycle for_k
+          cos_ijk = dot_product(R_ij, R_ik)/(d_ij*d_ik)
+
+          ! evaluate angular basis functions
+          i1 = sfb%a_i1
+          i2 = sfb%a_f1
+          N = sfb%a_N
+          !if (do_deriv) then
+             call sfb_angular_deriv(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, &
+                              sfb_values, &
+                              fc_j,dfc_j,id_ij2,&
+                              deriv_i=sfb_deriv_i,      &
+                              deriv_j=sfb_deriv_j, deriv_k=sfb_deriv_k)
+             !call update_deriv(i1,i2,j,k,N,sfb_values,sfb_deriv_i,sfb_deriv_j,sfb_deriv_k,&
+             !           values,deriv0,deriv1)
+             !values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+             do concurrent (ii=1:N)
+               values(i1+ii-1) = values(i1+ii-1) + sfb_values(ii)
+             end do
+             !deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
+             !deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
+             !deriv1(1:3, i1:i2, k) = deriv1(1:3, i1:i2, k) + sfb_deriv_k(1:3, 1:N)
+            do concurrent (kk=1:3,ii=1:N)
+               deriv0(kk, i1+ii-1) = deriv0(kk, i1+ii-1) + sfb_deriv_i(kk, ii)
+               deriv1(kk, i1+ii-1, j) = deriv1(kk, i1+ii-1, j) + sfb_deriv_j(kk, ii)
+               deriv1(kk, i1+ii-1, k) = deriv1(kk, i1+ii-1, k) + sfb_deriv_k(kk, ii)
+            end do
+             !do ii = 1, N
+             !do concurrent (ii=1:N)
+             !  deriv0(1, i1+ii-1) = deriv0(1, i1+ii-1) + sfb_deriv_i(1, ii)
+             !  deriv0(2, i1+ii-1) = deriv0(2, i1+ii-1) + sfb_deriv_i(2, ii)
+             !  deriv0(3, i1+ii-1) = deriv0(3, i1+ii-1) + sfb_deriv_i(3, ii)
+             !end do
+
+             !do concurrent (ii=1:N)
+             !  deriv1(1, i1+ii-1, j) = deriv1(1, i1+ii-1, j) + sfb_deriv_j(1, ii)
+             !  deriv1(2, i1+ii-1, j) = deriv1(2, i1+ii-1, j) + sfb_deriv_j(2, ii)
+             !  deriv1(3, i1+ii-1, j) = deriv1(3, i1+ii-1, j) + sfb_deriv_j(3, ii)
+             !end do
+
+             !do concurrent (ii=1:N)
+             !  deriv1(1, i1+ii-1, k) = deriv1(1, i1+ii-1, k) + sfb_deriv_k(1, ii)
+             !  deriv1(2, i1+ii-1, k) = deriv1(2, i1+ii-1, k) + sfb_deriv_k(2, ii)
+             !  deriv1(3, i1+ii-1, k) = deriv1(3, i1+ii-1, k) + sfb_deriv_k(3, ii)
+             !end do
+
+          !else
+          !   call sfb_angular(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, sfb_values)
+          !   values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+          !end if
+
+          ! redundant angular basis in case of multi-component systems
+          i1 = sfb%a_i2
+          i2 = sfb%a_f2
+          N = sfb%a_N
+          if (sfb%multi) then
+             s_k = sfb%typespin(sfb%typeid(itype1(k)))
+             !call update_deriv_multi(i1,i2,j,k,N,sfb_values,sfb_deriv_i,&
+             !     sfb_deriv_j,sfb_deriv_k,&
+             !     values,deriv0,deriv1,do_deriv,s_j,s_k)
+
+             !values(i1:i2) = values(i1:i2) + s_j*s_k*sfb_values(1:N)
+             do concurrent (ii=1:N)
+               values(i1+ii-1) = values(i1+ii-1) + s_j*s_k*sfb_values(ii)
+             end do
+             !if (do_deriv) then
+                !deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
+                !                   + s_j*s_k*sfb_deriv_i(1:3, 1:N)
+                !deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) &
+                !                      + s_j*s_k*sfb_deriv_j(1:3, 1:N)
+                !deriv1(1:3, i1:i2, k) = deriv1(1:3, i1:i2, k) &
+                !                      + s_j*s_k*sfb_deriv_k(1:3, 1:N)
+             !end if
+             do concurrent (kk=1:3,ii=1:N)
+               deriv0(kk, i1+ii-1) = deriv0(kk, i1+ii-1) + s_j*s_k*sfb_deriv_i(kk, ii)
+               deriv1(kk, i1+ii-1, j) = deriv1(kk, i1+ii-1, j) + s_j*s_k*sfb_deriv_j(kk, ii)
+               deriv1(kk, i1+ii-1, k) = deriv1(kk, i1+ii-1, k) +s_j*s_k*sfb_deriv_k(kk, ii)
+              end do
+          end if
+       end do for_k
+    end do for_j
+
+    deallocate(sfb_deriv_i, sfb_deriv_j, sfb_deriv_k)
+
+  end subroutine sfb_eval_deriv
+
   subroutine sfb_eval(sfb, itype0, coo0, nat, itype1, coo1, nv, &
                       values, deriv0, deriv1)
 
@@ -465,6 +771,12 @@
     double precision               :: s_j, s_k
     integer                        :: j, k, i1, i2, N
 
+    !if (present(deriv0) .and. present(deriv1)) then
+    !  call sfb_eval_deriv(sfb, itype0, coo0, nat, itype1, coo1, nv, &
+    !!                  values, deriv0, deriv1)
+    !  return
+    !end if
+
     call sfb_assert_init(sfb)
 
     if (nv /= sfb%N) then
@@ -476,6 +788,7 @@
        do_deriv = .true.
        deriv0(:,:) = 0.0d0
        deriv1(:,:,:) = 0.0d0
+       !call cleararray(nv,nat,deriv0,deriv1)
        allocate(sfb_deriv_i(3, sfb%num_values), &
                 sfb_deriv_j(3, sfb%num_values), &
                 sfb_deriv_k(3, sfb%num_values))
@@ -498,6 +811,9 @@
           if (do_deriv) then
              call sfb_radial(sfb, R_ij, d_ij, sfb_values, &
                              deriv_i=sfb_deriv_i, deriv_j=sfb_deriv_j)
+            !call update_deriv_r(i1,i2,j,N,sfb_values,sfb_deriv_i,sfb_deriv_j,&
+            !   values,deriv0,deriv1)
+
              values(i1:i2) = values(i1:i2) + sfb_values(1:N)
              deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
              deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
@@ -511,7 +827,13 @@
           i2 = sfb%r_f2
           N = sfb%r_N
           if (sfb%multi) then
+            !write(*,*) "j",j,itype1(j)
+            !write(*,*) sfb%typeid(itype1(j))
+            !write(*,*) sfb%typespin(sfb%typeid(itype1(j)))
              s_j = sfb%typespin(sfb%typeid(itype1(j)))
+             !call update_deriv_r_multi(i1,i2,j,N,sfb_values,&
+             !  sfb_deriv_i,sfb_deriv_j,&
+             !  values,deriv0,deriv1,s_j,do_deriv)
              values(i1:i2) = values(i1:i2) + s_j*sfb_values(1:N)
              if (do_deriv) then
                 deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
@@ -524,6 +846,9 @@
        end if  ! within radial cutoff
 
        if (d_ij > sfb%a_Rc) cycle for_j
+       
+
+
        for_k : do k = j+1, nat
           R_ik = coo1(1:3, k) - coo0(1:3)
           d_ik = sqrt(dot_product(R_ik, R_ik))
@@ -538,6 +863,8 @@
              call sfb_angular(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, &
                               sfb_values, deriv_i=sfb_deriv_i,      &
                               deriv_j=sfb_deriv_j, deriv_k=sfb_deriv_k)
+             !call update_deriv(i1,i2,j,k,N,sfb_values,sfb_deriv_i,sfb_deriv_j,sfb_deriv_k,&
+             !           values,deriv0,deriv1)
              values(i1:i2) = values(i1:i2) + sfb_values(1:N)
              deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
              deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
@@ -553,6 +880,10 @@
           N = sfb%a_N
           if (sfb%multi) then
              s_k = sfb%typespin(sfb%typeid(itype1(k)))
+             !call update_deriv_multi(i1,i2,j,k,N,sfb_values,sfb_deriv_i,&
+             !     sfb_deriv_j,sfb_deriv_k,&
+             !     values,deriv0,deriv1,do_deriv,s_j,s_k)
+
              values(i1:i2) = values(i1:i2) + s_j*s_k*sfb_values(1:N)
              if (do_deriv) then
                 deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
@@ -716,7 +1047,7 @@
   !====================================================================!
 
 
-  function sfb_fc(Rij, Rc) result(fc)
+  pure function sfb_fc(Rij, Rc) result(fc)
 
     implicit none
 
@@ -733,7 +1064,7 @@
 
   !--------------------------------------------------------------------!
 
-  function sfb_fc_d1(Rij, Rc) result(dfc)
+  pure function sfb_fc_d1(Rij, Rc) result(dfc)
 
     implicit none
 
@@ -794,6 +1125,96 @@
 
   !--------------------------------------------------------------------!
 
+subroutine sfb_angular_deriv(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, values, &
+                        fc_j,dfc_j,id_ij2,&
+                         deriv_i, deriv_j, deriv_k)
+
+    implicit none
+
+    type(FingerprintBasis),                     intent(inout) :: sfb
+    double precision, dimension(3),             intent(in)    :: R_ij, R_ik
+    double precision,                           intent(in)    :: d_ij, d_ik
+    double precision,                           intent(in)    :: cos_ijk
+    double precision, dimension(:),             intent(out)   :: values
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_i
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_j
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_k
+
+    double precision                     :: w_ijk
+    double precision                     :: fc_k, dfc_k !fc_j, dfc_j
+    double precision, dimension(sfb%a_N) :: f, df
+    double precision                     :: id_ik2, id_ij_ik!,id_ij2
+    double precision, dimension(3)       :: di_cos_ikj, dj_cos_ikj, dk_cos_ikj
+    double precision, dimension(3)       :: di_w_ijk, dj_w_ijk, dk_w_ijk
+    integer                              :: i
+    integer::k
+    double precision,intent(in) ::fc_j,dfc_j,id_ij2
+
+    !call sfb_assert_init(sfb)
+
+    !fc_j = sfb_fc(d_ij, sfb%a_Rc)
+    fc_k = sfb_fc(d_ik, sfb%a_Rc)
+    w_ijk = fc_j*fc_k
+
+    f = chebyshev_polynomial(cos_ijk, -1.0d0, 1.0d0, sfb%a_order)
+
+    values(1:sfb%a_N) = w_ijk*f
+
+    !if (present(deriv_i) .and. present(deriv_j) .and. present(deriv_k)) then
+       !dfc_j = sfb_fc_d1(d_ij, sfb%a_Rc)
+       dfc_k = sfb_fc_d1(d_ik, sfb%a_Rc)
+       df = chebyshev_polynomial_d1(cos_ijk, -1.0d0, 1.0d0, sfb%a_order)
+       !id_ij2 = 1.0d0/(d_ij*d_ij)
+       id_ik2 = 1.0d0/(d_ik*d_ik)
+       id_ij_ik = 1.0d0/(d_ij*d_ik)
+       ! d/dR_i (cos_ijk)
+       !di_cos_ikj = cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
+       ! d/dR_j (cos_ijk)
+       !dj_cos_ikj = -cos_ijk*R_ij*id_ij2 + R_ik*id_ij_ik
+       ! d/dR_k (cos_ijk)
+       !dk_cos_ikj = -cos_ijk*R_ik*id_ik2 + R_ij*id_ij_ik
+       ! d/dR_i (cos_ijk)
+       !di_cos_ikj = -dj_cos_ikj - dk_cos_ikj!cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
+       ! d/dR_i (w_ijk)
+       !di_w_ijk = -(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
+       ! d/dR_j (w_ijk)
+       !dj_w_ijk = dfc_j*fc_k*R_ij/d_ij
+       ! d/dR_k (w_ijk)
+       !dk_w_ijk = fc_j*dfc_k*R_ik/d_ik
+       do concurrent(k=1:3)
+         ! d/dR_j (cos_ijk)
+         dj_cos_ikj(k) = -cos_ijk*R_ij(k)*id_ij2 + R_ik(k)*id_ij_ik
+         ! d/dR_k (cos_ijk)
+         dk_cos_ikj(k) = -cos_ijk*R_ik(k)*id_ik2 + R_ij(k)*id_ij_ik
+         ! d/dR_j (w_ijk)
+         dj_w_ijk(k) = dfc_j*fc_k*R_ij(k)/d_ij
+         ! d/dR_k (w_ijk)
+         dk_w_ijk(k) = fc_j*dfc_k*R_ik(k)/d_ik
+       end do
+       ! d/dR_i (w_ijk)
+       !di_w_ijk = -dj_w_ijk  - dk_w_ijk!-(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
+       !forall (i=1:sfb%a_N)
+       do concurrent(k=1:3,i=1:sfb%a_N)
+          ! d/dR_i (w_ijk*f)
+          !deriv_i(:,i) = di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+          ! d/dR_j (w_ijk*f)
+          !deriv_j(:,i) = dj_w_ijk(:)*f(i) + w_ijk*df(i)*dj_cos_ikj(:)
+          ! d/dR_k (w_ijk*f)
+          !deriv_k(:,i) = dk_w_ijk(:)*f(i) + w_ijk*df(i)*dk_cos_ikj(:)
+          ! d/dR_i (w_ijk*f)
+          !deriv_i(:,i) = -deriv_j(:,i) -deriv_k(:,i)  !di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+          deriv_j(k,i) = dj_w_ijk(k)*f(i) + w_ijk*df(i)*dj_cos_ikj(k)
+          ! d/dR_k (w_ijk*f)
+          deriv_k(k,i) = dk_w_ijk(k)*f(i) + w_ijk*df(i)*dk_cos_ikj(k)
+          ! d/dR_i (w_ijk*f)
+          deriv_i(k,i) = -deriv_j(k,i) -deriv_k(k,i)  !di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+           
+       end do
+       !end forall
+    !end if
+
+  end subroutine sfb_angular_deriv
+
   subroutine sfb_angular(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, values, &
                          deriv_i, deriv_j, deriv_k)
 
@@ -815,6 +1236,7 @@
     double precision, dimension(3)       :: di_cos_ikj, dj_cos_ikj, dk_cos_ikj
     double precision, dimension(3)       :: di_w_ijk, dj_w_ijk, dk_w_ijk
     integer                              :: i
+    integer::k
 
     call sfb_assert_init(sfb)
 
@@ -834,25 +1256,39 @@
        id_ik2 = 1.0d0/(d_ik*d_ik)
        id_ij_ik = 1.0d0/(d_ij*d_ik)
        ! d/dR_i (cos_ijk)
-       di_cos_ikj = cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
+       !di_cos_ikj = cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
        ! d/dR_j (cos_ijk)
        dj_cos_ikj = -cos_ijk*R_ij*id_ij2 + R_ik*id_ij_ik
        ! d/dR_k (cos_ijk)
        dk_cos_ikj = -cos_ijk*R_ik*id_ik2 + R_ij*id_ij_ik
+       ! d/dR_i (cos_ijk)
+       !di_cos_ikj = -dj_cos_ikj - dk_cos_ikj!cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
        ! d/dR_i (w_ijk)
-       di_w_ijk = -(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
+       !di_w_ijk = -(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
        ! d/dR_j (w_ijk)
        dj_w_ijk = dfc_j*fc_k*R_ij/d_ij
        ! d/dR_k (w_ijk)
        dk_w_ijk = fc_j*dfc_k*R_ik/d_ik
-       forall (i=1:sfb%a_N)
+       ! d/dR_i (w_ijk)
+       !di_w_ijk = -dj_w_ijk  - dk_w_ijk!-(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
+       !forall (i=1:sfb%a_N)
+       do concurrent(k=1:3,i=1:sfb%a_N)
           ! d/dR_i (w_ijk*f)
-          deriv_i(:,i) = di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+          !deriv_i(:,i) = di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
           ! d/dR_j (w_ijk*f)
-          deriv_j(:,i) = dj_w_ijk(:)*f(i) + w_ijk*df(i)*dj_cos_ikj(:)
+          !deriv_j(:,i) = dj_w_ijk(:)*f(i) + w_ijk*df(i)*dj_cos_ikj(:)
           ! d/dR_k (w_ijk*f)
-          deriv_k(:,i) = dk_w_ijk(:)*f(i) + w_ijk*df(i)*dk_cos_ikj(:)
-       end forall
+          !deriv_k(:,i) = dk_w_ijk(:)*f(i) + w_ijk*df(i)*dk_cos_ikj(:)
+          ! d/dR_i (w_ijk*f)
+          !deriv_i(:,i) = -deriv_j(:,i) -deriv_k(:,i)  !di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+          deriv_j(k,i) = dj_w_ijk(k)*f(i) + w_ijk*df(i)*dj_cos_ikj(k)
+          ! d/dR_k (w_ijk*f)
+          deriv_k(k,i) = dk_w_ijk(k)*f(i) + w_ijk*df(i)*dk_cos_ikj(k)
+          ! d/dR_i (w_ijk*f)
+          deriv_i(k,i) = -deriv_j(k,i) -deriv_k(k,i)  !di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+           
+       end do
+       !end forall
     end if
 
   end subroutine sfb_angular
diff -Naru src/ext/symmfunc.mod src_modified/ext/symmfunc.mod
--- src/ext/symmfunc.mod	1970-01-01 09:00:00
+++ src_modified/ext/symmfunc.mod	2024-09-10 11:56:52
@@ -0,0 +1,11 @@
+‹      í\[sâ¸~×¯è72sJ[–Ùàİ¢IvÏ<Ql ;’"ÉÖìùõ§es‘ŒÍ`ğø$Re¦¿¯[İú|Qÿöë`x;l÷áñiòöm
+O—/ó§´XØ‚ûåtü:ÀÃòé^şy||x[ÜÿëASrqñ	ñ"ëO7sş9´^FãÉd4^ÌZ¸³B›-`pqq=\Æ»awı÷ô?wû·qÿ®»^üÙ|N:ñeoı9Pü»¹ûe8¸»íöch÷şh¹Åÿ¹îu/»·ĞÛ_Føa<uâë¸ß‰û—_R˜Äşó·ŞG pÿ"€$D @£ÀXr İrÆ£>¶¥µO~nZ,áÅ`!0	,¦€iàt‡Ajœ%Ôş|››Œæ‹Éô{zÄ¢{éU¥C7ˆ³AáiPîß^«$AL
+w¯ÒHŒ®ñGRÃûprA €‡À%ğ(³J0?°Ñü¯¯§G Õ•  „ €AHBçBh
+#ôz,ÉX A AÌ‡¥Pç‹ñ·Ó$ëÑœa@ÌZCM—ÏËù¢Ô ><İ*CJqC‘¢BÈ ä$b%!”Fª\¡N8ÎXm#H&$'R€rqÊpóíy‚êÏ]ï¥L8E H…ˆAÄ!eù‘„_´âW_&G	æ(‚H‘Hƒ¢ (%Öh›*%A¡¬P 4h
+šÎòK£¡WüDmÑĞ	f‚–DG QåOŒÒ5Öò±8{b4™/å¸)<J"Ššˆ¢(¢¨Š(Ê"Z@”­ˆ ÊR¢¨RC¢FûñgÔŸ‘Fÿ¡ dõ-Ê=†Â‰qÿø=^™: l„x”8 Õãš07L Q”7õCÃPá0”85C‘Ã
+T[Éœùb^YVD:°Tı0”?,Øƒûb6zıç97d¿·‡İö/½ôëİşÚìZ¾iÿ'Ú½Şà²}›üB§{÷oºƒ~ŠÁüĞoñ‚öõ¾-{ƒNük<ÆÕid	3;½N¦Ëåñ	äB…<¨)0â “	°§üó:EhéĞ<˜5œvyj6Óp¯	|	ÛAİ¾crlCçîêêKÊòp§8ZZ&X}dŠ€×‡ JˆúàIÍò¾²ùÁõ-–—v¤8’Æí¨ˆdg?<å˜¾k…`´Ä·ñãŸ“Ê0ÈøÀ`Ğú¯‡/"[Øù%ËÖ†:0d«C";;Ë8Jn˜
+ñR3·F”q”Ä@mŞú:~~®æç29M^ÜgT–¶Úã±ªéD•6éøP`¥úiicNê2gJ­¿§÷vÈuÙq·98|à™Íµ–r9èßÜ¶Q“ş ’µ°d›­‹‚ÈÎ"9 ‡7[ñşúÎxs7¿Ë’ökÂØ®îp/ÛX×îŸ^^ë1f`…ÁV½¦é
+¿órÇêöŞëÊ1~òò¦LmEó£É²`Ğ¡™©®·Ü=ÜßHî[ævÆ[ÆT5]IÆ˜ëV¢Ÿ—v˜$z¾íSç¹¹47©ÍzH3'”O…­x½Í÷ye Ìò³|ñİ×éI¦Ut:¦ºıµÏŸİ¹ãó­‰ŸÏ·Ççµ@6.øÁ½Ä•yÒ„úëÈãù(ûêú;£z},¥‹:‡5VÓY¾ıŸU1ìõ°Øëæ<|VPBKò.)ÆNlR>ër 9TÌkRäáİ´Şãa£ÆgI}r‹ÿ;çÚ Uò$§8“¢(JæhkIÏ(2%·µuUÓPE[KœëgE´O­0eÔ¦º¬ce|¶ŒËóßKUÙË”¥A4RáJíæšçËF=¢–
+©jÙC…DÌR!YûM×!-œ%#¬qs/âGxr@8ZÈÓûïXí‹sà¨¡ŸÂÇ‘S?£³ÖOçá—ª¦+i•HÛwÕÏjZQçäY=®˜#Ñ\Û§IŠ»íÌÖCG¢©àüzÉ¬D+¢‘M¹%ÆËó¥£®,‰VÕ²‡DSÚ’hYûM—hèÜ¢iES[¢U!îŸoš9ÍÓûïX>ì‹3w$Ú‡OáãĞ©ŸúœõSK[¢U5]I'é(ó¼ßy‰+G)¹¶O­U´v•Òy­›å`¶T2«ÄÎşä-Y±TF#Õ’Y„×ò¢í{ûÎZ=‘·ï­í hºf2.*ôfÍ¥¥š*r/w37…rt“oŞñ¤¾?ØÚ‘Nn>›McšWëñJ³¸ú“¥SŠíÎf`4q63Ë™ÜÇÈßó0eî7ôÉ\º
+¦4m/“,Úòn~ÖÍ5mŸûY×îCü~Å®´ynßõ£^±Ğrû–è‚Æ‹G^|#Çô¬°Åc5îŞ3wï‹ú†à=«š½Ávo~¸ùDn›‹«ù‡›ãf•Ñè<:¿FçzG£W€ÑD½¶Yâê€F2wŸÔ,OÛK­¥KM=œîg]d´¢WÒ•7ØZÑ‹zÅ„7‹Ng…¯ÑÁ…×,xûr÷®¸Â]Oà‚÷<»î¶»¨àÃÍ'r³vµâ‡›Oâf³pya–¾m{â”^Å{„ÚeÖ0/fãïu¢0íäfò2mØğŞí^_cÛÎà¸Ç‰İsßPv'k
+ëÎÖi»hÜß´ŞöbÆw±ºSØv3^wÈ¤ Îº¶v·ßQ‚Xı^)lû¿n¿³i´Øo®›’nzrã iõ«Äı™MHóV°í¨hvÃmC³+‰Õ2Ğ¼}"ÿîJóg`  
\ No newline at end of file
diff -Naru src/generate.f90 src_modified/generate.f90
--- src/generate.f90	2024-09-06 10:37:30
+++ src_modified/generate.f90	2024-09-06 10:37:30
@@ -25,518 +25,87 @@
 !-----------------------------------------------------------------------
 
 program generate
+    use aeio,     only: aeio_readline,        &
+                    aeio_header,          &
+                    aeio_timestamp,       &
+                    aeio_print_copyright, &
+                    PATHLEN, LINELEN
+    use aenet_generate 
 
-  use aeio,     only: aeio_readline,        &
-                      aeio_header,          &
-                      aeio_timestamp,       &
-                      aeio_print_copyright, &
-                      PATHLEN, LINELEN
 
-  use geometry, only: geo_init,          &
-                      geo_final,         &
-                      geo_itype_of_name, &
-                      geo_type_conv,     &
-                      pbc,               &
-                      latticeVec,        &
-                      nAtoms,            &
-                      nTypes,            &
-                      atomType,          &
-                      atomTypeName,      &
-                      cooLatt,           &
-                      cooCart,           &
-                      forCart,           &
-                      hasEnergy,         &
-                      hasForces,         &
-                      cohesiveEnergy,    &
-                      totalEnergy
+    implicit none
+    character(len=PATHLEN)                         :: inFile
+    integer::ionum
 
-  use input,    only: InputData,         &
-                      read_InpGenerate,  &
-                      del_InputData
 
-  use io,       only: io_adjustl,        &
-                      io_center,         &
-                      io_lower,          &
-                      io_readnext,       &
-                      io_unit
+    ionum= 139
+    call initialize(inFile)
+    call generate_subroutine(inFile,ionum)
 
-  use lclist,   only: lcl_init,          &
-                      lcl_final,         &
-                      lcl_print_info,    &
-                      lcl_nmax_nbdist,   &
-                      lcl_nbdist_cart
 
-  use sfsetup,  only: Setup,                 &
-                      read_Setup_parameters, &
-                      save_Setup,            &
-                      del_Setup,             &
-                      stp_init,              &
-                      stp_final,             &
-                      stp_get_range,         &
-                      stp_print_info,        &
-                      stp_eval,              &
-                      nsf_max
-
-  use timing,   only: tng_init,          &
-                      tng_final,         &
-                      tng_timing,        &
-                      tng_timing2,       &
-                      tng_timing3,       &
-                      tng_dump
-
-  use trainset, only: TrnSet,                 &
-                      new_TrnSet,             &
-                      close_TrnSet,           &
-                      ts_print_info,          &
-                      ts_write_header,        &
-                      ts_write_sf_info,       &
-                      ts_write_atom_info,     &
-                      ts_write_structure_info
-
-  use pytorchoutput, only: pyo_write_init,               &
-                           pyo_write_final,              &
-                           pyo_write_header_info,        &
-                           pyo_write_structure_info,     &
-                           pyo_write_atom_sf_info,       &
-                           pyo_select_force_structures!, &
-
-  implicit none
-
-  !--------------------------------------------------------------------!
-  ! stp(i)         structural fingerprint basis setup for atom type i  !
-  ! r_min, r_max   lower and upper bound for atomic interactions       !
-  ! ts             training set reference                              !
-  !                                                                    !
-  ! nnb_max, nnb   max. and actual number of neighboring atoms         !
-  ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
-  !                neighboring atom                                    !
-  ! nbdist(i)      distance of the i-th neighbor                       !
-  !                                                                    !
-  ! sfval(i)         value of the i-th basis function                  !
-  ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
-  !                  with respect to the central atom                  !
-  !                  sfderiv_i(3,nsf_max)                              !
-  ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
-  !                  with respect to the coordinates of atom k         !
-  !                  sfderiv_j(3,nsf_max,nnb_max)                      !
-  !                                                                    !
-  ! E_coh          cohesive energy                                     !
-  ! nFiles_inv     = 1/inp%nStrucs                                     !
-  !                                                                    !
-  ! inFile         name of the input file for the generate.x program   !
-  ! cooFile        name of the currently active structure file         !
-  ! keyword        the last keyword read from the input file           !
-  !                                                                    !
-  ! do_debug       if .true., additional files containing debugging    !
-  !                info will be created                                !
-  !                                                                    !
-  ! u_*            file units                                          !
-  !--------------------------------------------------------------------!
-
-  type(InputData)                                :: inp
-
-  type(Setup),       dimension(:),   allocatable :: stp
-  double precision                               :: r_min, r_max
-  type(TrnSet)                                   :: ts
-
-  integer                                        :: nnb_max, nnb
-  double precision,  dimension(:,:), allocatable :: nbcoo
-  double precision,  dimension(:),   allocatable :: nbdist
-  integer,  dimension(:),   allocatable :: nblist
-  integer,           dimension(:),   allocatable :: nbtype
-
-  double precision, dimension(:),     allocatable :: sfval
-  double precision, dimension(:,:),   allocatable :: sfderiv_i
-  double precision, dimension(:,:,:), allocatable :: sfderiv_j
-
-  double precision                               :: E_coh
-  integer                                        :: ifile
-  double precision                               :: nFiles_inv
-
-  character(len=PATHLEN)                         :: inFile
-  character(len=PATHLEN)                         :: cooFile
-  character(len=LINELEN)                         :: keyword
-
-  integer                                        :: itype1
-  integer                                        :: itype, iatom
-
-  integer                                        :: iline
-  character(len=1024)                            :: line
-
-  integer                                        :: u_in, u_tng
-  logical                                        :: do_debug = .false.
-  integer                                        :: u_dbg, idbg
-
-  integer                                        :: u_pyo, max_nnb_trainset, pyo_forces_struc
-  integer, allocatable                           :: struc_write_force(:)
-
-  integer :: i
-
-  ! timing registers
-  integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
-
-  !-------------------------- initialization --------------------------!
-
-  call initialize(inFile)
-
-  inp = read_InpGenerate(inFile)
-  allocate(stp(inp%nTypes))
-  call load_symmfunc_setups(inp, stp)
-
-  ! call parse_input(inFile)
-
-  if (inp%do_timing) then
-     u_tng = io_unit()
-     call tng_init(unit=u_tng, file='generate.time', registers=3)
-     write(*,*) 'Timing info will be written to: ', 'generate.time'
-     write(*,*)
-  end if
-  if (do_debug) then
-     u_dbg = io_unit()
-     open(u_dbg, file='generate.debug', status='replace', action='write')
-  end if
-
-  ! get interaction range and max. number of atoms within range
-  call stp_get_range(inp%nTypes, stp, r_min, r_max)
-  nnb_max = lcl_nmax_nbdist(r_min, r_max)
-  allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nblist(nnb_max),nbtype(nnb_max))
-
-  ! initialize workspace for structural fingerprint basis:
-  call stp_init(inp%nTypes, stp, nnb_max)
-  if (inp%do_timing) call tng_timing('Structural fingerprint basis initialized.')
-
-  ! allocate workspace for basis function evaluation:
-  allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
-  sfval(:) = 0.0d0
-  sfderiv_i(:,:) = 0.0d0
-  sfderiv_j(:,:,:) = 0.0d0
-
-  call aeio_header('Generation of training set started')
-  write(*,*)
-
-  write(*,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
-  write(*,'(1x,"types                 : ")', advance='no')
-  do itype = 1, inp%nTypes
-     if (mod(itype,7) == 0) write(*,'(29x)')
-     write(*,'(A5,1x)', advance='no') inp%typeName(itype)
-  end do
-  write(*,*)
-  write(*,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
-  write(*,*)
-
-  !-------------- write basis function settings to stdout -------------!
-
-  call aeio_header("Structural fingerprint basis set-up")
-  write(*,*)
-
-  do itype1 = 1, inp%nTypes
-     call stp_print_info(stp(itype1))
-  end do
-
-  !----------- write training set header to the output file -----------!
-
-  ts = new_TrnSet(inp%nTypes, inp%typeName, inp%atomicEnergy, &
-                  inp%nStrucs, trim(inp%outFileName))
-
-  if (inp%do_timing) call tng_timing('Training set file started.')
-
-  !--------------- write pytorch force training header ----------------!
+    contains !=============================================================!
   
-  if (inp%pyo_forces) then
-    u_pyo = io_unit()
-    call pyo_write_init(u_pyo, trim(inp%outFileName)//".forces")
-    call pyo_write_header_info(u_pyo, inp%nStrucs)
-    call pyo_select_force_structures(inp%nStrucs, inp%pyo_forces_percent, struc_write_force)
-    max_nnb_trainset = 0
-  endif
-
-  !------------------ iterate over coordinates files ------------------!
-
-  call aeio_header("Adding structures to the training set")
-  write(*,*)
-
-  u_in = io_unit()
-  open(u_in, file=inFile, status='old', action='read')
-  rewind(u_in)
-
-  iline = 0
-  do
-     ! forward until the FILES keyword:
-     call aeio_readline(u_in, iline, line)
-     read(line,*) keyword
-     if (trim(keyword) == 'FILES') then
-        read(u_in,*)
-        exit
-     end if
-  end do
-
-  ! header for stdout
-  write(*,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
-       'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
-
-  nFiles_inv = 1.0d0/dble(inp%nStrucs)
-  structures : do ifile = 1, inp%nStrucs
-
-     if (inp%do_timing) call tng_timing('Structure: '// io_adjustl(ifile))
-
-     call aeio_readline(u_in, iline, line)
-     cooFile = trim(line)
-
-     call geo_init(cooFile, 'xsf')
-     if (inp%do_timing) call tng_timing3(register=R_GEO)
-     if (.not. (hasForces .and. hasEnergy)) then
-        write(0,*) ">>>", hasForces, hasEnergy
-        write(0,*) "Error: incomplete output data in : ", trim(cooFile)
-        call finalize()
-        stop
-     end if
-
-     if (nTypes > inp%nTypes) then
-        write(*,*) 'Skipping ', trim(adjustl(cooFile)), &
-                   ': too many atomic species'
-        call geo_final()
-        cycle structures
-     end if
-
-     if (abs(cohesiveEnergy) /= 0.0d0) then
-        E_coh = cohesiveEnergy
-     else
-        ! if only the total energy is available, we have to calculate
-        ! the cohesive energy at this point
-        E_coh = totalEnergy
-        do iatom = 1, nAtoms
-           itype1 = atomType(iatom)
-           itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
-                                  inp%nTypes, inp%typeName)
-           E_coh = E_coh - inp%atomicEnergy(itype1)
-        end do
-     end if
-
-     write(*,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
-          ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
-          trim(adjustl(cooFile))
-
-     call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
-     if (inp%do_timing) call tng_timing3(register=R_NBL)
-
-     ! write structure info (atoms, types, energy) to training set file:
-     call ts_write_structure_info(ts, cooFile, nAtoms, nTypes, E_coh)
-     
-     ! write structure info (atoms, types) to pytorch forces file:
-     if (inp%pyo_forces) then
-       pyo_forces_struc = struc_write_force(ifile)
-       call pyo_write_structure_info(u_pyo, cooFile, nAtoms, nTypes, pyo_forces_struc)
-     end if
-
-     atoms : do iatom = 1, nAtoms
-
-        ! determine the training atom type of atom `iatom' in global
-        ! index terms
-        itype1 = atomType(iatom)
-        itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
-                               inp%nTypes, inp%typeName)
-
-        ! assert that atom type is included in the set-ups:
-        if (itype1 == 0) then
-           write(0,*) "Error: not a valid structure    : ", trim(cooFile)
-           write(0,*) "       Additional species found."
-           call finalize()
-           stop
-        end if
-
-        ! write atom info (species, forces) to training set file:
-        call ts_write_atom_info(ts, itype1, cooCart(iatom), forCart(iatom))
-
-        ! get all atoms within cut-off:
-        nnb = nnb_max
-        call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nblist=nblist, nbtype=nbtype)
-
-        if (inp%do_timing) call tng_timing3(register=R_NBL)
-        write(*,'(1x,I6,2x,A2,2x,I6)') &
-             iatom, trim(atomTypeName(atomType(iatom))), nnb
-
-        ! convert atom types to global index:
-        do i = 1, nnb
-           nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
-                                    inp%nTypes, inp%typeName)
-           if (nbtype(i) == 0) then
-              write(0,*) "Error: atom type not found in setup."
-              call finalize()
-              stop
-           end if
-        end do
-
-        ! evaluate the structural fingerprint basis function set-up:
-        call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
-                      stp(itype1), sfval=sfval, sfderiv_i=sfderiv_i, &
-                      sfderiv_j=sfderiv_j)
-
-        if (do_debug) then
-           do idbg = 1, stp(itype1)%nsf
-              write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
-           end do
-           write(u_dbg,*)
-        end if
-
-        if (inp%do_timing) call tng_timing3(register=R_SF)
-
-        ! write basis function values and derivatives
-        ! to the training set file:
-        call ts_write_sf_info(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf))
-
-        ! write basis function derivatives and neighbor list to pytorch output
-        if (inp%pyo_forces .and. pyo_forces_struc==1) then
-          max_nnb_trainset = max(max_nnb_trainset, nnb)
-          call pyo_write_atom_sf_info(u_pyo, itype1, nnb, stp(itype1)%nsf, nblist(:nnb), &
-                                      sfderiv_i(1:3,1:stp(itype1)%nsf), &
-                                      sfderiv_j(1:3,1:stp(itype1)%nsf,1:nnb) )
-        end if
-
-     end do atoms
-
-     if (inp%do_timing) then
-        call tng_dump(R_GEO, 'time spent reading geometries (so far)')
-        call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
-        call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
-     end if
-
-     call lcl_final()
-     call geo_final()
-
-  end do structures
-  write(*,*)
-
-  if (inp%do_timing) then
-     call tng_timing('Loop over structures done.')
-     call tng_dump(R_GEO, 'total time spent reading geometries')
-     call tng_dump(R_NBL, 'total time spent in the neighbor list')
-     call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
-  end if
-
-  !--------- save basis function setups with final statistics ---------!
-
-  call ts_print_info(ts)
-
-  !----------------------------- finalize -----------------------------!
-
-  deallocate(nbcoo, nbdist, nblist, nbtype)
-  close(u_in)
   
-  if (inp%pyo_forces) then
-    call pyo_write_final(u_pyo, max_nnb_trainset)
-  end if
+    subroutine initialize(inFile)
+  
+      implicit none
+  
+      character(len=*), intent(out) :: inFile
+  
+      integer :: nargs
+      logical :: fexists
+  
+      call aeio_header("generate.x - training set generation", char='=')
+      write(ionum,*)
+  
+      call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+  
+      nargs = command_argument_count()
+      if (nargs < 1) then
+         write(0,*) "Error: No input file provided."
+         call print_usage()
+         call finalize()
+         stop
+      end if
+  
+      call get_command_argument(1, value=inFile)
+      inquire(file=trim(inFile), exist=fexists)
+      if (.not. fexists) then
+         write(0,*) "Error: File not found: ", trim(inFile)
+         call print_usage()
+         call finalize()
+         stop
+      end if
+  
+    end subroutine initialize
 
-  call close_TrnSet(ts, stp=stp(1:inp%nTypes))
-  call finalize()
+    subroutine print_usage()
 
+        implicit none
 
-contains !=============================================================!
+        write(ionum,*)
+        write(ionum,*) "generate.x -- Generate training sets for use with `train.x'"
+        write(ionum,'(1x,70("-"))')
+        write(ionum,*) 'Usage: generate.x <input-file>'
+        write(ionum,*)
+        write(ionum,*) 'See the documentation or the source code for a description of the '
+        write(ionum,*) 'input file format.'
+        write(ionum,*)
 
-
-  subroutine initialize(inFile)
-
-    implicit none
-
-    character(len=*), intent(out) :: inFile
-
-    integer :: nargs
-    logical :: fexists
-
-    call aeio_header("generate.x - training set generation", char='=')
-    write(*,*)
-
-    call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
-
-    nargs = command_argument_count()
-    if (nargs < 1) then
-       write(0,*) "Error: No input file provided."
-       call print_usage()
-       call finalize()
-       stop
-    end if
-
-    call get_command_argument(1, value=inFile)
-    inquire(file=trim(inFile), exist=fexists)
-    if (.not. fexists) then
-       write(0,*) "Error: File not found: ", trim(inFile)
-       call print_usage()
-       call finalize()
-       stop
-    end if
-
-  end subroutine initialize
-
-  !--------------------------------------------------------------------!
-
-  subroutine finalize()
-
-    implicit none
-
-    integer :: itype
-
-    if (allocated(sfval)) then
-       deallocate(sfval, sfderiv_i, sfderiv_j)
-    end if
-
-    if (allocated(stp)) then
-       call stp_final(inp%nTypes, stp)
-       do itype = 1, inp%nTypes
-          call del_Setup(stp(itype))
-       end do
-       deallocate(stp, inp%typeName, inp%atomicEnergy)
-    end if
-
-    if (ts%init) call close_TrnSet(ts)
-
-    if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
-
-    if (inp%do_timing) call tng_final()
-    if (do_debug)  close(u_dbg)
-
-    call aeio_header(aeio_timestamp(), char=' ')
-    call aeio_header("Training set generation done.", char='=')
-
-  end subroutine finalize
-
-  !--------------------------------------------------------------------!
-
-  subroutine print_usage()
-
-    implicit none
-
-    write(*,*)
-    write(*,*) "generate.x -- Generate training sets for use with `train.x'"
-    write(*,'(1x,70("-"))')
-    write(*,*) 'Usage: generate.x <input-file>'
-    write(*,*)
-    write(*,*) 'See the documentation or the source code for a description of the '
-    write(*,*) 'input file format.'
-    write(*,*)
-
   end subroutine print_usage
 
-  !--------------------------------------------------------------------!
-
-  subroutine load_symmfunc_setups(inp, stp)
-
-    implicit none
-
-    type(InputData),           intent(in)  :: inp
-    type(Setup), dimension(:), intent(out) :: stp
-
-    integer :: i
-
-    do i = 1, inp%nTypes
-       stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
-       if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
-          write(0,*) "Error: Inconsistent atom type in setup:"
-          write(0,*) "       type expected : ", trim(inp%typeName(i))
-          write(0,*) "       type found    : ", trim(stp(i)%atomtype)
-          call finalize()
-          stop
-       end if
-    end do
-
-  end subroutine load_symmfunc_setups
-
-end program generate
+  
+    !--------------------------------------------------------------------!
+  
+    subroutine finalize()
+  
+      implicit none
+  
+      integer :: itype
+  
+  
+      call aeio_header(aeio_timestamp(), char=' ')
+      call aeio_header("Training set generation done.", char='=')
+  
+    end subroutine finalize
+end program generate
\ No newline at end of file
diff -Naru src/generate_MPI.F90 src_modified/generate_MPI.F90
--- src/generate_MPI.F90	1970-01-01 09:00:00
+++ src_modified/generate_MPI.F90	2024-09-06 22:00:25
@@ -0,0 +1,131 @@
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2019 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!+ ---------------------------------------------------------------------
+!+ If you make use of AENET for your publication, please cite:
+!+ [1] N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.
+!+ [2] J. Behler and M. Parrinello, Phys. Rev. Lett. 98 (2007) 146401.
+!+
+!+ If you used the Chebyshev descriptor, please cite:
+!+ [3] N. Artrith, A. Urban, and G. Ceder, PRB 96 (2017) 014112.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+program generate
+   use aeio,     only: aeio_readline,        &
+                   aeio_header,          &
+                   aeio_timestamp,       &
+                   aeio_print_copyright, &
+                   PATHLEN, LINELEN
+   use aenet_generate_MPI,only:generate_subroutine_MPI 
+
+  use parallel,    only: pp_init,                &
+                         pp_final,               &
+                         pp_bcast,               &
+                         pp_barrier,             &
+                         ppMaster,               &
+                         ppRank,                 &
+                         ppSize,                 &
+                         pp_bcast_InputData,     &
+                         pp_bcast_Setup   
+
+   use aenet_mpimodule
+
+
+   implicit none
+   character(len=PATHLEN)                         :: inFile
+   integer::ionum
+   integer::ierr
+
+
+   ionum= 139
+   call initialize_MPI(inFile)
+   call generate_subroutine_MPI(inFile,ionum)
+
+
+   contains 
+
+   subroutine initialize_MPI(inFile)
+
+    implicit none
+#ifdef PARALLEL
+    include 'mpif.h'
+#endif
+
+    character(len=*), intent(out) :: inFile
+
+    integer :: nargs
+    logical :: fexists
+    logical :: stopnow
+    integer::ierr
+
+#ifdef PARALLEL
+    call MPI_Init(ierr)
+#endif
+
+    call pp_init()
+
+    stopnow = .false.
+
+    if (ppMaster) then
+
+       !call aeio_header("generate.x - training set generation", char='=')
+       !write(*,*)
+
+       !call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+
+       nargs = command_argument_count()
+       if (nargs < 1) then
+          write(0,*) "Error: No input file provided."
+          call print_usage()
+          stopnow = .true.
+       end if
+
+       call get_command_argument(1, value=inFile)
+       inquire(file=trim(inFile), exist=fexists)
+       if (.not. fexists) then
+          write(0,*) "Error: File not found: ", trim(inFile)
+          stopnow = .true.
+       end if
+
+    end if
+
+    call pp_bcast(stopnow)
+    if (stopnow) then
+       stop
+    end if
+
+    call pp_bcast(inFile)
+
+  end subroutine initialize_MPI
+
+
+  subroutine print_usage()
+
+   implicit none
+
+   write(*,*)
+   write(*,*) "generate.x -- Generate training sets for use with `train.x'"
+   write(*,'(1x,70("-"))')
+   write(*,*) 'Usage: generate.x <input-file>'
+   write(*,*)
+   write(*,*) 'See the documentation or the source code for a description of the '
+   write(*,*) 'input file format.'
+   write(*,*)
+
+ end subroutine print_usage
+
+end program
\ No newline at end of file
diff -Naru src/generate_original.f90 src_modified/generate_original.f90
--- src/generate_original.f90	1970-01-01 09:00:00
+++ src_modified/generate_original.f90	2024-09-06 10:37:30
@@ -0,0 +1,542 @@
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2019 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!+ ---------------------------------------------------------------------
+!+ If you make use of AENET for your publication, please cite:
+!+ [1] N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.
+!+ [2] J. Behler and M. Parrinello, Phys. Rev. Lett. 98 (2007) 146401.
+!+
+!+ If you used the Chebyshev descriptor, please cite:
+!+ [3] N. Artrith, A. Urban, and G. Ceder, PRB 96 (2017) 014112.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+program generate
+
+  use aeio,     only: aeio_readline,        &
+                      aeio_header,          &
+                      aeio_timestamp,       &
+                      aeio_print_copyright, &
+                      PATHLEN, LINELEN
+
+  use geometry, only: geo_init,          &
+                      geo_final,         &
+                      geo_itype_of_name, &
+                      geo_type_conv,     &
+                      pbc,               &
+                      latticeVec,        &
+                      nAtoms,            &
+                      nTypes,            &
+                      atomType,          &
+                      atomTypeName,      &
+                      cooLatt,           &
+                      cooCart,           &
+                      forCart,           &
+                      hasEnergy,         &
+                      hasForces,         &
+                      cohesiveEnergy,    &
+                      totalEnergy
+
+  use input,    only: InputData,         &
+                      read_InpGenerate,  &
+                      del_InputData
+
+  use io,       only: io_adjustl,        &
+                      io_center,         &
+                      io_lower,          &
+                      io_readnext,       &
+                      io_unit
+
+  use lclist,   only: lcl_init,          &
+                      lcl_final,         &
+                      lcl_print_info,    &
+                      lcl_nmax_nbdist,   &
+                      lcl_nbdist_cart
+
+  use sfsetup,  only: Setup,                 &
+                      read_Setup_parameters, &
+                      save_Setup,            &
+                      del_Setup,             &
+                      stp_init,              &
+                      stp_final,             &
+                      stp_get_range,         &
+                      stp_print_info,        &
+                      stp_eval,              &
+                      nsf_max
+
+  use timing,   only: tng_init,          &
+                      tng_final,         &
+                      tng_timing,        &
+                      tng_timing2,       &
+                      tng_timing3,       &
+                      tng_dump
+
+  use trainset, only: TrnSet,                 &
+                      new_TrnSet,             &
+                      close_TrnSet,           &
+                      ts_print_info,          &
+                      ts_write_header,        &
+                      ts_write_sf_info,       &
+                      ts_write_atom_info,     &
+                      ts_write_structure_info
+
+  use pytorchoutput, only: pyo_write_init,               &
+                           pyo_write_final,              &
+                           pyo_write_header_info,        &
+                           pyo_write_structure_info,     &
+                           pyo_write_atom_sf_info,       &
+                           pyo_select_force_structures!, &
+
+  implicit none
+
+  !--------------------------------------------------------------------!
+  ! stp(i)         structural fingerprint basis setup for atom type i  !
+  ! r_min, r_max   lower and upper bound for atomic interactions       !
+  ! ts             training set reference                              !
+  !                                                                    !
+  ! nnb_max, nnb   max. and actual number of neighboring atoms         !
+  ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
+  !                neighboring atom                                    !
+  ! nbdist(i)      distance of the i-th neighbor                       !
+  !                                                                    !
+  ! sfval(i)         value of the i-th basis function                  !
+  ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
+  !                  with respect to the central atom                  !
+  !                  sfderiv_i(3,nsf_max)                              !
+  ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
+  !                  with respect to the coordinates of atom k         !
+  !                  sfderiv_j(3,nsf_max,nnb_max)                      !
+  !                                                                    !
+  ! E_coh          cohesive energy                                     !
+  ! nFiles_inv     = 1/inp%nStrucs                                     !
+  !                                                                    !
+  ! inFile         name of the input file for the generate.x program   !
+  ! cooFile        name of the currently active structure file         !
+  ! keyword        the last keyword read from the input file           !
+  !                                                                    !
+  ! do_debug       if .true., additional files containing debugging    !
+  !                info will be created                                !
+  !                                                                    !
+  ! u_*            file units                                          !
+  !--------------------------------------------------------------------!
+
+  type(InputData)                                :: inp
+
+  type(Setup),       dimension(:),   allocatable :: stp
+  double precision                               :: r_min, r_max
+  type(TrnSet)                                   :: ts
+
+  integer                                        :: nnb_max, nnb
+  double precision,  dimension(:,:), allocatable :: nbcoo
+  double precision,  dimension(:),   allocatable :: nbdist
+  integer,  dimension(:),   allocatable :: nblist
+  integer,           dimension(:),   allocatable :: nbtype
+
+  double precision, dimension(:),     allocatable :: sfval
+  double precision, dimension(:,:),   allocatable :: sfderiv_i
+  double precision, dimension(:,:,:), allocatable :: sfderiv_j
+
+  double precision                               :: E_coh
+  integer                                        :: ifile
+  double precision                               :: nFiles_inv
+
+  character(len=PATHLEN)                         :: inFile
+  character(len=PATHLEN)                         :: cooFile
+  character(len=LINELEN)                         :: keyword
+
+  integer                                        :: itype1
+  integer                                        :: itype, iatom
+
+  integer                                        :: iline
+  character(len=1024)                            :: line
+
+  integer                                        :: u_in, u_tng
+  logical                                        :: do_debug = .false.
+  integer                                        :: u_dbg, idbg
+
+  integer                                        :: u_pyo, max_nnb_trainset, pyo_forces_struc
+  integer, allocatable                           :: struc_write_force(:)
+
+  integer :: i
+
+  ! timing registers
+  integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
+
+  !-------------------------- initialization --------------------------!
+
+  call initialize(inFile)
+
+  inp = read_InpGenerate(inFile)
+  allocate(stp(inp%nTypes))
+  call load_symmfunc_setups(inp, stp)
+
+  ! call parse_input(inFile)
+
+  if (inp%do_timing) then
+     u_tng = io_unit()
+     call tng_init(unit=u_tng, file='generate.time', registers=3)
+     write(*,*) 'Timing info will be written to: ', 'generate.time'
+     write(*,*)
+  end if
+  if (do_debug) then
+     u_dbg = io_unit()
+     open(u_dbg, file='generate.debug', status='replace', action='write')
+  end if
+
+  ! get interaction range and max. number of atoms within range
+  call stp_get_range(inp%nTypes, stp, r_min, r_max)
+  nnb_max = lcl_nmax_nbdist(r_min, r_max)
+  allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nblist(nnb_max),nbtype(nnb_max))
+
+  ! initialize workspace for structural fingerprint basis:
+  call stp_init(inp%nTypes, stp, nnb_max)
+  if (inp%do_timing) call tng_timing('Structural fingerprint basis initialized.')
+
+  ! allocate workspace for basis function evaluation:
+  allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
+  sfval(:) = 0.0d0
+  sfderiv_i(:,:) = 0.0d0
+  sfderiv_j(:,:,:) = 0.0d0
+
+  call aeio_header('Generation of training set started')
+  write(*,*)
+
+  write(*,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
+  write(*,'(1x,"types                 : ")', advance='no')
+  do itype = 1, inp%nTypes
+     if (mod(itype,7) == 0) write(*,'(29x)')
+     write(*,'(A5,1x)', advance='no') inp%typeName(itype)
+  end do
+  write(*,*)
+  write(*,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
+  write(*,*)
+
+  !-------------- write basis function settings to stdout -------------!
+
+  call aeio_header("Structural fingerprint basis set-up")
+  write(*,*)
+
+  do itype1 = 1, inp%nTypes
+     call stp_print_info(stp(itype1))
+  end do
+
+  !----------- write training set header to the output file -----------!
+
+  ts = new_TrnSet(inp%nTypes, inp%typeName, inp%atomicEnergy, &
+                  inp%nStrucs, trim(inp%outFileName))
+
+  if (inp%do_timing) call tng_timing('Training set file started.')
+
+  !--------------- write pytorch force training header ----------------!
+  
+  if (inp%pyo_forces) then
+    u_pyo = io_unit()
+    call pyo_write_init(u_pyo, trim(inp%outFileName)//".forces")
+    call pyo_write_header_info(u_pyo, inp%nStrucs)
+    call pyo_select_force_structures(inp%nStrucs, inp%pyo_forces_percent, struc_write_force)
+    max_nnb_trainset = 0
+  endif
+
+  !------------------ iterate over coordinates files ------------------!
+
+  call aeio_header("Adding structures to the training set")
+  write(*,*)
+
+  u_in = io_unit()
+  open(u_in, file=inFile, status='old', action='read')
+  rewind(u_in)
+
+  iline = 0
+  do
+     ! forward until the FILES keyword:
+     call aeio_readline(u_in, iline, line)
+     read(line,*) keyword
+     if (trim(keyword) == 'FILES') then
+        read(u_in,*)
+        exit
+     end if
+  end do
+
+  ! header for stdout
+  write(*,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
+       'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
+
+  nFiles_inv = 1.0d0/dble(inp%nStrucs)
+  structures : do ifile = 1, inp%nStrucs
+
+     if (inp%do_timing) call tng_timing('Structure: '// io_adjustl(ifile))
+
+     call aeio_readline(u_in, iline, line)
+     cooFile = trim(line)
+
+     call geo_init(cooFile, 'xsf')
+     if (inp%do_timing) call tng_timing3(register=R_GEO)
+     if (.not. (hasForces .and. hasEnergy)) then
+        write(0,*) ">>>", hasForces, hasEnergy
+        write(0,*) "Error: incomplete output data in : ", trim(cooFile)
+        call finalize()
+        stop
+     end if
+
+     if (nTypes > inp%nTypes) then
+        write(*,*) 'Skipping ', trim(adjustl(cooFile)), &
+                   ': too many atomic species'
+        call geo_final()
+        cycle structures
+     end if
+
+     if (abs(cohesiveEnergy) /= 0.0d0) then
+        E_coh = cohesiveEnergy
+     else
+        ! if only the total energy is available, we have to calculate
+        ! the cohesive energy at this point
+        E_coh = totalEnergy
+        do iatom = 1, nAtoms
+           itype1 = atomType(iatom)
+           itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                  inp%nTypes, inp%typeName)
+           E_coh = E_coh - inp%atomicEnergy(itype1)
+        end do
+     end if
+
+     write(*,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
+          ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
+          trim(adjustl(cooFile))
+
+     call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
+     if (inp%do_timing) call tng_timing3(register=R_NBL)
+
+     ! write structure info (atoms, types, energy) to training set file:
+     call ts_write_structure_info(ts, cooFile, nAtoms, nTypes, E_coh)
+     
+     ! write structure info (atoms, types) to pytorch forces file:
+     if (inp%pyo_forces) then
+       pyo_forces_struc = struc_write_force(ifile)
+       call pyo_write_structure_info(u_pyo, cooFile, nAtoms, nTypes, pyo_forces_struc)
+     end if
+
+     atoms : do iatom = 1, nAtoms
+
+        ! determine the training atom type of atom `iatom' in global
+        ! index terms
+        itype1 = atomType(iatom)
+        itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                               inp%nTypes, inp%typeName)
+
+        ! assert that atom type is included in the set-ups:
+        if (itype1 == 0) then
+           write(0,*) "Error: not a valid structure    : ", trim(cooFile)
+           write(0,*) "       Additional species found."
+           call finalize()
+           stop
+        end if
+
+        ! write atom info (species, forces) to training set file:
+        call ts_write_atom_info(ts, itype1, cooCart(iatom), forCart(iatom))
+
+        ! get all atoms within cut-off:
+        nnb = nnb_max
+        call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nblist=nblist, nbtype=nbtype)
+
+        if (inp%do_timing) call tng_timing3(register=R_NBL)
+        write(*,'(1x,I6,2x,A2,2x,I6)') &
+             iatom, trim(atomTypeName(atomType(iatom))), nnb
+
+        ! convert atom types to global index:
+        do i = 1, nnb
+           nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
+                                    inp%nTypes, inp%typeName)
+           if (nbtype(i) == 0) then
+              write(0,*) "Error: atom type not found in setup."
+              call finalize()
+              stop
+           end if
+        end do
+
+        ! evaluate the structural fingerprint basis function set-up:
+        call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
+                      stp(itype1), sfval=sfval, sfderiv_i=sfderiv_i, &
+                      sfderiv_j=sfderiv_j)
+
+        if (do_debug) then
+           do idbg = 1, stp(itype1)%nsf
+              write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
+           end do
+           write(u_dbg,*)
+        end if
+
+        if (inp%do_timing) call tng_timing3(register=R_SF)
+
+        ! write basis function values and derivatives
+        ! to the training set file:
+        call ts_write_sf_info(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf))
+
+        ! write basis function derivatives and neighbor list to pytorch output
+        if (inp%pyo_forces .and. pyo_forces_struc==1) then
+          max_nnb_trainset = max(max_nnb_trainset, nnb)
+          call pyo_write_atom_sf_info(u_pyo, itype1, nnb, stp(itype1)%nsf, nblist(:nnb), &
+                                      sfderiv_i(1:3,1:stp(itype1)%nsf), &
+                                      sfderiv_j(1:3,1:stp(itype1)%nsf,1:nnb) )
+        end if
+
+     end do atoms
+
+     if (inp%do_timing) then
+        call tng_dump(R_GEO, 'time spent reading geometries (so far)')
+        call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
+        call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
+     end if
+
+     call lcl_final()
+     call geo_final()
+
+  end do structures
+  write(*,*)
+
+  if (inp%do_timing) then
+     call tng_timing('Loop over structures done.')
+     call tng_dump(R_GEO, 'total time spent reading geometries')
+     call tng_dump(R_NBL, 'total time spent in the neighbor list')
+     call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
+  end if
+
+  !--------- save basis function setups with final statistics ---------!
+
+  call ts_print_info(ts)
+
+  !----------------------------- finalize -----------------------------!
+
+  deallocate(nbcoo, nbdist, nblist, nbtype)
+  close(u_in)
+  
+  if (inp%pyo_forces) then
+    call pyo_write_final(u_pyo, max_nnb_trainset)
+  end if
+
+  call close_TrnSet(ts, stp=stp(1:inp%nTypes))
+  call finalize()
+
+
+contains !=============================================================!
+
+
+  subroutine initialize(inFile)
+
+    implicit none
+
+    character(len=*), intent(out) :: inFile
+
+    integer :: nargs
+    logical :: fexists
+
+    call aeio_header("generate.x - training set generation", char='=')
+    write(*,*)
+
+    call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+
+    nargs = command_argument_count()
+    if (nargs < 1) then
+       write(0,*) "Error: No input file provided."
+       call print_usage()
+       call finalize()
+       stop
+    end if
+
+    call get_command_argument(1, value=inFile)
+    inquire(file=trim(inFile), exist=fexists)
+    if (.not. fexists) then
+       write(0,*) "Error: File not found: ", trim(inFile)
+       call print_usage()
+       call finalize()
+       stop
+    end if
+
+  end subroutine initialize
+
+  !--------------------------------------------------------------------!
+
+  subroutine finalize()
+
+    implicit none
+
+    integer :: itype
+
+    if (allocated(sfval)) then
+       deallocate(sfval, sfderiv_i, sfderiv_j)
+    end if
+
+    if (allocated(stp)) then
+       call stp_final(inp%nTypes, stp)
+       do itype = 1, inp%nTypes
+          call del_Setup(stp(itype))
+       end do
+       deallocate(stp, inp%typeName, inp%atomicEnergy)
+    end if
+
+    if (ts%init) call close_TrnSet(ts)
+
+    if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
+
+    if (inp%do_timing) call tng_final()
+    if (do_debug)  close(u_dbg)
+
+    call aeio_header(aeio_timestamp(), char=' ')
+    call aeio_header("Training set generation done.", char='=')
+
+  end subroutine finalize
+
+  !--------------------------------------------------------------------!
+
+  subroutine print_usage()
+
+    implicit none
+
+    write(*,*)
+    write(*,*) "generate.x -- Generate training sets for use with `train.x'"
+    write(*,'(1x,70("-"))')
+    write(*,*) 'Usage: generate.x <input-file>'
+    write(*,*)
+    write(*,*) 'See the documentation or the source code for a description of the '
+    write(*,*) 'input file format.'
+    write(*,*)
+
+  end subroutine print_usage
+
+  !--------------------------------------------------------------------!
+
+  subroutine load_symmfunc_setups(inp, stp)
+
+    implicit none
+
+    type(InputData),           intent(in)  :: inp
+    type(Setup), dimension(:), intent(out) :: stp
+
+    integer :: i
+
+    do i = 1, inp%nTypes
+       stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
+       if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
+          write(0,*) "Error: Inconsistent atom type in setup:"
+          write(0,*) "       type expected : ", trim(inp%typeName(i))
+          write(0,*) "       type found    : ", trim(stp(i)%atomtype)
+          call finalize()
+          stop
+       end if
+    end do
+
+  end subroutine load_symmfunc_setups
+
+end program generate
diff -Naru src/kan.mod src_modified/kan.mod
--- src/kan.mod	1970-01-01 09:00:00
+++ src_modified/kan.mod	2024-09-10 10:49:23
@@ -0,0 +1,15 @@
+‹      í\[s¢Ê~ï_Ño˜‡9ÅUáÑQ&Ç£jö™'
+áD1¥&3Ù¿~¯ÅE›«(ÉÙ»ªBBìoİ/½šûoccftGt³}z]ÛôÍŞí­K9Aáèrg[û‰®vÛİ¿.Ìõlïìırç¼¶»ı¿VOZ­;ZÇ7	¸#ğ#\-`ÙkóÅÚYû Ø8Ê=[.GE*Ÿ
+/‰r)sh«Õ×Á£Ş§óÑ÷ÑøÑ—Áh¦fÇÛ‰1î‘à&ü%åá«;{foü0t-™rîÚz÷>¾…q¯TöäixDœHWø6ÌZ›2Ö¾}éözútŠL[
+@pÖıÆú"ÂÜºA´)÷kïüi@[¤n`Ã›µ~µs$qMj(Š<åI_ÿ¦h ¯æÕÔƒœ©fwÖı:Ôiğ ¦ƒñè²j”[½º'˜$&Í…IJ².&“¡O9çWnFa’ÊÜŒÂ$%¸) óí&)ÏÍLR‘›˜¤%ˆ`¥€ÒĞ»Cªœôn>ˆ´Ákÿ2='†Q<ÃH.1ŸÊ¿¿HCJ*K»`ô)ˆQAnnÖ/ù¸‡¸fj 7{ÿîİŞlFà~Ój‘Şx4uE¦G ¯!ğ¢ÌáÍu=¾ aÇ:l7‡÷»Fôâ9ôêIQ•p®í2¼VJ´¬î£R @‚õ‘s/I6ïJ°¬kÜE€³[šÇM7Á ¥,.ø‹{IaŠºZN*B¤Ù¯
+E(X’oÑüõ­B”À*ö«ÆŒBÄ‚b¿òª4Š†P((¾(HÕìğšùŒØF˜|ØyÖÃ{I9ÅKòüAñ†²MÏpHÖ›ù.ûTûª’3^kK1U£!P¶«€’ƒÁ¥—Ä‡8­·ÿ¢iÔœLB Ëí[1É7’ƒKc\pæÕ]5:Ô++gãH‰äåFY«„Qf»ÛXkçOû	ï=l+¼¿nÓHÂ0³´<æ¥Gõó ƒÇOguhdqˆv¶g½ââª·x–·¼ââ˜õ.ğæ‹Ë`bnXp4Ô#”Á½º^É¸=4Ö®•Ñwî»×e“œ ÷‰Â0]kãI¤şê™LÉí‚”,{êâNè;)ñ¯™GËà‡-s·,`’uW2xá]tira\<zËØº1İec7²Š´ç¸ª‚3vŸ›[_Áö¾›ŸB•k°R¨ê©3[yû‘;¡0öì<µ özlNç`kk¼‘²à+Z­"…à-&ãI¥¦!{ıQW‘ØÅÏ×êV”ã^w°ó‘ë5.´)8Ú‘ïf‘t‚]ï¢(®£Uêqç»Ynh¡\ŠÀh|¼Í{[àÖìFkã=™6n0ÿú|q/ü“°‚‰û²uÜCƒeP¢B`¾^.Q`ç;’”Ş\¼Ê	­˜ÑÆÌi¹ßLÂí#\ë0·sBû˜‘gñœ©µ'•XZµ ok>FñOjtx#(èÇÔè>F&?ˆ¬;"öãwûƒ›mó:)½yZ©B¹£“ù×á wüÜ€Mü‘(?kçÖğ´Å0`|^ãe¹#Kw¤QÊ4—[÷ÍŞLG6•£\¢ÖÎq÷Îòî8ÓŠ@õşÜĞKw‹¾ÍG½0–êCx<™Nàs|<!ßTÆ.0Şû˜f+‚pËˆûÉ^™ë0#0sfr»ÆÀÛó+¢$ƒ‡	ğy0û2í>ê¾:³Á7ø€Ÿu{}æë_8é+‚ïãğù$zÑ¿¬Eä…Ü‡KAÍ}!ÆNÛM
+‚nû ±«Z 5{:_[g?&¨­,ó§µÿy“=¸	 íÎtZ¼®lÈ	ËLŒ)«Œÿ¬§oÀÅu!™öïƒí>íKR¸1¬£ïC'c|ÒˆbPGcÄÜ"Ë,j1G(àÔ^Ş9q•ªxæ+kÁ25ÆóÙ`¤'<Ä—?º?¦¦şß&)~„™Ä{Z;ğôãGsƒ¾gò“îtJ¦½‡ÔÒÉ¤‡æÅ#r=÷Êq½=ê‘r*‘—¢NR¨8º©Ã„a Ï!œ²	W<e³ÖëíÒ: ¹ÅRâtW`	§ŸÌkŠrâ3	IóÌè›UğÍÇ­ıÒq8lú0îÏ‡ºOu_ï	›ä˜}0‘©„¤ªTÕ<=KFÜÃÒZ/ÍÅsÍØáÎ<eYH5Õii"Õ$ªÉTS¨Ö¦Z‡ï4pèËŸöâ}ÿÓ~3_¶ëww»qĞÜ
+‘@’$Ä4ê˜m²£)I×á#c'Çš†Ø§/À%Â%ù939ºıjÎ·›ñ${F"Áp>-n÷ Š†(JƒAkx9"""xğ¼z»Í~x:3V‹œJ˜ iû‚è T•©S#
+X†ƒçB¼PL,ıéôZÁæÚ‰Û… xŞE@ĞA‚K†K«$¨pi	²ˆON#{±ÈË5q¤%°Ø<Äb!í¬ßE¼Í8b3ò`–àñZ½g1YÛ8¨‹H«ğ³kİ&Üè†Ù×'ú¨¯z?˜Œ%17èƒú ‚>ˆI}(ÀDtº°|n+ò”Èˆ@ ÄÓ¤ £IÏ ‰ë$0+	ÌJ³’Ú)ˆ;4õ4j©R<UEé½>}ìå‹üÄX„•ªâ,çÂ\-kÑPvÌŠ{‚ä>"È\dÁÇ)‹Iœ8
+ôkç€¿õØzóìHeOø2]n{mƒ¤Ğ¡2ñº0/ï¹•µÜ©® ‘¢©pÍRĞú¼óäH×«ñÂC.y
+%/³.Î"/T&bè½¹1ßK™tegH—Q‰ HŞ¨rRtêiÌ„ó¾ÕN´g31\¬ÙŸ?<8{ßş.ÓÙ©[l_¤Øœ—í{ßZ¬zW Ç1A bû¢<å»%f‚3%‘%É€ª¡¤¤gd£¯yvÙtby²Å[“]:}'ñZ‚ùhN-‘˜fÒäêX˜rÃ¡õee±„•7B–j/Š?-×€vìÉõ÷R³eè)¥[I=?éVy0LåêÄ½üÃÚúX‹Mnwä©vÙds’µ4‚å/]›äK‘µ6„WÜodml©…åÕ<¶¸@‰®¶×Ñ:Ù”¡OçÃ;KÌf‰[Y%#Ëœe*ee$l´UŠ'+#1ƒ–ú\ÇVWLîÅrº“ßª¶o*ğjd¨*J)U_ÊÉó°}öÿ“èa°‚ş¬EÎşÛŠiY4ˆdCå¹õoU%^îw=J{X|Ìo«©Å!ı½hjqïÈÎvU‡ä;ŒLø6~«
+6ÛøTFºúw¢_%Sˆÿìı‹“gP/ŠÉ~îW4ÓDÂ­‘DŞ!fDåî$I^µ$ÜéjŸóG)¯u1¨sÖòk#=»NE/îÀ·‰.×Ú½WÆBø¨õf½È ¾É!¡1’Ø”EáÛ’
+Ó å\_.BSQ]ğ}u)	¥mÁ×ìœÿ0Ü´¶—½{5µ8X§-~‰«/DIÆYn¤ŞÅ#ìIsMB¹¹â¡ò}D=äÒ»K‘-º‹˜ãÿà	ó§ı!N!ÕŠHó±v;ëäBşBLÇ4ÒÁÙà~>O&ağ÷İétş ÷M£;úÎ,Û^¼lsØ9Ov
+üdS9ÑñØÎuÊğÔ‰i’cŠ÷Z$×Ú$‹Ñu"wh0Á}R|Q8ã5á<•
+\àiG&Ù'à%oi“è\(OqPô8Š‰ç@Òfáo*É˜­Ã6£’6Ë†Ô"aØ”ùÔñ+Šñ'|\¦àg‰'¬!ü‹À–á½q•ãp
+Ş-±œ‘îÈ_¾ÍCC—^  
\ No newline at end of file
diff -Naru src/makeKANdescriptors.f90 src_modified/makeKANdescriptors.f90
--- src/makeKANdescriptors.f90	1970-01-01 09:00:00
+++ src_modified/makeKANdescriptors.f90	2024-09-10 11:05:47
@@ -0,0 +1,11 @@
+program main
+    use makeKAN,only:initialize,makeKANdescriptor
+    implicit none
+    character(len=1024) :: infile,outfile
+    integer::npoints
+    logical::frombinary
+
+    call initialize(infile,outfile,npoints,frombinary) 
+    call makeKANdescriptor(infile,outfile,npoints,frombinary)
+
+end program
\ No newline at end of file
diff -Naru src/makefiles/Makefile.ifort_intelmpi src_modified/makefiles/Makefile.ifort_intelmpi
--- src/makefiles/Makefile.ifort_intelmpi	2024-09-06 10:37:30
+++ src_modified/makefiles/Makefile.ifort_intelmpi	2024-09-06 10:37:30
@@ -27,11 +27,11 @@
 
 SUFFIX   = ifort_intelmpi
 
-FC       = mpiifort -c
-LD       = mpiifort
+FC       = mpiifx -traceback -check bounds -c
+LD       = mpiifx
 DEBUG    =
 FCFLAGS  = -DPARALLEL -O2 $(DEBUG)
-LDFLAGS  = -static-intel $(DEBUG)
+LDFLAGS  = -static-intel -DPARALLEL $(DEBUG)
 NUMLIB   = -Wl,--start-group \
            $(MKLROOT)/lib/intel64/libmkl_intel_lp64.a \
            $(MKLROOT)/lib/intel64/libmkl_core.a \
diff -Naru src/makekan.mod src_modified/makekan.mod
--- src/makekan.mod	1970-01-01 09:00:00
+++ src_modified/makekan.mod	2024-09-10 11:05:39
@@ -0,0 +1,8 @@
+‹      í\IsâJ¾×¯¨›ğáMhéHƒÚC4B€ßôI!°˜Ö`·ı~ıËÔ‚J+2²g&ÚD[6¦¾Ü¾ÌÊJéöûÔXı	}Ú=¼lmújïÎÎ¥œ pt½·­£ı@7ûİ=¼¬Ì'ëÑşÑŸ<Ø‡õŞy>îö‡l4t:7´‰/~sCà[xu8€eoÍgko=ÙGÀÆQA<Z.GE*Ş¾$Êİåü	ÇQv:CİİëCºœü˜Lÿœü1š,ôÉ‚„—3c:wúŸ‡ıñx:0Ó» ìÈ”s·Ö»·D?âV7¨Ly‚o¯A˜˜ˆá
+ßÇ©µ)km[ûæôş` Ïçş+ ÁyOÖ[ —€ˆ+à†°@t)÷ûàüegHi4 jxµ¶/ö¡=jhŠ"xÈPÿ®x ïî—»‡ïšıEÿÛX§ÃÑ>™¦¶Óh”Û¼¸L’“Â$U—“©P§œó»„6ã0ImmÆa’
+Ú€ùz“T×f=>*“t¢PzLÕ@“ŞÅ'±60÷oÓ#é,ŒâFrIøÔ68ğş*)©míFr‘µ€‚Ú|Ú>säóZòFXI@ÉÚü³oôˆ!€ı¤Ó!ƒéd¾èŠ\F ÖxQæğâc_€´cwOÇ÷g»Aôâ9ôúÉp•p®í2X«jİRÈQ  Áú¨9Ì—$_wTGÕµ"ÀÙ¯Í'ÇÍÁ e,.ø‹{EaG}X9(B¦9lJEhXRÑüÇG…(AT6­…ˆŠÃÆÛ¹`P´„BAóÅ•@êV‡YÏˆ]„Y‚ÃÎ«†^rÿÇñ’">è!ŞĞ¶ÙÉÁz5î‚ôpØÀ†Ê£¯:5ã¹¶’R5eS] ”\˜.İqI|ˆÓzı7†ög­É$!ºŞ½–³|+5¸9ÆµgÑ¾«Cg €ıÊÆÙä8R¡x¹RÕ*a–ÙíŸ¬­ó—ı §·£X6„^Çõw	KfÀÀ4³¶<•GÍë “Ç/gsleqÈv>³~àâª·x[~àâXõxõÅe17Üp´Ô#”^]oË¸;–DÑ|äÉÈ‡ãşeİ¦&€>Ñ¦k=yi~÷ÌN¦äzIJ–=ws§üTÌøYGËÀÃ–¹_—É¦w2°ğ>¾4¹pƒ\>{ËØº1İu~ º Jø¿Š²øĞ2vÛ[_Áö¾[\BUk°J¨ú¥sÆ¡›@‚sÉ½P{~Z{31§ ùØÅÆo¤*øšQ«H!x‹©xR«iÈÂŞ|ÖUävñëµºåtÖœ|²Æ…‰6G7vàİ.’^pê]ÅÇx•z:ùnWZh—20Z?ïòŞx€5¿ÑÚzO¦‹Ì¿¿†^E<ÿ"j…dâ>ï÷Øâ6¨Y!_¯–(qò+J¯n^%B+æ´1ZîW³p÷×úÊíEh¿‚r!ó¬s½–â¤–JënÀ»šQüÄ“=ŞÃúy'5z‚‘©ÇObëˆıøıáh&fÛ|B'×™Ç¼¡³å·ñhpúÜ@MüI(¿jçÕğ´Ã`|¿¬tU©Ç7¤iÊ4×;÷ÕŞMG6•£\ÒÖŞqÎúæ4ÔŠHõáÒĞ+·‹¾/'ƒh–êc”¼ £Îàs|@¡âTÆ10^û f'& à–÷ƒ½1×9šÁ®Yb8÷¾oŒ¼Ã¿2Ş2º›ÂG‹?æı{İ÷kc1ú?!}ãV_øüJEÂë¤|Z
+¥x=Z«+JàÃ¦÷à÷AÙ‚íu«¡ïúè±ÏZ~ğá•å~ñs†NÓéA*3Y‡_×™b˜ÜşB§å{-axù;g Hffj„Yeâ½œÔnH€×…eÚoGÛ}À"4×ÌT¡t6Åwq*(ä¨\~¤4"
+Qâ¡1<m€ğß¹8ªâ‘6f¾üfL—‹ÑD'IúƒùgÿçÜÔÿå(Å0Ó€#Wğó ™ŞC½œ5ëCb˜ÏôŠKg³†ĞU¤õãz'Ø1)ıtÅ–ò’:4"Å)BÎ*Š@f«T,œø‚+·YÛínmm.?WFÂŸ²[eZŠœ”dX°P´ày¡Tò™l I¯W´kÇa°qVZ§wÓár¬ûEèPŒ3„NøÚCXªJUÍã·tÑ€ ÖÖvm®kâ£ˆd%L€fTsä¡Õpš§£‰T“¨&SM¡Z—j=fÔ€××¿ìÕûá—ıj>ï¶ïîîÉÁ˜+-I‹‘Pó©(j¨„8$Å!>:v­iˆ_ày*ğ¼DxI~iMNT¡­Íù4åòAN/ç9z7€¢á}•Á`¶x9f&`"ğ@
+Pâz‡ÒGl™Ñ-fÙªBH ¢®oŒÀU™¾%ğ8Í€;v 1Äûµ?ÈŞ8àÂ!ÉqüH ?$xÉğRàÕ…ˆ%¨ğÒR¢_4^ö’“W5NICdW¸Øoô¶ÅUm=„aí¯šSÒOç¢è½WÓ;"ç{­óazíFÿ§	ºaõ™>ê“ÁO¦‚5† *>vğ|CßÓ¾H³Œğ´>Òª“bÖg¹@à¬8³Àh›5$ÑS£á&A¸InR7C=š{sk¥M}¦ÛÒ[}>:(vHÁ-VÅ±Ğ•¹Y7V °óe^~$/AA†$$>VYLcÅÉ¢ß{8ÙSo+• Ë#È
+àa; ìg¼¾Îó{é­¹Ü‹ƒÏ­ƒÏĞÇ6 ¥7<%£DºÙt¡zm /—”–Sá‘3ô0bèƒ¥1¢f˜_º H£ŠHEòşB•ÓBªÑ(ç}©½X>±¸Õ9\ŞİL?p“ÛòQ¡(Ù½?¨Ñ9oËà}iñÎ,ãT]Ç±É!D(£b¹ÂEP fTÁ$ı°íèõì™ØH@.[îRê¯.¶xm±+×ş$¹a¾µ`#’êDhr},L»á`üº¶Ù"c©eÆ‹âOäµ ›¸MåŠş{iØ2|‹Tò­´ŸG¾UÓ¹z‰kş¯ÚæT‹nÒ©vAØäk’µ4ŞhË_º6)¶"kmH¯xüŞÊÚ8<ÓˆÊë1ö¸#@…ş°×YˆbÊĞçËñ‚]%æ«ˆ$£¬Vå”UŠ2véjeÇ(ÊHBãÀ`Áí«¾Ö±G–°{¹š.â­zG²¯Æ·2 TÂQÓñÁ/±:{nÿ=…¶køÉ[äì°™UE#€X5T]»q~«ka`¹·fTfX|ÊÌ›ÕÖâP‰¾­ÚZÜ»-è‚¸jÂò=F%|¿Ö6?øTF¹ú¿$¿cfÿÕû¿3¤Åt?7Úi"á9JªîHb)Qî%Ï~‘W¯	ÇºçúQª{GS
+êµüZ…Ã(Ï.ƒS“Ãñá øäÒ•ãZû÷ÚXŞ¼‡%ä`Á§E¤<FÛŠ(|DÚaZD£œûËEhjº>‚á.¡4â-ø¨‚½óŸÃU÷ö²÷ğ°¶Ç1î¬Å/¡úêH”tŞ‘åVö»x›|:\ÓP®®xãú!æråÓ¥ØİEÊñ&‡ğ.ö‡Ã1N)5ŠHğ±ö{+¢…¿Ó©Œ„rp1º]N—óÒ@‰ŞŸÏ—wúĞ4ú“Ëâ­á«÷£m{çÁÎ€Ÿƒì[a"9îûã¥NLµ&¡x^rØ›ä)ºI¤!q‡\ Å’3GÎS©ä½<íÉ¤øx›RbÒ\¡—6å)NŸf;yêz2&áw*ÉÒÃ–£’5‡¿Ôb#eØ ùÌÙ-ŠÉI)|»›€k‰'¬©üÀš¬á½¹–Ó^‚<‰A+‘nÈß*³÷g_  
\ No newline at end of file
diff -Naru src/parallel.F90 src_modified/parallel.F90
--- src/parallel.F90	2024-09-06 10:37:30
+++ src_modified/parallel.F90	2024-09-10 11:59:09
@@ -3,7 +3,7 @@
 !-----------------------------------------------------------------------
 !+ This file is part of the AENET package.
 !+
-!+ Copyright (C) 2012-2019 Nongnuch Artrith and Alexander Urban
+!+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
 !+
 !+ This Source Code Form is subject to the terms of the Mozilla Public
 !+ License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -13,19 +13,12 @@
 !+ WITHOUT ANY WARRANTY; without even the implied warranty of
 !+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 !+ Mozilla Public License, v. 2.0, for more details.
-!+ ---------------------------------------------------------------------
-!+ If you make use of AENET for your publication, please cite:
-!+ [1] N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.
-!+ [2] J. Behler and M. Parrinello, Phys. Rev. Lett. 98 (2007) 146401.
-!+
-!+ If you used the Chebyshev descriptor, please cite:
-!+ [3] N. Artrith, A. Urban, and G. Ceder, PRB 96 (2017) 014112.
 !-----------------------------------------------------------------------
 !
 ! This module mainly provides generic interfaces to the FORTRAN 77 MPI
 ! bindings.  The MPI send, receive and broadcast operations are
 ! simplified for the case of a rank 0 master process and the single
-! communicator MPI_COMM_WORLD.
+! communicator mpi_comm_aenet.
 !
 ! The prodedures for sending and receiving derived types defined in
 ! this module only send primitive data types.  This is probably not
@@ -35,8 +28,28 @@
 ! 2011-11-10 Alexander Urban (AU), Nongnuch Artrith (NA)
 !-----------------------------------------------------------------------
 
+module aenet_mpimodule
+#ifdef PARALLEL
+   use mpi
+#endif
+!  use common_variables, only : mpi_comm_aenet_sub, myrank_sub, nprocs_sub
+  implicit none
+  !include 'mpif.h'
+  save
+#ifdef PARALLEL
+  !TYPE(mpi_comm), public :: mpi_comm_aenet = mpi_comm_world
+  integer, public :: mpi_comm_aenet = mpi_comm_world
+#endif
+end module aenet_mpimodule
 
+
+
+
 module parallel
+#ifdef PARALLEL
+  !use mpi_f08
+  use mpi
+#endif  
 
   use aeio,        only: aeio_header
 
@@ -45,7 +58,7 @@
 
   use input,       only: InputData
 
-  use io,          only: io_adjustl
+  use io,          only: io_adjustl,io_lower
 
   use potential,   only: NNPot
 
@@ -54,14 +67,16 @@
 
   use trainset,    only: TrnSet,      &
                          new_TrnSet_info
+  use aenet_mpimodule,only:mpi_comm_aenet
 
+  use KAN, only :KAN_descriptor
+
   implicit none
   save
 
-#ifdef PARALLEL
-  include 'mpif.h'
-#endif
 
+!  include 'mpif.h'
+
   public::  pp_init,              &
             pp_final,             &
             pp_print_info,        &
@@ -88,7 +103,8 @@
             pp_bcast_NNPot,       &
             pp_bcast_coo,         &
             pp_bcast_latt,        &
-            pp_sum_weights
+            pp_sum_weights, &
+            set_isinit_false
 
   !------------------------------ public ------------------------------!
 
@@ -104,6 +120,7 @@
 
 #ifdef PARALLEL
   integer, dimension(MPI_STATUS_SIZE) :: status
+  !TYPE(MPI_Status):: status
 #endif
 
   !--------------------------------------------------------------------!
@@ -198,10 +215,22 @@
                       pp_sum_dn
   end interface
 
+  !--------------------------------------------------------------------!
+  !           training set file footer containing statistics           !
+  !--------------------------------------------------------------------!
 
+
+
+
 contains !=============================================================!
 
 
+  subroutine set_isinit_false()
+    implicit none
+    isInit = .false.
+    return
+  end subroutine set_isinit_false
+
   subroutine pp_init()
 
     implicit none
@@ -209,10 +238,10 @@
     if (isInit) return
 
 #ifdef PARALLEL
-    call MPI_Init(ierr)
+!    call MPI_Init(ierr)
 
-    call MPI_Comm_size(MPI_COMM_WORLD, ppSize, ierr)
-    call MPI_Comm_rank(MPI_COMM_WORLD, ppRank, ierr)
+    call mpi_comm_size(mpi_comm_aenet, ppSize, ierr)
+    call mpi_comm_rank(mpi_comm_aenet, ppRank, ierr)
 
     isParallel = .true.
 #endif
@@ -224,9 +253,103 @@
     end if
 
     isInit = .true.
+    
 
   end subroutine pp_init
 
+
+  subroutine pp_calc_and_Bcast_footer(ts, stp)
+
+    implicit none
+
+    type(TrnSet),intent(inout) :: ts
+    type(Setup), dimension(:), intent(inout) :: stp
+
+    real(8) :: E_max, E_min, E_av, E_avsum, E_avsum_sum,Etemp
+    integer :: nAtomsTot, nStrucs,ntemp
+    integer :: ierr, itype
+    integer :: neval,itemp
+    real(8), dimension(:), allocatable :: d2
+
+   !   calculate max, min, average
+    E_avsum = ts%E_av * dble(ts%nStrucs)
+#ifdef PARALLEL
+    call MPI_ALLREDUCE( ts%nAtomsTot, nAtomsTot, 1, MPI_INTEGER, MPI_SUM, mpi_comm_aenet, ierr )
+#endif
+    Etemp = ts%E_max
+    call pp_bcast(Etemp)
+    ts%E_max = max(ts%E_max,Etemp)
+#ifdef PARALLEL
+    call MPI_ALLREDUCE( ts%E_max, E_max, 1, MPI_DOUBLE_PRECISION, MPI_MAX, mpi_comm_aenet, ierr )
+#endif  
+    Etemp = ts%E_min
+    call pp_bcast(Etemp)
+    ts%E_min = min(ts%E_min,Etemp)
+
+#ifdef PARALLEL
+    call MPI_ALLREDUCE( ts%E_min, E_min, 1, MPI_DOUBLE_PRECISION, MPI_MIN, mpi_comm_aenet, ierr )
+#endif    
+    call MPI_ALLREDUCE( E_avsum, E_avsum_sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, mpi_comm_aenet, ierr )
+
+    itemp = ts%iStruc
+#ifdef PARALLEL
+    call MPI_ALLREDUCE( itemp, nStrucs, 1, MPI_INTEGER, MPI_SUM, mpi_comm_aenet, ierr )
+#endif
+
+    ts%nAtomsTot = nAtomsTot
+    ts%E_max = E_max
+    ts%E_min = E_min
+    ts%nStrucs = nStrucs
+    ts%iStruc = nStrucs
+    ts%E_av = E_avsum_sum / dble(ts%nStrucs)
+
+
+    if (ts%iStruc < ts%nStrucs) then
+       write(0,*) "Warning: writing footer to incomplete training set file."
+    end if
+
+    do itype = 1, ubound(stp,1)
+       stp(itype)%neval= max( stp(itype)%neval,0)
+#ifdef PARALLEL
+       call MPI_ALLREDUCE( stp(itype)%neval, neval, 1, MPI_INTEGER, MPI_SUM, mpi_comm_aenet, ierr )
+#endif
+       allocate(d2(1:ubound(stp(itype)%sfval_min,1)))
+#ifdef PARALLEL       
+       call MPI_ALLREDUCE( stp(itype)%sfval_min, d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_MIN, mpi_comm_aenet, ierr )
+#endif       
+       stp(itype)%sfval_min = d2
+       deallocate(d2)
+       allocate(d2(1:ubound(stp(itype)%sfval_max,1)))
+#ifdef PARALLEL       
+       call MPI_ALLREDUCE( stp(itype)%sfval_max, d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_MAX, mpi_comm_aenet, ierr )
+#endif       
+       stp(itype)%sfval_max = d2
+       deallocate(d2)
+       allocate(d2(1:ubound(stp(itype)%sfval_avg,1)))
+#ifdef PARALLEL       
+       call MPI_ALLREDUCE( stp(itype)%sfval_avg*stp(itype)%neval, &
+          d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_SUM, mpi_comm_aenet, ierr )
+#endif          
+       stp(itype)%sfval_avg = d2 / neval
+       deallocate(d2)
+       allocate(d2(1:ubound(stp(itype)%sfval_cov,1)))
+#ifdef PARALLEL       
+       call MPI_ALLREDUCE( stp(itype)%sfval_cov*stp(itype)%neval, &
+          d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_SUM, mpi_comm_aenet, ierr )
+#endif          
+       stp(itype)%sfval_cov = d2 / neval
+       deallocate(d2)
+
+       stp(itype)%neval = neval
+
+   !       write(*,*) 'CHECK', itype, stp(itype)%neval, &
+   !       stp(itype)%sfval_min(1), stp(itype)%sfval_max(1), stp(itype)%sfval_avg(1), &
+   !       stp(itype)%sfval_cov(1)
+
+    end do
+
+  end subroutine pp_calc_and_Bcast_footer    
+
   !--------------------------------------------------------------------!
 
   subroutine pp_final()
@@ -236,7 +359,7 @@
     if (.not. isInit) return
 
 #ifdef PARALLEL
-    call MPI_Finalize(ierr)
+!    call MPI_Finalize(ierr)
 #endif
 
     isInit     = .false.
@@ -347,7 +470,126 @@
 
   end subroutine pp_bcast_Network
 
+    !--------------------------------------------------------------------!
+  !                                                                    !
+  !                 send/receive KAN descriptor                 !
+  !                                                                    !
   !--------------------------------------------------------------------!
+
+  subroutine pp_send_KAN(stp, dest)
+
+    implicit none
+
+    type(KAN_descriptor), intent(in) :: stp
+    integer,     intent(in) :: dest
+
+    integer :: isf, nsfp, nenv,ik
+
+    if (.not. isParallel) return
+
+    call pp_send(stp%npoints, dest)
+    call pp_send(stp%nk, dest)
+    call pp_send(stp%b_KAN, stp%nk, dest)
+
+    call pp_send(stp%bk_r1,stp%nk,dest)
+    call pp_send(stp%bk_a1,stp%nk,dest)
+
+    call pp_send(stp%multi,dest)
+
+    call pp_send(stp%ntypes, dest)
+    if (stp%multi) then
+      call pp_send(stp%bk_r2,stp%nk,dest)
+      call pp_send(stp%bk_a2,stp%nk,dest)
+      do ik = 1, stp%nk
+        call pp_send(stp%values_r2(1:stp%npoints,ik),stp%npoints,dest)
+        call pp_send(stp%values_a2(1:stp%npoints,ik),stp%npoints,dest)
+      enddo
+    end if
+
+    do ik = 1, stp%nk
+      call pp_send(stp%values_r1(1:stp%npoints,ik),stp%npoints,dest)
+      call pp_send(stp%values_a1(1:stp%npoints,ik),stp%npoints,dest)
+    enddo
+
+    call pp_send(stp%points_r,stp%npoints,dest)
+    call pp_send(stp%points_a,stp%npoints,dest)
+
+    call pp_send(stp%r_Rc,dest)
+    call pp_send(stp%r_Nc,dest)
+    call pp_send(stp%a_Rc,dest)
+    call pp_send(stp%rc_min,dest)
+    call pp_send(stp%first_fun,dest)
+
+    call pp_send(stp%typeid,stp%ntypes,dest)
+    call pp_send(stp%typespin,stp%ntypes,dest)
+
+  end subroutine pp_send_KAN
+
+  function pp_recv_KAN() result(stp)
+
+    implicit none
+
+    type(KAN_descriptor) :: stp
+    integer     :: isf, nsf, nenv, ntypes_global, nsfp,ik
+    if (.not. isParallel) return
+
+    call pp_recv(stp%npoints)
+    call pp_recv(stp%nk)
+    allocate(stp%b_KAN(stp%nk))
+    allocate(stp%bk_r1(stp%nk))
+    allocate(stp%bk_a1(stp%nk))
+
+    call pp_recv(stp%b_KAN, stp%nk)
+
+    call pp_recv(stp%bk_r1,stp%nk)
+    call pp_recv(stp%bk_a1,stp%nk)
+
+    call pp_recv(stp%multi)
+    call pp_recv(stp%ntypes)
+
+    if (stp%multi) then
+      allocate(stp%bk_r2(stp%nk))
+      allocate(stp%bk_a2(stp%nk))
+      allocate(stp%values_r2(stp%npoints,stp%nk))
+      allocate(stp%values_a2(stp%npoints,stp%nk))
+      call pp_recv(stp%bk_r2,stp%nk)
+      call pp_recv(stp%bk_a2,stp%nk)
+      do ik = 1, stp%nk
+        call pp_recv(stp%values_r2(1:stp%npoints,ik),stp%npoints)
+        call pp_recv(stp%values_a2(1:stp%npoints,ik),stp%npoints)
+      enddo
+    end if
+
+
+    allocate(stp%values_r1(stp%npoints,stp%nk))
+    allocate(stp%values_a1(stp%npoints,stp%nk))
+
+    do ik = 1, stp%nk
+      call pp_recv(stp%values_r1(1:stp%npoints,ik),stp%npoints)
+      call pp_recv(stp%values_a1(1:stp%npoints,ik),stp%npoints)
+    enddo
+
+    allocate(stp%points_r(stp%npoints),stp%points_a(stp%npoints))
+
+    call pp_recv(stp%points_r,stp%npoints)
+    call pp_recv(stp%points_a,stp%npoints)
+
+    call pp_recv(stp%r_Rc)
+    call pp_recv(stp%r_Nc)
+    call pp_recv(stp%a_Rc)
+    call pp_recv(stp%rc_min)
+    call pp_recv(stp%first_fun)
+
+    allocate(stp%typeid(stp%ntypes),          &
+      stp%typespin(stp%ntypes))
+
+    call pp_recv(stp%typeid,stp%ntypes)
+    call pp_recv(stp%typespin,stp%ntypes)
+
+  end function pp_recv_KAN
+
+
+  !--------------------------------------------------------------------!
   !                                                                    !
   !                 send/receive basis function set-up                 !
   !                                                                    !
@@ -367,6 +609,7 @@
     call pp_send(stp%nsf, dest)
     call pp_send(stp%nenv, dest)
     call pp_send(stp%ntypes_global, dest)
+    
 
     call pp_send(stp%neval, dest)
     call pp_send(stp%atomtype, dest)
@@ -376,6 +619,7 @@
 
     call pp_send(stp%envtypes, stp%nenv, dest)
     call pp_send(stp%gtype, stp%nenv, dest)
+
     call pp_send(stp%ltype, stp%ntypes_global, dest)
 
     call pp_send(stp%sf, stp%nsf, dest)
@@ -391,6 +635,13 @@
     call pp_send(stp%sfval_avg(1:stp%nsf), stp%nsf, dest)
     call pp_send(stp%sfval_cov(1:stp%nsf), stp%nsf, dest)
 
+    call pp_send(stp%init, dest)!added
+    call pp_send(stp%description, dest)!added
+    
+    if (trim(io_lower(stp%sftype)) .eq. "chebyshevkan") then
+      call pp_send_KAN(stp%kan, dest)
+    end if
+
   end subroutine pp_send_Setup
 
   !--------------------------------------------------------------------!
@@ -401,7 +652,6 @@
 
     type(Setup) :: stp
     integer     :: isf, nsf, nenv, ntypes_global, nsfp
-
     if (.not. isParallel) return
 
     call pp_recv(nsf)
@@ -431,6 +681,13 @@
     call pp_recv(stp%sfval_avg(1:stp%nsf), nsf)
     call pp_recv(stp%sfval_cov(1:stp%nsf), nsf)
 
+    call pp_recv(stp%init)!added
+    call pp_recv(stp%description)!added
+
+    if (trim(io_lower(stp%sftype)) .eq. "chebyshevkan") then
+      stp%kan = pp_recv_KAN()
+    end if
+
   end function pp_recv_Setup
 
   !--------------------------------------------------------------------!
@@ -723,6 +980,13 @@
 
     call pp_send(inp%mc_relax_final, dest)
 
+    call pp_send(inp%print_atomic_energies, dest)
+
+    call pp_send(inp%file, dest) !added
+    call pp_send(inp%outFileName, dest) !added
+    call pp_send(inp%verbosity, dest) !added  
+    call pp_send(inp%pyo_forces, dest) !added   
+
   end subroutine pp_send_InputData
 
   !--------------------------------------------------------------------!
@@ -833,6 +1097,14 @@
 
     call pp_recv(inp%mc_relax_final)
 
+    call pp_recv(inp%print_atomic_energies)
+
+    call pp_recv(inp%file) !added
+    call pp_recv(inp%outFileName) !added
+
+    call pp_recv(inp%verbosity) !added    
+    call pp_recv(inp%pyo_forces) !added  
+
   end function pp_recv_InputData
 
   !--------------------------------------------------------------------!
@@ -956,7 +1228,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Barrier(MPI_COMM_WORLD, ierr)
+    call MPI_Barrier(mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_barrier
@@ -982,9 +1254,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, 1, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_INTEGER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, 1, MPI_INTEGER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_INTEGER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) val, root
@@ -1006,9 +1278,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_INTEGER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_INTEGER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_INTEGER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1029,9 +1301,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) val, root
@@ -1053,9 +1325,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1076,9 +1348,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, 1, MPI_LOGICAL, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_LOGICAL, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, 1, MPI_LOGICAL, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_LOGICAL, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) val, root
@@ -1100,9 +1372,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_LOGICAL, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_LOGICAL, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_LOGICAL, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_LOGICAL, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1127,9 +1399,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_CHARACTER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_CHARACTER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_CHARACTER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_CHARACTER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     n = root
@@ -1156,9 +1428,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, m, MPI_CHARACTER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, m, MPI_CHARACTER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, m, MPI_CHARACTER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, m, MPI_CHARACTER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1189,7 +1461,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, 1, MPI_INTEGER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, 1, MPI_INTEGER, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) val, dest
 #endif
@@ -1211,7 +1483,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, n, MPI_INTEGER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, n, MPI_INTEGER, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) n, val, dest
 #endif
@@ -1232,7 +1504,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, 1, MPI_DOUBLE_PRECISION, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, 1, MPI_DOUBLE_PRECISION, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) val, dest
 #endif
@@ -1254,7 +1526,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, n, MPI_DOUBLE_PRECISION, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, n, MPI_DOUBLE_PRECISION, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) n, val, dest
 #endif
@@ -1275,7 +1547,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, 1, MPI_LOGICAL, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, 1, MPI_LOGICAL, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) val, dest
 #endif
@@ -1299,7 +1571,7 @@
 
 #ifdef PARALLEL
     n = len(val)
-    call MPI_Send(val, n, MPI_CHARACTER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, n, MPI_CHARACTER, dest, tag, mpi_comm_aenet, ierr)
 #else
     n = dest
     write(*,*) val
@@ -1325,7 +1597,7 @@
 
 #ifdef PARALLEL
     m = len(val(1))
-    call MPI_Send(val, m*n, MPI_CHARACTER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, m*n, MPI_CHARACTER, dest, tag, mpi_comm_aenet, ierr)
 #else
     m = n*dest
     write(*,*) val
@@ -1357,10 +1629,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, 1, MPI_INTEGER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, 1, MPI_INTEGER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = src
@@ -1385,10 +1657,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, n, MPI_INTEGER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n, MPI_INTEGER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = n*src
@@ -1412,10 +1684,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, 1, MPI_DOUBLE_PRECISION, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, 1, MPI_DOUBLE_PRECISION, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = 1.0*src
@@ -1440,10 +1712,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, n, MPI_DOUBLE_PRECISION, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n, MPI_DOUBLE_PRECISION, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = 1.0d0*n*src
@@ -1467,10 +1739,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, 1, MPI_LOGICAL, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, 1, MPI_LOGICAL, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = (src == 1)
@@ -1497,10 +1769,10 @@
     n = len(val)
     if (present(src)) then
        call MPI_Recv(val, n, MPI_CHARACTER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n, MPI_CHARACTER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     n = src
@@ -1529,10 +1801,10 @@
     m = len(val(1))
     if (present(src)) then
        call MPI_Recv(val, n*m, MPI_CHARACTER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n*m, MPI_CHARACTER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     m = src
@@ -1562,7 +1834,7 @@
     buff = val
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, 1, MPI_INTEGER, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_i1
@@ -1582,7 +1854,7 @@
     buff(1:n) = val(1:n)
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, n, MPI_INTEGER, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_in
@@ -1601,7 +1873,7 @@
     buff = val
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, 1, MPI_DOUBLE_PRECISION, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_d1
@@ -1621,10 +1893,25 @@
     buff(1:n) = val(1:n)
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, n, MPI_DOUBLE_PRECISION, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_dn
 
 
 end module parallel
+
+
+
+
+subroutine set_mpi_aenet(mpi_comm_in)
+  use aenet_mpimodule
+  use parallel,only:set_isinit_false
+  !type(mpi_comm),intent(in)::mpi_comm_in
+  integer,intent(in)::mpi_comm_in
+  integer::ierr
+  call set_isinit_false()
+  call mpi_comm_dup(mpi_comm_in,mpi_comm_aenet,ierr)
+!  mpi_comm_aenet = mpi_comm
+  return
+end subroutine set_mpi_aenet
\ No newline at end of file
diff -Naru src/potential.f90 src_modified/potential.f90
--- src/potential.f90	2024-09-06 10:37:30
+++ src_modified/potential.f90	2024-09-10 11:20:35
@@ -49,6 +49,7 @@
                          load_TrnSet_info, &
                          close_TrnSet,     &
                          ts_print_info
+  use KAN, only :KAN_descriptor                         
 
   implicit none
   save
@@ -141,6 +142,13 @@
     pot%net = load_Network(unit=u)
     pot%stp = load_Setup(global_types, unit=u)
     pot%ts  = load_TrnSet_info(unit=u)
+
+    if (trim(pot%stp%sftype) == "ChebyshevKAN") then
+      pot%stp%kan = KAN_descriptor(pot%ts%ntypes,u)
+      !write(*,*) pot%kan%points_r
+      !write(*,*) pot%stp%kan%values_r1
+      !stop 
+    end if
 
     pot%E_scale     = 1.0d0/pot%ts%scale
 
diff -Naru src/predict.F90 src_modified/predict.F90
--- src/predict.F90	2024-09-06 10:37:30
+++ src_modified/predict.F90	2024-09-06 10:37:30
@@ -33,7 +33,7 @@
   use aenet,     only: aenet_init,                     &
                        aenet_final,                    &
                        aenet_atomic_energy,            &
-                       aenet_atomic_energy_and_forces, &
+                       aenet_atomic_energy_and_forces_novirial, &
                        aenet_convert_atom_types,       &
                        aenet_free_atom_energy,         &
                        aenet_load_potential,           &
@@ -640,7 +640,7 @@
                             nblist=nblist, nbtype=nbtype)
 
        if (do_F) then
-          call aenet_atomic_energy_and_forces( &
+          call aenet_atomic_energy_and_forces_novirial( &
                coo_i, type_i, iatom, nnb, nbcoo, nbtype, nblist, &
                nAtoms, E_i, forCart, stat)
 #ifdef CHECK_FORCES
diff -Naru src/pytorchoutput_MPI.f90 src_modified/pytorchoutput_MPI.f90
--- src/pytorchoutput_MPI.f90	1970-01-01 09:00:00
+++ src_modified/pytorchoutput_MPI.f90	2024-09-06 10:37:30
@@ -0,0 +1,163 @@
+module pytorchoutput_MPI
+  use io,      only: io_adjustl, io_unit
+
+  implicit none
+  private
+  save
+
+  public :: pyo_write_structure_info_MPI,     &
+            pyo_write_atom_sf_info_MPI,&
+            pyo_loadandwrite       
+
+contains
+
+
+
+  !--------------------------------------------------------------------!
+  !--------------------------------------------------------------------!
+
+  subroutine pyo_write_structure_info_MPI(filename, natoms, ntypes, pyo_forces_struc,ifile)
+
+      implicit none
+  
+      integer, intent(in)          :: natoms, ntypes, pyo_forces_struc
+      character(len=*), intent(in) :: filename
+      integer,          intent(in)    :: ifile
+      integer,parameter :: pyo_unit = 1234
+
+      open(unit = pyo_unit, action = "write", status = "replace", file = 'ts.force.'//io_adjustl(ifile), form = "unformatted")    
+
+      write(pyo_unit) len_trim(filename)
+      write(pyo_unit) trim(filename)
+      write(pyo_unit) natoms, ntypes
+      write(pyo_unit) pyo_forces_struc
+      
+  end subroutine pyo_write_structure_info_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine pyo_write_atom_sf_info_MPI(itype, nnb, nsf, nblist, sfderiv_i, sfderiv_j,ifile)
+
+      implicit none
+
+      integer,                            intent(in) ::  nnb, nsf, itype
+      integer,          dimension(:),     intent(in) :: nblist
+      double precision, dimension(:,:),   intent(in) :: sfderiv_i
+      double precision, dimension(:,:,:), intent(in) :: sfderiv_j
+      integer,          intent(in)    :: ifile
+
+      double precision                               :: sfderiv_j_aux(nnb, nsf, 3), sfderiv_i_aux(nsf,3)
+
+      integer :: ineigh, isf, icoo
+      integer,parameter :: pyo_unit = 1234
+
+      !call pyo_write_init(u_pyo, trim(inp%outFileName)//".forces.tmp")
+      !call pyo_write_header_info(u_pyo, inp%nStrucs)
+      !call pyo_select_force_structures(inp%nStrucs, inp%pyo_forces_percent, struc_write_force)
+     
+
+      open(unit = pyo_unit, action = "write", file = 'ts.force.'//io_adjustl(ifile), form='unformatted', position='append')  
+
+      sfderiv_j_aux = 0.0d0
+      sfderiv_i_aux = 0.0d0
+      do ineigh = 1, nnb
+        do isf = 1, nsf
+          sfderiv_j_aux(ineigh, isf, :) = sfderiv_j(:, isf, ineigh)
+        enddo
+      enddo
+      do isf = 1, nsf
+        sfderiv_i_aux(isf,:) = sfderiv_i(:,isf)
+      enddo
+
+      write(pyo_unit) itype
+      write(pyo_unit) nsf, nnb
+      write(pyo_unit) nblist(1:nnb)
+      write(pyo_unit) sfderiv_i_aux(1:nsf,1:3)
+      write(pyo_unit) sfderiv_j_aux(1:nnb,1:nsf,1:3)
+      
+      
+  end subroutine pyo_write_atom_sf_info_MPI
+
+ 
+  subroutine pyo_loadandwrite(headfile)
+    implicit none
+    character(len=*),intent(in)::headfile
+    integer,parameter:: pyo_head = 902
+    integer::ifile
+    character(len=100)::filenameload
+    integer::l
+    integer::nAtoms,ntypes,pyo_forces_struc
+
+    integer,parameter :: pyo_unitall = 545
+    integer::nstrucs
+    integer,parameter::pyo_file = 1092
+    integer::iatom
+    integer::itype,nsf,nnb,max_nnb_trainset
+
+    double precision, allocatable,dimension(:,:):: sfderiv_i_aux
+    double precision, allocatable,dimension(:,:,:):: sfderiv_j_aux
+    integer,          allocatable,dimension(:) :: nblist
+
+    open (pyo_unitall, file='pyo.all', status='replace',form='unformatted')
+    open(unit = pyo_head,  status = "old", file = headfile, form = "unformatted")
+
+    
+
+    read(pyo_head) nstrucs
+    write(pyo_unitall) nstrucs
+
+    read(pyo_head) max_nnb_trainset
+
+    do ifile = 1, nStrucs
+      ! call pyo_write_structure_info_MPI(cooFile, nAtoms, nTypes, pyo_forces_struc,ifile)
+      open(unit = pyo_file,  status = "old", file = 'ts.force.'//io_adjustl(ifile), form = "unformatted")
+      read(pyo_file) l
+      filenameload = " "
+      l = min(l,len(filenameload))
+      read(pyo_file) filenameload(1:l)
+
+      read(pyo_file) natoms, ntypes
+      read(pyo_file) pyo_forces_struc
+
+      write(pyo_unitall) len_trim(filenameload)
+      write(pyo_unitall) trim(filenameload)
+      write(pyo_unitall) natoms, ntypes
+      write(pyo_unitall) pyo_forces_struc
+
+      atoms : do iatom = 1, nAtoms
+        if (pyo_forces_struc==1) then
+          !max_nnb_trainset = max(max_nnb_trainset, nnb)
+          !call pyo_write_atom_sf_info_MPI(itype1, nnb, stp(itype1)%nsf, nblist(:nnb), &
+          !                            sfderiv_i(1:3,1:stp(itype1)%nsf), &
+          !                            sfderiv_j(1:3,1:stp(itype1)%nsf,1:nnb) ,ifile)
+          read(pyo_file) itype
+          read(pyo_file) nsf, nnb
+          allocate(nblist(1:nnb))
+
+          read(pyo_file) nblist(1:nnb)
+          allocate(sfderiv_i_aux(1:nsf,1:3))
+          read(pyo_file) sfderiv_i_aux(1:nsf,1:3)
+          allocate(sfderiv_j_aux(1:nnb,1:nsf,1:3))
+          read(pyo_file) sfderiv_j_aux(1:nnb,1:nsf,1:3)
+
+          write(pyo_unitall) itype
+          write(pyo_unitall) nsf, nnb
+          write(pyo_unitall) nblist(1:nnb)
+          write(pyo_unitall) sfderiv_i_aux(1:nsf,1:3)
+          write(pyo_unitall) sfderiv_j_aux(1:nnb,1:nsf,1:3)
+          deallocate(nblist,sfderiv_i_aux,sfderiv_j_aux)
+        end if
+      end do atoms
+      close(pyo_file)
+    end do
+
+    
+    write(pyo_unitall) max_nnb_trainset
+
+    close(pyo_unitall)
+    close(pyo_head)
+
+
+  end subroutine
+
+end module pytorchoutput_MPI
\ No newline at end of file
diff -Naru src/sfsetup.f90 src_modified/sfsetup.f90
--- src/sfsetup.f90	2024-09-06 10:37:30
+++ src_modified/sfsetup.f90	2024-09-10 11:19:28
@@ -45,6 +45,8 @@
                       sf_add_ang,    &
                       sf_fingerprint
 
+  use KAN, only :KAN_descriptor,sfb_eval_kan
+
   implicit none
   private
   save
@@ -150,6 +152,7 @@
      double precision,       dimension(:),   allocatable :: sfval_max
      double precision,       dimension(:),   allocatable :: sfval_avg
      double precision,       dimension(:),   allocatable :: sfval_cov
+     type(KAN_descriptor) :: kan
 
   end type Setup
 
@@ -172,8 +175,14 @@
 
   type(FingerprintBasis), dimension(:), allocatable, private :: sfb
 
+  !------------------------- ChebyshevKAN basis --------------------------!
+  ! sfb(i)      structural fingerprint basis of atom type i            !
   !--------------------------------------------------------------------!
 
+  type(KAN_descriptor), dimension(:), allocatable, private :: kanb
+
+  !--------------------------------------------------------------------!
+
   logical, private :: isInit = .false.
 
   !---------------------------- constants -----------------------------!
@@ -310,8 +319,10 @@
     end if
 
     ! connect local atom type IDs with global ones
+    
     allocate(stp%gtype(stp%nenv), stp%ltype(ntypes_global))
     call stp_set_global_types(stp, ntypes_global, global_types)
+    stp%ntypes_global = ntypes_global !added
 
     stp%init = .true.
 
@@ -781,8 +792,9 @@
     integer            :: nG_max
 
     if (isInit) then
-       write(0,*) "Error: module already initialized in `stp_init'."
-       stop
+      return
+      ! write(0,*) "Error: module already initialized in `stp_init'."
+      ! stop
     end if
 
     sftype = trim(stp(1)%sftype)
@@ -801,6 +813,12 @@
        do itype = 1, ntypes
           call setup_basis_chebyshev(stp(itype), sfb(itype))
        end do
+    case('chebyshevkan')
+      write(*,*) "chebyshevkan"
+      allocate(kanb(ntypes))
+      do itype = 1, ntypes
+         call setup_basis_chebyshevKAN(stp(itype)%kan, kanb(itype))
+      end do
     case('behler2011')
        nG_max = 0
        do itype = 1, ntypes
@@ -938,6 +956,24 @@
           call sfb_eval(sfb(itype0), type0_loc, coo0, n, type1_loc, coo1, &
                         nsf, sfval(1:nsf))
        end if
+      case('chebyshevkan')
+         !write(*,*) "chebyshevkan"
+         !stop
+         !nsf = stp%nsf
+         if (do_deriv) then
+            call sfb_eval_kan(kanb(itype0),  coo0, n, type1_loc, coo1, &
+                           kanb(itype0)%nk, &
+                           sfval(1:kanb(itype0)%nk), sfderiv_i(1:3,1:kanb(itype0)%nk), &
+                           sfderiv_j(1:3,1:kanb(itype0)%nk,1:n))
+            !write(*,*) sfval
+            !stop
+         else
+            !call sfb_eval_kan(stp%kan, type0_loc, coo0, n, type1_loc, coo1, &
+            !               nsf,sfb(itype0)%multi,sfb(itype0)%typeid,sfb(itype0)%typespin,&
+            !               sfval(1:stp%kan%nk))
+            write(*,*) "do_deriv should be true. Now the false case is not supported in chebyshevkan"
+            stop
+         end if       
     case('behler2011')
        nsf = stp%nsf
        if (do_deriv) then
@@ -950,29 +986,31 @@
        end if
     end select
 
-    if (do_scale) then
-       if (do_deriv) then
-          call stp_normalize(stp, sfval, sfderiv_i, sfderiv_j, n)
-       else
-          call stp_normalize(stp, sfval)
-       end if
-    else
-       if (stp%neval == 0) then
-          stp%sfval_min(1:nsf) = sfval(1:nsf)
-          stp%sfval_max(1:nsf) = sfval(1:nsf)
-          stp%sfval_avg(1:nsf) = sfval(1:nsf)
-          stp%sfval_cov(1:nsf) = sfval(1:nsf)*sfval(1:nsf)
-       else
-          do i = 1, stp%nsf
-             stp%sfval_min(i) = min(stp%sfval_min(i), sfval(i))
-             stp%sfval_max(i) = max(stp%sfval_max(i), sfval(i))
-             stp%sfval_avg(i) = (dble(stp%neval)*stp%sfval_avg(i) &
-                                + sfval(i))/(dble(stp%neval+1))
-             stp%sfval_cov(i) = (dble(stp%neval)*stp%sfval_cov(i) &
-                                + sfval(i)*sfval(i))/(dble(stp%neval+1))
-          end do
-       end if
-    end if
+    if (trim(io_lower(stp%sftype)) .ne. "chebyshevkan") then
+      if (do_scale) then
+         if (do_deriv) then
+            call stp_normalize(stp, sfval, sfderiv_i, sfderiv_j, n)
+         else
+            call stp_normalize(stp, sfval)
+         end if
+      else
+         if (stp%neval == 0) then
+            stp%sfval_min(1:nsf) = sfval(1:nsf)
+            stp%sfval_max(1:nsf) = sfval(1:nsf)
+            stp%sfval_avg(1:nsf) = sfval(1:nsf)
+            stp%sfval_cov(1:nsf) = sfval(1:nsf)*sfval(1:nsf)
+         else
+            do i = 1, stp%nsf
+               stp%sfval_min(i) = min(stp%sfval_min(i), sfval(i))
+               stp%sfval_max(i) = max(stp%sfval_max(i), sfval(i))
+               stp%sfval_avg(i) = (dble(stp%neval)*stp%sfval_avg(i) &
+                                 + sfval(i))/(dble(stp%neval+1))
+               stp%sfval_cov(i) = (dble(stp%neval)*stp%sfval_cov(i) &
+                                 + sfval(i)*sfval(i))/(dble(stp%neval+1))
+            end do
+         end if
+      end if
+   end if
 
     stp%neval = stp%neval + 1
 
@@ -1177,6 +1215,16 @@
     sfb = new_SFBasis(stp%nenv, stp%envtypes, r_N, a_N, r_Rc, a_Rc)
 
   end subroutine setup_basis_chebyshev
+
+  subroutine setup_basis_chebyshevKAN(kan_in, kan_out)
+   implicit none
+
+   type(KAN_descriptor),            intent(in)  :: kan_in
+   type(KAN_descriptor), intent(out) :: kan_out
+
+   kan_out = KAN_descriptor(kan_in)
+
+ end subroutine setup_basis_chebyshevKAN
 
   !--------------------------------------------------------------------!
 
diff -Naru src/sub_generate.f90 src_modified/sub_generate.f90
--- src/sub_generate.f90	1970-01-01 09:00:00
+++ src_modified/sub_generate.f90	2024-09-06 10:37:30
@@ -0,0 +1,568 @@
+module aenet_generate 
+   use aenet_trainbin2ascii,only:trainbin2ascii_subroutine
+implicit none
+contains 
+
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2019 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!+ ---------------------------------------------------------------------
+!+ If you make use of AENET for your publication, please cite:
+!+ [1] N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.
+!+ [2] J. Behler and M. Parrinello, Phys. Rev. Lett. 98 (2007) 146401.
+!+
+!+ If you used the Chebyshev descriptor, please cite:
+!+ [3] N. Artrith, A. Urban, and G. Ceder, PRB 96 (2017) 014112.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+subroutine generate_subroutine(inFile,ionum)
+
+    use aeio,     only: aeio_readline,        &
+                        aeio_header,          &
+                        aeio_timestamp,       &
+                        aeio_print_copyright, &
+                        PATHLEN, LINELEN
+  
+    use geometry, only: geo_init,          &
+                        geo_final,         &
+                        geo_itype_of_name, &
+                        geo_type_conv,     &
+                        pbc,               &
+                        latticeVec,        &
+                        nAtoms,            &
+                        nTypes,            &
+                        atomType,          &
+                        atomTypeName,      &
+                        cooLatt,           &
+                        cooCart,           &
+                        forCart,           &
+                        hasEnergy,         &
+                        hasForces,         &
+                        cohesiveEnergy,    &
+                        totalEnergy
+  
+    use input,    only: InputData,         &
+                        read_InpGenerate,  &
+                        del_InputData
+  
+    use io,       only: io_adjustl,        &
+                        io_center,         &
+                        io_lower,          &
+                        io_readnext,       &
+                        io_unit
+  
+    use lclist,   only: lcl_init,          &
+                        lcl_final,         &
+                        lcl_print_info,    &
+                        lcl_nmax_nbdist,   &
+                        lcl_nbdist_cart
+  
+    use sfsetup,  only: Setup,                 &
+                        read_Setup_parameters, &
+                        save_Setup,            &
+                        del_Setup,             &
+                        stp_init,              &
+                        stp_final,             &
+                        stp_get_range,         &
+                        stp_print_info,        &
+                        stp_eval,              &
+                        nsf_max
+  
+    use timing,   only: tng_init,          &
+                        tng_final,         &
+                        tng_timing,        &
+                        tng_timing2,       &
+                        tng_timing3,       &
+                        tng_dump
+  
+    use trainset, only: TrnSet,                 &
+                        new_TrnSet,             &
+                        close_TrnSet,           &
+                        ts_print_info,          &
+                        ts_write_header,        &
+                        ts_write_sf_info,       &
+                        ts_write_atom_info,     &
+                        ts_write_structure_info
+  
+    use pytorchoutput, only: pyo_write_init,               &
+                             pyo_write_final,              &
+                             pyo_write_header_info,        &
+                             pyo_write_structure_info,     &
+                             pyo_write_atom_sf_info,       &
+                             pyo_select_force_structures!, &
+  
+    implicit none
+  
+    !--------------------------------------------------------------------!
+    ! stp(i)         structural fingerprint basis setup for atom type i  !
+    ! r_min, r_max   lower and upper bound for atomic interactions       !
+    ! ts             training set reference                              !
+    !                                                                    !
+    ! nnb_max, nnb   max. and actual number of neighboring atoms         !
+    ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
+    !                neighboring atom                                    !
+    ! nbdist(i)      distance of the i-th neighbor                       !
+    !                                                                    !
+    ! sfval(i)         value of the i-th basis function                  !
+    ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
+    !                  with respect to the central atom                  !
+    !                  sfderiv_i(3,nsf_max)                              !
+    ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
+    !                  with respect to the coordinates of atom k         !
+    !                  sfderiv_j(3,nsf_max,nnb_max)                      !
+    !                                                                    !
+    ! E_coh          cohesive energy                                     !
+    ! nFiles_inv     = 1/inp%nStrucs                                     !
+    !                                                                    !
+    ! inFile         name of the input file for the generate.x program   !
+    ! cooFile        name of the currently active structure file         !
+    ! keyword        the last keyword read from the input file           !
+    !                                                                    !
+    ! do_debug       if .true., additional files containing debugging    !
+    !                info will be created                                !
+    !                                                                    !
+    ! u_*            file units                                          !
+    !--------------------------------------------------------------------!
+  
+    type(InputData)                                :: inp
+  
+    type(Setup),       dimension(:),   allocatable :: stp
+    double precision                               :: r_min, r_max
+    type(TrnSet)                                   :: ts
+  
+    integer                                        :: nnb_max, nnb
+    double precision,  dimension(:,:), allocatable :: nbcoo
+    double precision,  dimension(:),   allocatable :: nbdist
+    integer,  dimension(:),   allocatable :: nblist
+    integer,           dimension(:),   allocatable :: nbtype
+  
+    double precision, dimension(:),     allocatable :: sfval
+    double precision, dimension(:,:),   allocatable :: sfderiv_i
+    double precision, dimension(:,:,:), allocatable :: sfderiv_j
+  
+    double precision                               :: E_coh
+    integer                                        :: ifile
+    double precision                               :: nFiles_inv
+
+    character(len=*),intent(in)                    :: inFile
+    integer,intent(in)                             :: ionum
+  
+    !character(len=PATHLEN)                         :: inFile
+    character(len=PATHLEN)                         :: cooFile
+    character(len=LINELEN)                         :: keyword
+  
+    integer                                        :: itype1
+    integer                                        :: itype, iatom
+  
+    integer                                        :: iline
+    character(len=1024)                            :: line
+  
+    integer                                        :: u_in, u_tng
+    logical                                        :: do_debug = .false.
+    integer                                        :: u_dbg, idbg
+  
+    integer                                        :: u_pyo, max_nnb_trainset, pyo_forces_struc
+    integer, allocatable                           :: struc_write_force(:)
+  
+    integer :: i
+  
+    ! timing registers
+    integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
+
+    character(len=1024)::outfilename_ascii
+    character(len=1024)::outFileName
+    logical ::to_bin,to_ascii
+  
+    !-------------------------- initialization --------------------------!
+  
+    !call initialize(inFile)
+  
+    inp = read_InpGenerate(inFile)
+    allocate(stp(inp%nTypes))
+    call load_symmfunc_setups(inp, stp)
+  
+    ! call parse_input(inFile)
+  
+    if (inp%do_timing) then
+       u_tng = io_unit()
+       call tng_init(unit=u_tng, file='generate.time', registers=3)
+       write(ionum,*) 'Timing info will be written to: ', 'generate.time'
+       write(ionum,*)
+    end if
+    if (do_debug) then
+       u_dbg = io_unit()
+       open(u_dbg, file='generate.debug', status='replace', action='write')
+    end if
+  
+    ! get interaction range and max. number of atoms within range
+    call stp_get_range(inp%nTypes, stp, r_min, r_max)
+    nnb_max = lcl_nmax_nbdist(r_min, r_max)
+    allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nblist(nnb_max),nbtype(nnb_max))
+  
+    ! initialize workspace for structural fingerprint basis:
+    call stp_init(inp%nTypes, stp, nnb_max)
+    if (inp%do_timing) call tng_timing('Structural fingerprint basis initialized.')
+  
+    ! allocate workspace for basis function evaluation:
+    allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
+    sfval(:) = 0.0d0
+    sfderiv_i(:,:) = 0.0d0
+    sfderiv_j(:,:,:) = 0.0d0
+  
+    call aeio_header('Generation of training set started')
+    write(ionum,*)
+  
+    write(ionum,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
+    write(*,'(1x,"types                 : ")', advance='no')
+    do itype = 1, inp%nTypes
+       if (mod(itype,7) == 0) write(*,'(29x)')
+       write(*,'(A5,1x)', advance='no') inp%typeName(itype)
+    end do
+    write(ionum,*)
+    write(ionum,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
+    write(ionum,*)
+  
+    !-------------- write basis function settings to stdout -------------!
+  
+    call aeio_header("Structural fingerprint basis set-up")
+    write(ionum,*)
+  
+    do itype1 = 1, inp%nTypes
+       !call stp_print_info(stp(itype1))
+    end do
+  
+    !----------- write training set header to the output file -----------!
+  
+    ts = new_TrnSet(inp%nTypes, inp%typeName, inp%atomicEnergy, &
+                    inp%nStrucs, trim(inp%outFileName))
+
+    outfilename_ascii = trim(inp%outFileName)//'.ascii'                    
+  
+    if (inp%do_timing) call tng_timing('Training set file started.')
+  
+    !--------------- write pytorch force training header ----------------!
+    
+    if (inp%pyo_forces) then
+      u_pyo = io_unit()
+      call pyo_write_init(u_pyo, trim(inp%outFileName)//".forces")
+      call pyo_write_header_info(u_pyo, inp%nStrucs)
+      call pyo_select_force_structures(inp%nStrucs, inp%pyo_forces_percent, struc_write_force)
+      max_nnb_trainset = 0
+    endif
+  
+    !------------------ iterate over coordinates files ------------------!
+  
+    call aeio_header("Adding structures to the training set")
+    write(ionum,*)
+  
+    u_in = io_unit()
+    open(u_in, file=inFile, status='old', action='read')
+    rewind(u_in)
+  
+    iline = 0
+    do
+       ! forward until the FILES keyword:
+       call aeio_readline(u_in, iline, line)
+       read(line,*) keyword
+       if (trim(keyword) == 'FILES') then
+          read(u_in,*)
+          exit
+       end if
+    end do
+  
+    ! header for stdout
+    write(*,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
+         'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
+  
+    nFiles_inv = 1.0d0/dble(inp%nStrucs)
+    structures : do ifile = 1, inp%nStrucs
+  
+       if (inp%do_timing) call tng_timing('Structure: '// io_adjustl(ifile))
+  
+       call aeio_readline(u_in, iline, line)
+       cooFile = trim(line)
+  
+       call geo_init(cooFile, 'xsf')
+       if (inp%do_timing) call tng_timing3(register=R_GEO)
+       if (.not. (hasForces .and. hasEnergy)) then
+          write(0,*) ">>>", hasForces, hasEnergy
+          write(0,*) "Error: incomplete output data in : ", trim(cooFile)
+          call finalize()
+          stop
+       end if
+  
+       if (nTypes > inp%nTypes) then
+          write(ionum,*) 'Skipping ', trim(adjustl(cooFile)), &
+                     ': too many atomic species'
+          call geo_final()
+          cycle structures
+       end if
+  
+       if (abs(cohesiveEnergy) /= 0.0d0) then
+          E_coh = cohesiveEnergy
+       else
+          ! if only the total energy is available, we have to calculate
+          ! the cohesive energy at this point
+          E_coh = totalEnergy
+          do iatom = 1, nAtoms
+             itype1 = atomType(iatom)
+             itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                    inp%nTypes, inp%typeName)
+             E_coh = E_coh - inp%atomicEnergy(itype1)
+          end do
+       end if
+  
+       write(*,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
+            ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
+            trim(adjustl(cooFile))
+  
+       call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
+       if (inp%do_timing) call tng_timing3(register=R_NBL)
+  
+       ! write structure info (atoms, types, energy) to training set file:
+       call ts_write_structure_info(ts, cooFile, nAtoms, nTypes, E_coh)
+       
+       ! write structure info (atoms, types) to pytorch forces file:
+       if (inp%pyo_forces) then
+         pyo_forces_struc = struc_write_force(ifile)
+         call pyo_write_structure_info(u_pyo, cooFile, nAtoms, nTypes, pyo_forces_struc)
+       end if
+  
+       atoms : do iatom = 1, nAtoms
+  
+          ! determine the training atom type of atom `iatom' in global
+          ! index terms
+          itype1 = atomType(iatom)
+          itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                 inp%nTypes, inp%typeName)
+  
+          ! assert that atom type is included in the set-ups:
+          if (itype1 == 0) then
+             write(0,*) "Error: not a valid structure    : ", trim(cooFile)
+             write(0,*) "       Additional species found."
+             call finalize()
+             stop
+          end if
+  
+          ! write atom info (species, forces) to training set file:
+          call ts_write_atom_info(ts, itype1, cooCart(iatom), forCart(iatom))
+  
+          ! get all atoms within cut-off:
+          nnb = nnb_max
+          call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nblist=nblist, nbtype=nbtype)
+  
+          if (inp%do_timing) call tng_timing3(register=R_NBL)
+          !write(*,'(1x,I6,2x,A2,2x,I6)') &
+          !     iatom, trim(atomTypeName(atomType(iatom))), nnb
+  
+          ! convert atom types to global index:
+          do i = 1, nnb
+             nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
+                                      inp%nTypes, inp%typeName)
+             if (nbtype(i) == 0) then
+                write(0,*) "Error: atom type not found in setup."
+                call finalize()
+                stop
+             end if
+          end do
+  
+          ! evaluate the structural fingerprint basis function set-up:
+          call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
+                        stp(itype1), sfval=sfval, sfderiv_i=sfderiv_i, &
+                        sfderiv_j=sfderiv_j)
+  
+          if (do_debug) then
+             do idbg = 1, stp(itype1)%nsf
+                write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
+             end do
+             write(u_dbg,*)
+          end if
+  
+          if (inp%do_timing) call tng_timing3(register=R_SF)
+  
+          ! write basis function values and derivatives
+          ! to the training set file:
+          call ts_write_sf_info(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf))
+  
+          ! write basis function derivatives and neighbor list to pytorch output
+          if (inp%pyo_forces .and. pyo_forces_struc==1) then
+            max_nnb_trainset = max(max_nnb_trainset, nnb)
+            call pyo_write_atom_sf_info(u_pyo, itype1, nnb, stp(itype1)%nsf, nblist(:nnb), &
+                                        sfderiv_i(1:3,1:stp(itype1)%nsf), &
+                                        sfderiv_j(1:3,1:stp(itype1)%nsf,1:nnb) )
+          end if
+  
+       end do atoms
+  
+       if (inp%do_timing) then
+          call tng_dump(R_GEO, 'time spent reading geometries (so far)')
+          call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
+          call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
+       end if
+  
+       call lcl_final()
+       call geo_final()
+  
+    end do structures
+    write(ionum,*)
+  
+    if (inp%do_timing) then
+       call tng_timing('Loop over structures done.')
+       call tng_dump(R_GEO, 'total time spent reading geometries')
+       call tng_dump(R_NBL, 'total time spent in the neighbor list')
+       call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
+    end if
+  
+    !--------- save basis function setups with final statistics ---------!
+  
+    call ts_print_info(ts)
+  
+    !----------------------------- finalize -----------------------------!
+  
+    deallocate(nbcoo, nbdist, nblist, nbtype)
+    close(u_in)
+    
+    if (inp%pyo_forces) then
+      call pyo_write_final(u_pyo, max_nnb_trainset)
+    end if
+
+    to_bin = .false.
+    to_ascii = .true.
+    outFileName = inp%outFileName
+
+    call close_TrnSet(ts, stp=stp(1:inp%nTypes))
+    call finalize()
+
+    call trainbin2ascii_subroutine(trim(outFileName), trim(outfilename_ascii),to_bin, to_ascii)
+  
+  
+  
+  contains !=============================================================!
+  
+  
+    subroutine initialize(inFile)
+  
+      implicit none
+  
+      character(len=*), intent(out) :: inFile
+  
+      integer :: nargs
+      logical :: fexists
+  
+      call aeio_header("generate.x - training set generation", char='=')
+      write(ionum,*)
+  
+      call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+  
+      nargs = command_argument_count()
+      if (nargs < 1) then
+         write(0,*) "Error: No input file provided."
+         call print_usage()
+         call finalize()
+         stop
+      end if
+  
+      call get_command_argument(1, value=inFile)
+      inquire(file=trim(inFile), exist=fexists)
+      if (.not. fexists) then
+         write(0,*) "Error: File not found: ", trim(inFile)
+         call print_usage()
+         call finalize()
+         stop
+      end if
+  
+    end subroutine initialize
+  
+    !--------------------------------------------------------------------!
+  
+    subroutine finalize()
+  
+      implicit none
+  
+      integer :: itype
+  
+      if (allocated(sfval)) then
+         deallocate(sfval, sfderiv_i, sfderiv_j)
+      end if
+  
+      if (allocated(stp)) then
+         call stp_final(inp%nTypes, stp)
+         do itype = 1, inp%nTypes
+            call del_Setup(stp(itype))
+         end do
+         deallocate(stp, inp%typeName, inp%atomicEnergy)
+      end if
+  
+      if (ts%init) call close_TrnSet(ts)
+  
+      if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
+  
+      if (inp%do_timing) call tng_final()
+      if (do_debug)  close(u_dbg)
+  
+      call aeio_header(aeio_timestamp(), char=' ')
+      call aeio_header("Training set generation done.", char='=')
+  
+    end subroutine finalize
+  
+    !--------------------------------------------------------------------!
+  
+    subroutine print_usage()
+  
+      implicit none
+  
+      write(ionum,*)
+      write(ionum,*) "generate.x -- Generate training sets for use with `train.x'"
+      write(*,'(1x,70("-"))')
+      write(ionum,*) 'Usage: generate.x <input-file>'
+      write(ionum,*)
+      write(ionum,*) 'See the documentation or the source code for a description of the '
+      write(ionum,*) 'input file format.'
+      write(ionum,*)
+  
+    end subroutine print_usage
+  
+    !--------------------------------------------------------------------!
+  
+    subroutine load_symmfunc_setups(inp, stp)
+  
+      implicit none
+  
+      type(InputData),           intent(in)  :: inp
+      type(Setup), dimension(:), intent(out) :: stp
+  
+      integer :: i
+  
+      do i = 1, inp%nTypes
+         stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
+         if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
+            write(0,*) "Error: Inconsistent atom type in setup:"
+            write(0,*) "       type expected : ", trim(inp%typeName(i))
+            write(0,*) "       type found    : ", trim(stp(i)%atomtype)
+            call finalize()
+            stop
+         end if
+      end do
+  
+    end subroutine load_symmfunc_setups
+  
+   end subroutine generate_subroutine
+
+
+
+ 
+end module
\ No newline at end of file
diff -Naru src/sub_generate_MPI.f90 src_modified/sub_generate_MPI.f90
--- src/sub_generate_MPI.f90	1970-01-01 09:00:00
+++ src_modified/sub_generate_MPI.f90	2024-09-06 10:37:30
@@ -0,0 +1,723 @@
+module aenet_generate_MPI 
+   use aenet_trainbin2ascii,only:trainbin2ascii_subroutine
+implicit none
+contains 
+
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2019 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!+ ---------------------------------------------------------------------
+!+ If you make use of AENET for your publication, please cite:
+!+ [1] N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.
+!+ [2] J. Behler and M. Parrinello, Phys. Rev. Lett. 98 (2007) 146401.
+!+
+!+ If you used the Chebyshev descriptor, please cite:
+!+ [3] N. Artrith, A. Urban, and G. Ceder, PRB 96 (2017) 014112.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+subroutine generate_subroutine_MPI(inFile,ionum)
+
+    use aeio,     only: aeio_readline,        &
+                        aeio_header,          &
+                        aeio_timestamp,       &
+                        aeio_print_copyright, &
+                        PATHLEN, LINELEN
+  
+    use geometry, only: geo_init,          &
+                        geo_final,         &
+                        geo_itype_of_name, &
+                        geo_type_conv,     &
+                        pbc,               &
+                        latticeVec,        &
+                        nAtoms,            &
+                        nTypes,            &
+                        atomType,          &
+                        atomTypeName,      &
+                        cooLatt,           &
+                        cooCart,           &
+                        forCart,           &
+                        hasEnergy,         &
+                        hasForces,         &
+                        cohesiveEnergy,    &
+                        totalEnergy
+  
+    use input,    only: InputData,         &
+                        read_InpGenerate,  &
+                        del_InputData
+  
+    use io,       only: io_adjustl,        &
+                        io_center,         &
+                        io_lower,          &
+                        io_readnext,       &
+                        io_unit
+  
+    use lclist,   only: lcl_init,          &
+                        lcl_final,         &
+                        lcl_print_info,    &
+                        lcl_nmax_nbdist,   &
+                        lcl_nbdist_cart
+  
+    use sfsetup,  only: Setup,                 &
+                        read_Setup_parameters, &
+                        save_Setup,            &
+                        del_Setup,             &
+                        stp_init,              &
+                        stp_final,             &
+                        stp_get_range,         &
+                        stp_print_info,        &
+                        stp_eval,              &
+                        nsf_max
+  
+    use timing,   only: tng_init,          &
+                        tng_final,         &
+                        tng_timing,        &
+                        tng_timing2,       &
+                        tng_timing3,       &
+                        tng_dump
+  
+    use trainset, only: TrnSet,                 &
+                        new_TrnSet,             &
+                        close_TrnSet,           &
+                        ts_print_info,          &
+                        ts_write_header,        &
+                        ts_write_sf_info,       &
+                        ts_write_atom_info,     &
+                        ts_write_structure_info
+  
+    use pytorchoutput, only: pyo_write_init,               &
+                             pyo_write_final,              &
+                             pyo_write_header_info,        &
+                             pyo_write_structure_info,     &
+                             pyo_write_atom_sf_info,       &
+                             pyo_select_force_structures!, &
+   use pytorchoutput_MPI, only: pyo_write_structure_info_MPI,     &
+                             pyo_write_atom_sf_info_MPI,&
+                             pyo_loadandwrite
+
+    use trainset_MPI, only: new_TrnSet_MPI,             &
+                             close_TrnSet_MPI,           &
+                             ts_write_header_MPI,        &
+                             ts_write_sf_info_MPI,       &
+                             ts_write_atom_info_MPI,     &
+                             ts_write_structure_info_MPI,&
+                             ts_parallel_footer_MPI,&
+                             ts_loadandwrite_structure_info_MPI
+
+    use parallel,    only: pp_init,                &
+                         pp_final,               &
+                         pp_bcast,               &
+                         pp_barrier,             &
+                         ppMaster,               &
+                         ppRank,                 &
+                         ppSize,                 &
+                         pp_bcast_InputData,     &
+                         pp_bcast_Setup                             
+  
+    implicit none
+  
+    !--------------------------------------------------------------------!
+    ! stp(i)         structural fingerprint basis setup for atom type i  !
+    ! r_min, r_max   lower and upper bound for atomic interactions       !
+    ! ts             training set reference                              !
+    !                                                                    !
+    ! nnb_max, nnb   max. and actual number of neighboring atoms         !
+    ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
+    !                neighboring atom                                    !
+    ! nbdist(i)      distance of the i-th neighbor                       !
+    !                                                                    !
+    ! sfval(i)         value of the i-th basis function                  !
+    ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
+    !                  with respect to the central atom                  !
+    !                  sfderiv_i(3,nsf_max)                              !
+    ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
+    !                  with respect to the coordinates of atom k         !
+    !                  sfderiv_j(3,nsf_max,nnb_max)                      !
+    !                                                                    !
+    ! E_coh          cohesive energy                                     !
+    ! nFiles_inv     = 1/inp%nStrucs                                     !
+    !                                                                    !
+    ! inFile         name of the input file for the generate.x program   !
+    ! cooFile        name of the currently active structure file         !
+    ! keyword        the last keyword read from the input file           !
+    !                                                                    !
+    ! do_debug       if .true., additional files containing debugging    !
+    !                info will be created                                !
+    !                                                                    !
+    ! u_*            file units                                          !
+    !--------------------------------------------------------------------!
+  
+    type(InputData)                                :: inp
+  
+    type(Setup),       dimension(:),   allocatable :: stp
+    double precision                               :: r_min, r_max
+    type(TrnSet)                                   :: ts
+  
+    integer                                        :: nnb_max, nnb
+    double precision,  dimension(:,:), allocatable :: nbcoo
+    double precision,  dimension(:),   allocatable :: nbdist
+    integer,  dimension(:),   allocatable :: nblist
+    integer,           dimension(:),   allocatable :: nbtype
+  
+    double precision, dimension(:),     allocatable :: sfval
+    double precision, dimension(:,:),   allocatable :: sfderiv_i
+    double precision, dimension(:,:,:), allocatable :: sfderiv_j
+  
+    double precision                               :: E_coh
+    integer                                        :: ifile
+    double precision                               :: nFiles_inv
+
+    character(len=*),intent(in)                    :: inFile
+    integer,intent(in)                             :: ionum
+  
+    !character(len=PATHLEN)                         :: inFile
+    character(len=PATHLEN)                         :: cooFile
+    character(len=LINELEN)                         :: keyword
+  
+    integer                                        :: itype1
+    integer                                        :: itype, iatom
+  
+    integer                                        :: iline
+    character(len=1024)                            :: line
+  
+    integer                                        :: u_in, u_tng
+    logical                                        :: do_debug = .false.
+    integer                                        :: u_dbg, idbg
+  
+    integer                                        :: u_pyo, max_nnb_trainset, pyo_forces_struc
+    integer, allocatable                           :: struc_write_force(:)
+  
+  
+    integer :: i, j, l
+    logical :: lexist
+    ! timing registers
+    integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
+
+    character(len=1024)::outfilename_ascii
+    character(len=1024)::outFileName
+    logical ::to_bin,to_ascii
+
+    logical :: stopnow
+    character(len=262144)                           :: longline
+  
+    integer rename, status
+    integer::N_do_forces
+  
+  !-------------------------- initialization --------------------------!
+
+    if (ppMaster) then
+      call system( 'rm -f ts.* 2> /dev/null' )
+    end if
+ 
+    call initialize_MPI()
+  
+    if (ppMaster) inp = read_InpGenerate(inFile)
+    call pp_bcast_InputData(inp)
+
+    allocate(stp(inp%nTypes))
+    call load_symmfunc_setups_MPI(inp, stp)
+  
+    ! call parse_input(inFile)
+  
+    if (inp%do_timing .and. ppMaster) then
+       u_tng = io_unit()
+       call tng_init(unit=u_tng, file='generate.time', registers=3)
+       write(ionum,*) 'Timing info will be written to: ', 'generate.time'
+       write(ionum,*)
+    end if
+    if (do_debug .and. ppMaster) then
+       u_dbg = io_unit()
+       open(u_dbg, file='generate.debug', status='replace', action='write')
+    end if
+  
+    ! get interaction range and max. number of atoms within range
+    call stp_get_range(inp%nTypes, stp, r_min, r_max)
+    nnb_max = lcl_nmax_nbdist(r_min, r_max)
+    allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nblist(nnb_max),nbtype(nnb_max))
+  
+    ! initialize workspace for structural fingerprint basis:
+    call stp_init(inp%nTypes, stp, nnb_max)
+    if (inp%do_timing) call tng_timing('Structural fingerprint basis initialized.')
+  
+    ! allocate workspace for basis function evaluation:
+    allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
+    sfval(:) = 0.0d0
+    sfderiv_i(:,:) = 0.0d0
+    sfderiv_j(:,:,:) = 0.0d0
+
+    if (ppMaster) then
+      call aeio_header('Generation of training set started')
+      write(ionum,*)
+   
+      write(ionum,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
+      write(*,'(1x,"types                 : ")', advance='no')
+      do itype = 1, inp%nTypes
+         if (mod(itype,7) == 0) write(*,'(29x)')
+         write(*,'(A5,1x)', advance='no') inp%typeName(itype)
+      end do
+      write(ionum,*)
+      write(ionum,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
+      write(ionum,*)
+    end if
+  
+    !-------------- write basis function settings to stdout -------------!
+    if (ppMaster) then
+      call aeio_header("Structural fingerprint basis set-up")
+      write(ionum,*)
+  
+      do itype1 = 1, inp%nTypes
+       call stp_print_info(stp(itype1))
+      end do
+   end if
+  
+    !----------- write training set header to the output file -----------!
+  
+    ts = new_TrnSet_MPI(inp%nTypes, inp%typeName, inp%atomicEnergy, &
+                    inp%nStrucs, trim(inp%outFileName))
+
+    outfilename_ascii = trim(inp%outFileName)//'.ascii'                    
+  
+    if (inp%do_timing .and. ppMaster) call tng_timing('Training set file started.')
+  
+    !--------------- write pytorch force training header ----------------!
+
+    call pp_barrier()
+
+    if (inp%pyo_forces) then
+      u_pyo = io_unit()
+      if (ppMaster) then
+         !call pyo_write_init(u_pyo, trim(inp%outFileName)//".forces.tmp")
+         call pyo_write_init(u_pyo, "ts.forces.tmp")
+         call pyo_write_header_info(u_pyo, inp%nStrucs)
+         call pyo_select_force_structures(inp%nStrucs, inp%pyo_forces_percent, struc_write_force)
+         N_do_forces = ubound(struc_write_force,1)
+      end if
+      call pp_bcast(N_do_forces)
+      if (ppMaster) then
+      else
+         allocate(struc_write_force(N_do_forces))
+      end if
+      do i=1,N_do_forces
+         call pp_bcast(struc_write_force(i))
+      end do
+      max_nnb_trainset = 0
+    endif
+  
+    !------------------ iterate over coordinates files ------------------!
+  
+    if (ppMaster) then
+      call aeio_header("Adding structures to the training set")
+      write(ionum,*)
+    end if
+  
+    u_in = io_unit()
+    open(u_in, file=inFile, status='old', action='read')
+    rewind(u_in)
+  
+    iline = 0
+    do
+       ! forward until the FILES keyword:
+       call aeio_readline(u_in, iline, line)
+       read(line,*) keyword
+       if (trim(keyword) == 'FILES') then
+          read(u_in,*)
+          exit
+       end if
+    end do
+  
+    if (ppMaster) then
+    ! header for stdout
+      write(*,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
+            'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
+   
+    end if
+
+    stopnow = .false.
+
+    call pp_barrier()
+
+
+
+    nFiles_inv = 1.0d0/dble(inp%nStrucs)
+    structures : do ifile = 1, inp%nStrucs
+  
+       if (inp%do_timing .and. ppMaster) call tng_timing('Structure: '// io_adjustl(ifile))
+  
+       call aeio_readline(u_in, iline, line)
+       cooFile = trim(line)
+
+       if ( mod(ifile-1,ppSize) .ne. ppRank ) cycle
+  
+       call geo_init(cooFile, 'xsf')
+       if (inp%do_timing) call tng_timing3(register=R_GEO)
+       if (.not. (hasForces .and. hasEnergy)) then
+          write(0,*) ">>>", hasForces, hasEnergy
+          write(0,*) "Error: incomplete output data in : ", trim(cooFile)
+          !call finalize()
+          stop
+       end if
+  
+       if (nTypes > inp%nTypes) then
+          if (ppMaster) then
+            write(ionum,*) 'Skipping ', trim(adjustl(cooFile)), &
+                     ': too many atomic species'
+          end if
+          call geo_final()
+          cycle structures
+       end if
+  
+       if (abs(cohesiveEnergy) /= 0.0d0) then
+          E_coh = cohesiveEnergy
+       else
+          ! if only the total energy is available, we have to calculate
+          ! the cohesive energy at this point
+          E_coh = totalEnergy
+          do iatom = 1, nAtoms
+             itype1 = atomType(iatom)
+             itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                    inp%nTypes, inp%typeName)
+             E_coh = E_coh - inp%atomicEnergy(itype1)
+          end do
+       end if
+  
+       if (ppMaster) then
+         write(*,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
+            ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
+            trim(adjustl(cooFile))
+       end if
+            
+       call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
+       if (inp%do_timing .and. ppMaster) call tng_timing3(register=R_NBL)
+  
+       ! write structure info (atoms, types, energy) to training set file:
+       call ts_write_structure_info_MPI(ts, cooFile, nAtoms, nTypes, E_coh,ifile)
+       
+       ! write structure info (atoms, types) to pytorch forces file:
+       if (inp%pyo_forces ) then
+         pyo_forces_struc = struc_write_force(ifile)
+         call pyo_write_structure_info_MPI(cooFile, nAtoms, nTypes, pyo_forces_struc,ifile)
+       end if
+  
+       atoms : do iatom = 1, nAtoms
+  
+          ! determine the training atom type of atom `iatom' in global
+          ! index terms
+          itype1 = atomType(iatom)
+          itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                 inp%nTypes, inp%typeName)
+  
+          ! assert that atom type is included in the set-ups:
+          if (itype1 == 0) then
+             write(0,*) "Error: not a valid structure    : ", trim(cooFile)
+             write(0,*) "       Additional species found."
+             !call finalize()
+             stop
+          end if
+  
+          ! write atom info (species, forces) to training set file:
+          call ts_write_atom_info_MPI(ts, itype1, cooCart(iatom), forCart(iatom),ifile)
+  
+          ! get all atoms within cut-off:
+          nnb = nnb_max
+          call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nblist=nblist, nbtype=nbtype)
+  
+          if (inp%do_timing .and. ppMaster) call tng_timing3(register=R_NBL)
+          !write(*,'(1x,I6,2x,A2,2x,I6)') &
+          !     iatom, trim(atomTypeName(atomType(iatom))), nnb
+  
+          ! convert atom types to global index:
+          do i = 1, nnb
+             nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
+                                      inp%nTypes, inp%typeName)
+             if (nbtype(i) == 0) then
+                write(0,*) "Error: atom type not found in setup."
+                call finalize_MPI()
+                stop
+             end if
+          end do
+  
+          ! evaluate the structural fingerprint basis function set-up:
+          call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
+                        stp(itype1), sfval=sfval, sfderiv_i=sfderiv_i, &
+                        sfderiv_j=sfderiv_j)
+  
+          if (do_debug .and. ppMaster) then
+             do idbg = 1, stp(itype1)%nsf
+                write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
+             end do
+             write(u_dbg,*)
+          end if
+  
+          if (inp%do_timing) call tng_timing3(register=R_SF)
+  
+          ! write basis function values and derivatives
+          ! to the training set file:
+          call ts_write_sf_info_MPI(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf),ifile)
+  
+          ! write basis function derivatives and neighbor list to pytorch output
+          if (inp%pyo_forces .and. pyo_forces_struc==1) then
+            max_nnb_trainset = max(max_nnb_trainset, nnb)
+            call pyo_write_atom_sf_info_MPI(itype1, nnb, stp(itype1)%nsf, nblist(:nnb), &
+                                        sfderiv_i(1:3,1:stp(itype1)%nsf), &
+                                        sfderiv_j(1:3,1:stp(itype1)%nsf,1:nnb) ,ifile)
+          end if
+  
+       end do atoms
+  
+       if (inp%do_timing) then
+          call tng_dump(R_GEO, 'time spent reading geometries (so far)')
+          call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
+          call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
+       end if
+  
+       call lcl_final()
+       call geo_final()
+  
+    end do structures
+    if (ppMaster) write(ionum,*)
+  
+    if (inp%do_timing) then
+       call tng_timing('Loop over structures done.')
+       call tng_dump(R_GEO, 'total time spent reading geometries')
+       call tng_dump(R_NBL, 'total time spent in the neighbor list')
+       call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
+    end if
+  
+    !--------- save basis function setups with final statistics ---------!
+  
+    if (ppMaster) call ts_print_info(ts)
+  
+    !----------------------------- finalize -----------------------------!
+  
+    deallocate(nbcoo, nbdist, nblist, nbtype)
+    close(u_in)
+    
+    if (inp%pyo_forces .and. ppMaster) then
+      call pyo_write_final(u_pyo, max_nnb_trainset)
+    end if
+
+
+    call pp_barrier()
+
+    if (ppMaster) then
+     do ifile = 1, inp%nStrucs
+        call ts_loadandwrite_structure_info_MPI(ifile)
+     end do
+    end if
+  
+    call ts_parallel_footer_MPI(ts, stp)
+
+    if (inp%pyo_forces .and. ppMaster) then
+      call pyo_loadandwrite("ts.forces.tmp")
+      !call pyo_loadandwrite(trim(inp%outFileName)//".forces.tmp")
+    end if
+
+
+
+    call close_TrnSet_MPI(ts, stp=stp(1:inp%nTypes))
+
+
+    l = 5000
+    call pp_barrier()
+    if (ppMaster) then
+     status = rename( "ts.all",adjustl(trim(inp%outFileName))) !rename the file
+        do ifile = 1, inp%nStrucs
+           open(10001, file='ts.'//io_adjustl(ifile))
+           close(10001, status="delete")
+        end do
+    end if
+
+    if (inp%pyo_forces .and. ppMaster) then
+      status = rename( "pyo.all",trim(inp%outFileName)//".forces") !rename the file
+      do ifile = 1, inp%nStrucs
+         open(10001, file='ts.force.'//io_adjustl(ifile))
+         close(10001, status="delete")
+      end do
+    end if
+  
+    call pp_barrier()
+    call finalize_MPI()
+
+
+    to_bin = .false.
+    to_ascii = .true.
+    outFileName = inp%outFileName
+    call trainbin2ascii_subroutine(trim(outFileName), trim(outfilename_ascii),to_bin, to_ascii)
+  
+
+    return
+
+    call finalize()
+
+
+  
+  contains !=============================================================!
+  
+  
+  subroutine initialize_MPI()
+
+    implicit none
+
+!    character(len=*), intent(out) :: inFile
+
+    integer :: nargs
+    logical :: fexists
+    logical :: stopnow
+
+    call pp_init()
+
+!    stopnow = .false.
+
+    if (ppMaster) then
+
+       call aeio_header("generate.x - training set generation", char='=')
+       write(ionum,*)
+
+       call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+
+!       nargs = command_argument_count()
+!       if (nargs < 1) then
+!          write(0,*) "Error: No input file provided."
+!          call print_usage()
+!          stopnow = .true.
+!       end if
+
+!       call get_command_argument(1, value=inFile)
+!       inquire(file=trim(inFile), exist=fexists)
+!       if (.not. fexists) then
+!          write(0,*) "Error: File not found: ", trim(inFile)
+!          stopnow = .true.
+!       end if
+
+   end if
+!   stopnow = .true.
+
+!    call pp_bcast(stopnow)
+!    if (stopnow) then
+!       call finalize_MPI()
+!       stop
+!    end if
+
+   ! call pp_bcast(inFile)
+
+  end subroutine initialize_MPI
+
+    !--------------------------------------------------------------------!
+  
+  subroutine finalize_MPI()
+
+    implicit none
+
+    integer :: itype
+
+    if (allocated(sfval)) then
+       deallocate(sfval, sfderiv_i, sfderiv_j)
+    end if
+
+    if (allocated(stp)) then
+       call stp_final(inp%nTypes, stp)
+       do itype = 1, inp%nTypes
+          call del_Setup(stp(itype))
+       end do
+       deallocate(stp, inp%typeName, inp%atomicEnergy)
+    end if
+
+    if (ts%init) call close_TrnSet_MPI(ts)
+
+    if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
+
+    if (inp%do_timing .and. ppMaster ) call tng_final()
+    if (do_debug .and. ppMaster )  close(u_dbg)
+
+    if (ppMaster) then
+       call aeio_header(aeio_timestamp(), char=' ')
+       call aeio_header("Training set generation done.", char='=')
+    end if
+
+    call pp_final()
+
+  end subroutine finalize_MPI
+
+  
+    !--------------------------------------------------------------------!
+  
+    subroutine print_usage()
+  
+      implicit none
+  
+      write(ionum,*)
+      write(ionum,*) "generate.x -- Generate training sets for use with `train.x'"
+      write(*,'(1x,70("-"))')
+      write(ionum,*) 'Usage: generate.x <input-file>'
+      write(ionum,*)
+      write(ionum,*) 'See the documentation or the source code for a description of the '
+      write(ionum,*) 'input file format.'
+      write(ionum,*)
+  
+    end subroutine print_usage
+  
+    !--------------------------------------------------------------------!
+  
+  subroutine load_symmfunc_setups_MPI(inp, stp)
+
+    implicit none
+
+    type(InputData),           intent(in)  :: inp
+    type(Setup), dimension(:), intent(out) :: stp
+    logical :: stopnow
+    integer :: i
+
+    stopnow = .false.
+    
+   
+    if(ppMaster) then 
+      do i = 1, inp%nTypes
+         stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
+         if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
+            write(0,*) "Error: Inconsistent atom type in setup:"
+            write(0,*) "       type expected : ", trim(inp%typeName(i))
+            write(0,*) "       type found    : ", trim(stp(i)%atomtype)
+            stopnow = .true.
+         end if
+      end do
+   end if
+
+   call pp_barrier()
+   
+
+   do i = 1, inp%nTypes
+      call pp_bcast_Setup(stp(i))
+   end do
+
+   
+   call pp_barrier()
+
+
+
+    call pp_bcast(stopnow)
+    if (stopnow) then
+       call finalize_MPI()
+       stop
+    end if
+
+  end subroutine load_symmfunc_setups_MPI
+
+ end subroutine generate_subroutine_MPI
+
+
+
+ 
+end module
\ No newline at end of file
diff -Naru src/sub_makeKANdescriptors.f90 src_modified/sub_makeKANdescriptors.f90
--- src/sub_makeKANdescriptors.f90	1970-01-01 09:00:00
+++ src_modified/sub_makeKANdescriptors.f90	2024-09-10 11:05:39
@@ -0,0 +1,934 @@
+module makeKAN
+    implicit none
+
+    type, public :: Model_parameters
+        integer              :: nlayers
+        integer              :: nnodesmax
+        integer              :: Wsize
+        integer              :: nvalues
+        integer, allocatable :: nnodes(:), fun(:), iw(:), iv(:)
+        real(8), allocatable  :: W(:)
+
+        real(8), allocatable  :: W_KAN(:,:)
+        real(8),allocatable   ::b_KAN(:)
+        real(8), allocatable  :: W_MLP(:)
+
+        character(len=1024)           :: description
+        character(len=2)              :: atomtype
+        integer              :: nenv
+        character(len=2), allocatable :: envtypes(:)
+
+        real(8)                        :: rc_min, rc_max
+        character(len=100)            :: sftype
+        integer                       :: nsf, nsfparam
+        integer, allocatable          :: sf(:), sfenv(:,:)
+        real(8), allocatable           :: sfparam(:,:), sfval_min(:), sfval_max(:), sfval_avg(:), sfval_cov(:)
+        integer::neval
+        character(len=1024)           :: file
+        logical                       :: normalized
+        real(8)                        :: scale, shift, E_min, E_max, E_avg
+        integer                       :: ntypes, natomtot, nstrucs
+        character(len=2), allocatable :: type_names(:)
+        real(8), allocatable           :: E_atom(:)
+        real(8)::a_Rc,r_Rc
+        integer::a_Nc,r_Nc
+        integer::nk
+        character(len=1024)           :: infile
+        character(len=1024) ::model_r1,model_r2,model_a1,model_a2
+
+        integer              :: nlayers_KAN
+        integer              :: nnodesmax_KAN
+        integer              :: Wsize_KAN
+        integer              :: nvalues_KAN
+        integer, allocatable :: nnodes_KAN(:), fun_KAN(:), iw_KAN(:), iv_KAN(:)
+
+        integer::npoints
+
+        real(8),allocatable::values_r1(:,:),values_r2(:,:),values_a1(:,:),values_a2(:,:)
+        real(8),allocatable::bk_r1(:),bk_r2(:),bk_a1(:),bk_a2(:)
+        integer::first_fun
+
+    end type
+
+    interface Model_parameters
+        module procedure init_Model_parameters
+    end interface Model_parameters
+
+
+    double precision, parameter, private :: PI     = 3.14159265358979d0
+    double precision, parameter, private :: PI_INV = 1.0d0/PI
+    double precision, parameter, private :: PI2    = 2.0d0*PI
+    double precision, parameter, private :: EPS    = 1.0d-12
+    contains 
+
+    subroutine calc_bk(bk,Wkn,nc,nk,sfval_avg,sfval_cov)
+        implicit none
+        integer,intent(in)::nc,nk
+        real(8),intent(out)::bk(1:nk)
+        real(8),intent(in)::sfval_avg(1:nc+1),sfval_cov(1:nc+1)
+        real(8),intent(in)::Wkn(1:nk,1:nc+1)
+        
+        integer::isf
+        !integer::iw1,iw2
+        real(8)::scale,shift,s
+        real(8)::cn(1:nc+1)
+
+
+
+        !iw1 = 1
+        !iw2 = iw1 -1 + nc +1
+        do isf = 1, nc+1
+            shift = sfval_avg(isf)!isf+iw1-1)
+            s = sqrt(sfval_cov(isf) - shift*shift)
+            !s = sqrt(sfval_cov(isf+iw1-1) - shift*shift)
+            if (s <= 1.0d-10) then
+                scale = 0.0d0
+            else
+                scale = 1.0d0/s
+            end if
+            !write(*,*) "scale",scale
+            cn(isf) = scale*(-shift)
+        end do
+        bk = matmul(Wkn,cn)
+
+
+
+    end subroutine
+
+    subroutine write_model(param,outfile)
+        implicit none
+        character(len=*), intent(in)  :: outfile
+        type(Model_parameters),intent(inout)::param
+
+        param%nsf = param%nk
+        deallocate(param%sf,param%sfparam,param%sfenv,param%sfval_min,param%sfval_max,param%sfval_avg,param%sfval_cov)
+        allocate(param%sf(param%nsf), param%sfparam(param%nsfparam, param%nsf), &
+            param%sfenv(2, param%nsf), param%sfval_min( param%nsf), &
+            param%sfval_max( param%nsf), param%sfval_avg( param%nsf), param%sfval_cov( param%nsf))
+
+        open(unit = 2, action = "write", status = "replace", file = outfile, form = "unformatted")
+
+
+        write(2) param%nlayers_KAN
+        write(2) param%nnodesmax_KAN
+        write(2) param%Wsize_KAN
+        write(2) param%nvalues_KAN
+        write(2) param%nnodes_KAN(:)
+        write(2) param%fun_KAN(:)
+        write(2) param%iw_KAN(:)
+        write(2) param%iv_KAN(:)
+        write(2) param%W_MLP(:)
+
+        write(2) param%description
+        write(2) param%atomtype
+        write(2) param%nenv
+        write(2) param%envtypes(:)
+        write(2) param%rc_min
+        write(2) param%rc_max
+        write(2) param%sftype
+
+        write(2) param%nsf
+        write(2) param%nsfparam
+        write(2) param%sf(:)
+        write(2) param%sfparam(:,:)
+        write(2) param%sfenv(:,:)
+        write(2) param%neval
+        write(2) param%sfval_min
+        write(2) param%sfval_max
+        write(2) param%sfval_avg
+        write(2) param%sfval_cov
+
+        write(2) param%file
+        write(2) param%normalized
+        write(2) param%scale
+        write(2) param%shift
+        write(2) param%ntypes
+        write(2) param%type_names(:)
+        write(2) param%E_atom(:)
+        write(2) param%natomtot
+        write(2) param%nstrucs
+        write(2) param%E_min, param%E_max, param%E_avg
+
+
+        write(2) param%npoints
+        write(2) param%nk
+        write(2) param%b_KAN
+        write(2) param%values_r1
+        if (param%ntypes > 1) then
+            write(2) param%values_r2
+        end if
+        write(2) param%values_a1
+        if (param%ntypes > 1) then
+            write(2) param%values_a2
+        end if
+        write(2) param%bk_r1
+        if (param%ntypes > 1) then
+            write(2) param%bk_r2
+        end if
+        write(2) param%bk_a1
+        if (param%ntypes > 1) then
+            write(2) param%bk_a2
+        end if
+        write(2) param%r_Rc,param%r_Nc,param%a_Rc,param%a_Nc
+        write(2) param%rc_min
+        write(2) param%first_fun
+
+        
+        !write(*,*) param%bk_r1,param%bk_r2,param%bk_a1,param%bk_a2
+        
+    
+        close(2)
+ 
+
+    end
+
+    subroutine construct_KAN_descriptor(param,npoints)
+        implicit none
+        type(Model_parameters),intent(inout)::param
+        integer,intent(in) ::npoints
+        real(8)::r_Rc,Rmin,d_ij
+        integer::i,iw1,iw2,nk
+        !real(8),allocatable::values_r1(:),values_r2(:),values_a1(:),values_a2(:)
+        !real(8),allocatable::bk_r1(:),bk_r2(:),bk_a1(:),bk_a2(:)
+        real(8)::w_ij
+        real(8)::cos_theta_ijk
+        !integer::isf
+        !real(8)::shift,scale,s
+        real(8),allocatable::cn(:)
+        real(8),allocatable::values(:)
+
+        r_Rc = param%r_Rc
+        Rmin = param%rc_min
+        nk = param%nk
+        param%npoints = npoints
+       ! allocate(values_r1(1:nk),values_r2(1:nk),values_a1(1:nk),values_a2(1:nk))
+       ! allocate(bk_r1(1:nk),bk_r2(1:nk),bk_a1(1:nk),bk_a2(1:nk))
+        allocate(cn(1:param%r_Nc+1))
+
+        allocate(param%values_r1(npoints,1:param%nk),param%values_r2(npoints,1:param%nk),&
+                param%values_a1(npoints,1:param%nk),param%values_a2(npoints,1:param%nk))
+        param%values_r1 = 0d0
+        param%values_a1 = 0d0
+        allocate(values(1:param%nk))
+        values = 0d0
+
+        param%values_r2 = 0d0
+        param%values_a2 = 0d0
+
+
+        allocate(param%bk_r1(1:param%nk),param%bk_r2(1:param%nk),&
+                param%bk_a1(1:param%nk),param%bk_a2(1:param%nk))
+
+        param%bk_r1 = 0d0
+        param%bk_r2 = 0d0
+        param%bk_a1 = 0d0
+        param%bk_a2 = 0d0
+
+
+
+
+ 
+        open(11,file= trim(param%model_r1))!trim(param%infile)//"_CKAN_r1.txt")
+        if (param%ntypes > 1) then
+            open(12,file= trim(param%model_r2))!trim(param%infile)//"_CKAN_r2.txt")
+            open(14,file= trim(param%model_a2))!trim(param%infile)//"_CKAN_a2.txt")
+        end if
+        open(13,file= trim(param%model_a1))!trim(param%infile)//"_CKAN_a1.txt")
+        
+
+        param%bk_r1 = 0d0
+        
+
+        iw1 = 1
+        iw2 = iw1 -1 + param%r_Nc +1
+        !write(*,*) iw1,iw2
+        call calc_bk(param%bk_r1,param%W_KAN(1:nk,iw1:iw2),param%r_nc,nk,param%sfval_avg(iw1:iw2),param%sfval_cov(iw1:iw2))
+
+        if (param%ntypes > 1) then
+            iw1 = param%r_Nc +1 + param%a_Nc +1 + 1
+            !iw2 + 1
+            iw2 = iw1 -1 + param%r_Nc +1
+            !write(*,*) iw1,iw2
+            call calc_bk(param%bk_r2,param%W_KAN(1:nk,iw1:iw2),param%r_nc,nk,param%sfval_avg(iw1:iw2),param%sfval_cov(iw1:iw2))
+        end if
+
+        write(11,*) "# ",nk, r_Rc, Rmin,npoints
+        write(11,*) "# ",param%bk_r1
+
+        if (param%ntypes > 1) then
+            write(12,*) "# ",nk, r_Rc, Rmin,npoints
+            write(12,*) "# ",param%bk_r2
+        end if
+
+
+        do i=1,npoints  
+            d_ij = dble(i-1)*(r_Rc-Rmin)/dble(npoints-1) + Rmin
+            w_ij = sfb_fc(d_ij, r_Rc)
+            iw1 = 1
+            iw2 = iw1 -1 + param%r_Nc +1
+            call evaluate_KANfunction(param%W_KAN(1:nk,iw1:iw2),nk,d_ij,0d0,r_Rc,param%r_Nc+1,&
+                param%sfval_avg(iw1:iw2),param%sfval_cov(iw1:iw2),values)
+            param%values_r1(i,:) = values*w_ij
+            write(11,*) d_ij,param%values_r1(i,:)
+            
+            if (param%ntypes > 1) then
+                iw1 = param%r_Nc +1 + param%a_Nc +1 + 1
+                iw2 = iw1 -1 + param%r_Nc +1
+                !write(*,*) iw1,iw2
+                call evaluate_KANfunction(param%W_KAN(1:nk,iw1:iw2),nk,d_ij,0d0,r_Rc,param%r_Nc+1,&
+                    param%sfval_avg(iw1:iw2),param%sfval_cov(iw1:iw2),values)  
+                param%values_r2(i,:) = values*w_ij
+                write(12,*) d_ij,param%values_r2(i,:)
+                !write(*,*) d_ij,values_r1,values_r2
+            end if
+            
+           
+        end do
+
+        r_Rc = param%a_Rc
+        Rmin = param%rc_min
+
+        !if (param%ntypes > 1) then
+        !    iw1 = 2*(param%r_Nc +1) + 1
+        !else
+        !    iw1 = (param%r_Nc +1) + 1
+        !end if
+        iw1 = (param%r_Nc +1) + 1
+        iw2 = iw1 -1 + param%a_Nc +1
+        !write(*,*) iw1,iw2
+        call calc_bk(param%bk_a1,param%W_KAN(1:nk,iw1:iw2),param%a_nc,nk,param%sfval_avg(iw1:iw2),param%sfval_cov(iw1:iw2))
+        write(13,*) "# ",nk, r_Rc, Rmin,npoints
+        write(13,*) "# ",param%bk_r1
+
+
+        if (param%ntypes > 1) then
+            iw1 = param%r_Nc +1 + param%a_Nc +1 + (param%r_Nc +1) + 1
+            iw2 = iw1 -1 + param%a_Nc +1
+            !write(*,*) iw1,iw2
+            
+            call calc_bk(param%bk_a2,param%W_KAN(1:nk,iw1:iw2),param%a_nc,nk,param%sfval_avg(iw1:iw2),param%sfval_cov(iw1:iw2))
+            write(14,*) "# ",nk, r_Rc, Rmin,npoints
+            write(14,*) "# ",param%bk_r2
+
+        end if
+
+
+        do i=1,npoints  
+            cos_theta_ijk = dble(i-1)*2/dble(npoints-1) -1d0
+            iw1 = (param%r_Nc +1) + 1
+            iw2 = iw1 -1 + param%a_Nc +1
+            call evaluate_KANfunction(param%W_KAN(1:nk,iw1:iw2),nk,cos_theta_ijk,-1d0,1d0,param%a_Nc+1,&
+                param%sfval_avg(iw1:iw2),param%sfval_cov(iw1:iw2),values)
+            param%values_a1(i,:) = values
+            write(13,*) cos_theta_ijk,param%values_a1(i,:)
+
+            if (param%ntypes > 1) then
+                iw1 = param%r_Nc +1 + param%a_Nc +1 + (param%r_Nc +1) + 1
+                iw2 = iw1 -1 + param%a_Nc +1
+               
+                call evaluate_KANfunction(param%W_KAN(1:nk,iw1:iw2),nk,cos_theta_ijk,-1d0,1d0,param%a_Nc+1,&
+                    param%sfval_avg(iw1:iw2),param%sfval_cov(iw1:iw2),values)
+                param%values_a2(i,:) = values
+                !write(*,*) d_ij,values_r1,values_r2
+                
+                write(14,*) cos_theta_ijk,param%values_a2(i,:)
+            end if
+        end do
+
+        close(11)
+        if (param%ntypes > 1) then
+            close(12)
+            close(14)
+        end if
+        close(13)
+        
+
+    end subroutine
+
+    subroutine evaluate_KANfunction(Wkn,nk,x,xa,xb,r_N,sfval_avg,sfval_cov,values)
+        implicit none
+        integer,intent(in)::nk !number of KAN functions
+        integer,intent(in)::r_N !number of radial basis
+        real(8),intent(in)::Wkn(nk,r_N) !(nk,r_N)
+        real(8),intent(in)::x,xa,xb
+        real(8),intent(in)::sfval_cov(1:r_N),sfval_avg(1:r_N)
+        double precision, dimension(r_N) :: f
+        double precision, dimension(nk),intent(out):: values
+        integer::r_order,isf
+        real(8)::shift,scale,s
+
+        r_order = r_N - 1
+        f(1:r_N) = chebyshev_polynomial(x, xa, xb, r_order)
+        do isf = 1, r_N
+            shift = sfval_avg(isf)
+            ! scale covariance to 1
+            ! s = sqrt(stp%sfval_cov(isf) + shift*shift - 2.0d0*shift*stp%sfval_avg(isf))
+            s = sqrt(sfval_cov(isf) - shift*shift)
+            if (s <= 1.0d-10) then
+                scale = 0.0d0
+            else
+                scale = 1.0d0/s
+            end if
+            !write(*,*) "scale_w",scale
+            f(isf) = scale*(f(isf))!-shift)
+        end do
+
+        !f(r_N+1) = 1.0d0 
+        values = matmul(Wkn,f)
+    end subroutine 
+
+    type(Model_parameters) function init_Model_parameters(infile) result(param)
+        implicit none
+        character(len=*), intent(in)  :: infile
+        !integer,intent(in) ::npoints
+        integer::iw1,iw2
+        integer::i
+        !logical::debugmode
+
+        open(unit = 1, action = "read", status = "old", file = infile)
+        param%infile = trim(infile)
+        param%model_r1 = trim(param%infile)//"_CKAN_r1.txt"
+        param%model_r2 = trim(param%infile)//"_CKAN_r2.txt"
+        param%model_a1 = trim(param%infile)//"_CKAN_a1.txt"
+        param%model_a2 = trim(param%infile)//"_CKAN_a2.txt"
+
+
+        !write(*,*) infile
+        ! Network information
+        read(1,*) param%nlayers
+        read(1,*) param%nnodesmax
+        read(1,*) param%Wsize
+        read(1,*) param%nvalues
+
+        allocate(param%nnodes( param%nlayers), param%fun( param%nlayers-1), &
+            param%iw( param%nlayers), param%iv( param%nlayers), param%W( param%Wsize))
+
+        read(1,*) param%nnodes(:)
+        read(1,*) param%fun(:)
+        read(1,*) param%iw(:)
+        read(1,*) param%iv(:)
+        read(1,*) param%W(:)
+
+        param%nlayers_KAN = param%nlayers -1
+
+
+
+        param%nnodesmax_KAN = 1
+        do i = 2,param%nlayers
+            if (param%nnodesmax_KAN < param%nnodes(i)) then
+                param%nnodesmax_KAN = param%nnodes(i)
+            end if
+        end do
+
+
+
+        iw1 = param%nnodes(1)
+        iw2 = param%nnodes(2)
+        param%nk = iw2
+        allocate(param%W_KAN(iw2,iw1))
+        allocate(param%b_KAN(iw2))
+        param%W_KAN = reshape(param%W(1:iw1*iw2), &
+            (/ iw2,iw1 /) )
+        param%b_KAN = param%W(iw1*iw2+1:iw1*iw2+iw2)
+
+        !write(*,*) "number of layers in the network, inluding input and output layer  "
+        !write(*,*) param%nlayers
+        
+        !write(*,*) "max. number of nodes in a layer of this network"
+        !write(*,*) param%nnodesmax
+        !write(*,*) "total number of weights; Wsize = size(W) "
+        !write(*,*) param%Wsize
+        !write(*,*) "total number of nodes/neurons in the network "
+        !write(*,*) param%nvalues
+        !write(*,*) "number of nodes (without bias) in the i-th layer"
+        !write(*,*) param%nnodes(:)
+
+
+        !write(*,*) "activation function type for the i-th layer "
+        !write(*,*) param%fun(:)
+        !write(*,*) "index of the last weight of the i-th layer  "
+        !write(*,*) "e.g.: W(iw(2)) --> last weight in the 2nd layer "
+        !write(*,*) param%iw(:)
+        !write(*,*) "index of the last node in the i-th layer "
+        !write(*,*) param%iv(:)
+        !write(*,*) "i-th weight of the graph edges (including bias) "
+        !write(*,*) param%W(:)
+
+        !write(*,*) "weight for KAN (without bias) "
+        !write(*,*) param%W_KAN
+        !write(*,*) "bias for KAN  "
+        !write(*,*) param%b_KAN
+
+        !write(*,*) "max. number of nodes in a layer of KAN network"
+        !write(*,*) param%nnodesmax_KAN
+
+        allocate(param%W_MLP(1:ubound(param%W,1)-(iw1*iw2+iw2+1)+1))
+        param%W_MLP(1:ubound(param%W,1)-(iw1*iw2+iw2+1)+1) = param%W(iw1*iw2+iw2+1:ubound(param%W,1))
+        !write(*,*) "i-th weight of the graph edges (including bias) for new network "
+        !write(*,*) param%W_MLP(:)
+
+        !write(*,*) "total number of weights; Wsize_KAN = size(W_MLP) "
+        param%Wsize_KAN = ubound(param%W_MLP,1)
+        !write(*,*) param%Wsize_KAN
+
+
+        allocate(param%nnodes_KAN( param%nlayers_KAN), param%fun_KAN( param%nlayers_KAN-1), &
+        param%iw_KAN( param%nlayers_KAN), param%iv_KAN( param%nlayers_KAN))
+
+        param%nnodes_KAN(1:param%nlayers_KAN) = param%nnodes(2:param%nlayers)
+        param%fun_KAN(1:param%nlayers_KAN-1) = param%fun(2:param%nlayers-1)
+        param%first_fun = param%fun(1)
+        !write(*,*) "number of nodes (without bias) in the i-th layer for KAN"
+        !write(*,*) param%nnodes_KAN(:)
+        !write(*,*) "activation function type for the i-th layer for KAN"
+        !write(*,*) param%fun_KAN(:)
+        param%nvalues_KAN = 0
+        do i=1,param%nlayers_KAN
+            param%nvalues_KAN = param%nvalues_KAN +  param%nnodes_KAN(i)+1
+            param%iw_KAN(i) = param%iw(i+1) - (param%nnodes(1)+1)*param%nnodes(2)
+            param%iv_KAN(i) = param%iv(i+1) - (param%nnodes(1)+1)
+        end do
+
+        !write(*,*) "index of the last weight of the i-th layer for KAN "
+        !write(*,*) "e.g.: W(iw_KAN(2)) --> last weight in the 2nd layer "
+        !write(*,*) param%iw_KAN(:)
+        !write(*,*) "index of the last node in the i-th layer for KAN"
+        !write(*,*) param%iv_KAN(:)
+
+        !write(*,*) "total number of nodes/neurons in the network "
+        !write(*,*) param%nvalues_KAN
+            
+        ! Structural Fingerprint setup information
+
+        read(1,*) param%description
+        read(1,*) param%atomtype
+        read(1,*) param%nenv
+
+        allocate(param%envtypes(param%nenv))
+
+        read(1,*) param%envtypes(:)
+        read(1,*) param%rc_min
+        read(1,*) param%rc_max
+        read(1,*) param%sftype
+        read(1,*) param%nsf
+        read(1,*) param%nsfparam
+
+        allocate(param%sf(param%nsf), param%sfparam(param%nsfparam, param%nsf), &
+            param%sfenv(2, param%nsf), param%sfval_min( param%nsf), &
+            param%sfval_max( param%nsf), param%sfval_avg( param%nsf), param%sfval_cov( param%nsf))
+
+        read(1,*)  param%sf(:)
+        read(1,*)  param%sfparam(:,:)
+        read(1,*)  param%sfenv(:,:)
+        read(1,*)  param%neval
+        read(1,*)  param%sfval_min
+        read(1,*)  param%sfval_max
+        read(1,*)  param%sfval_avg
+        read(1,*)  param%sfval_cov
+
+        !write(*,*) "an optional description from the setup file "
+        !write(*,*)  param%description
+        !write(*,*) "species of the central atom"
+        !write(*,*)  param%atomtype
+        !write(*,*) "number of different surrounding species"
+        !write(*,*)  param%nenv
+        !write(*,*) "species of the surrounding atoms "
+        !write(*,*)  param%envtypes(:)
+
+        !write(*,*) "minimal interaction radius and max. cutoff "
+        !write(*,*)  param%rc_min
+        !write(*,*)  param%rc_max
+        !write(*,*) "basis function type (e.g. Behler2011)    "
+        !write(*,*)  param%sftype
+
+        if (trim(param%sftype) == "Chebyshev") then
+            write(*,*) "This basis function "//trim(param%sftype)//" is supported for KAN"
+            param%sftype = "ChebyshevKAN"
+        else
+            write(*,*) "Error: This basis function "//trim(param%sftype)//" is not supported for KAN"
+            stop
+        end if
+        
+        !radial_Rc = 6.5  radial_N = 20 angular_Rc = 5.  angular_N = 6
+        param%r_Rc = param%sfparam(1,1)
+        param%r_nc = int(param%sfparam(2,1))
+        param%a_Rc = param%sfparam(3,1)
+        param%a_nc = int(param%sfparam(4,1))
+        !write(*,*) "radial_Rc,radial_N,angular_Rc,angular_N"
+        !write(*,*) param%r_Rc,param%r_nc,param%a_Rc,param%a_nc
+
+
+        !write(*,*) "number of structural fingerprint basis functions  "
+        !write(*,*)  param%nsf
+        !write(*,*) "the max. number of parameters of a basis function"
+        !write(*,*)  param%nsfparam
+        !write(*,*) "function kind of the particular basis type   "
+        !write(*,*)  param%sf(:)
+        !write(*,*) "i-th parameter of the j-th basis function"
+        !write(*,*) "               i <= nsfparam"
+        !write(*,*)  param%sfparam(:,:)
+        !write(*,*) "i-th environment species for j-th basis function"
+        !write(*,*)  param%sfenv(:,:)
+        !write(*,*) "number of evaluations   "
+        !write(*,*)  param%neval
+        !write(*,*) "lowest so far encountered value of the i-th SF "
+        !write(*,*)  param%sfval_min
+        !write(*,*) "largest so far encountered value of the i-th SF "
+        !write(*,*)  param%sfval_max
+        !write(*,*) "current average value of the i-th symm. function "
+        !write(*,*)  param%sfval_avg
+        !write(*,*) "current covariance of the i-th symm. function "
+        !write(*,*)  param%sfval_cov
+    
+
+            ! Trainset information
+
+        read(1,*)  param%file
+        read(1,*)  param%normalized
+        read(1,*)  param%scale
+        read(1,*)  param%shift
+        read(1,*)  param%ntypes
+
+        allocate( param%type_names( param%ntypes),  param%E_atom( param%ntypes))
+
+        !write(*,*) " name of the corresponding training set file "
+        !write(*,*)  param%file
+        !write(*,*) ".true., if the input and output values have been  normalized to the interval [-1,1] ('read' mode only)"
+        !write(*,*)  param%normalized
+        !write(*,*) "energy scaling factor used for the normalization "
+        !write(*,*)  param%scale
+        !write(*,*) "atomic energy shift used for energy normalization "
+        !write(*,*)  param%shift
+        !write(*,*) "number of atomic species in the training set  "
+        !write(*,*)  param%ntypes
+
+        read(1,*)  param%type_names(:)
+        !write(*,*) "name of i-th atomic species    "
+        !write(*,*)  param%type_names(:)
+
+        read(1,*)  param%E_atom(:)
+        !write(*,*) "E_atom"
+        
+        !write(*,*)  param%E_atom(:)
+
+        read(1,*)  param%natomtot
+        read(1,*)  param%nstrucs
+        read(1,*)  param%E_min,  param%E_max,  param%E_avg
+
+
+
+
+        !write(*,*) "natomtot"
+        !write(*,*)  param%natomtot
+        !write(*,*) "nstrucs"
+        !write(*,*)  param%nstrucs
+        !write(*,*) "E_min,E_max,E_avg"
+        !write(*,*)  param%E_min,  param%E_max,  param%E_avg
+   
+
+
+
+        close(unit = 1)
+
+    end function
+
+
+
+    subroutine finalize()
+
+        implicit none
+    
+    end subroutine finalize
+    
+    subroutine initialize(infile,outfile,npoints,frombinary)
+        implicit none
+        character(len=*), intent(out) :: infile, outfile
+        integer :: iarg, nargs
+        character(len=100) :: arg
+        integer,intent(out)::npoints
+        integer :: conversion_success
+        logical,intent(out)::frombinary
+    
+        nargs = command_argument_count()
+        if (nargs < 1) then
+           write(0,*) "Error: No input file provided."
+           call finalize()
+           stop
+        end if
+
+        
+    
+        infile = ' '
+        outfile = ' '
+        
+        iarg = 1
+        call get_command_argument(iarg, value=arg)
+        infile = trim(arg)
+        iarg = 2
+        call get_command_argument(iarg, value=arg)
+        outfile = trim(arg)
+        if (nargs == 3 .or. nargs == 4) then
+            iarg = 3
+            call get_command_argument(iarg, value=arg)
+            read(arg, *, iostat=conversion_success) npoints
+        else
+            npoints = 1000
+        end if
+
+        if (nargs == 4) then
+            iarg = 4
+            call get_command_argument(iarg, value=arg)
+            if (trim(arg) == "--from-binary") then
+                frombinary = .true.
+            else
+                frombinary = .false.
+            end if
+        else
+            frombinary = .false.
+        end if
+
+
+
+        return
+
+
+    end
+
+    function sfb_fc(Rij, Rc) result(fc)
+
+        implicit none
+    
+        double precision, intent(in) :: Rij, Rc
+        double precision             :: fc
+    
+        if (Rij >= Rc) then
+           fc  = 0.0d0
+        else
+           fc  =  0.5d0*(cos(PI/Rc*Rij) + 1.0d0)
+        end if
+    
+      end function sfb_fc
+
+    !--------------------------------------------------------------------!
+  !                   Evaluate Chebyshev polynomials                   !
+  !--------------------------------------------------------------------!
+
+  function chebyshev_polynomial(r, r0, r1, n) result(T)
+    ! Arguments:
+    !    r        function argument
+    !    r0, r1   the Chebyshev polynomials will be rescaled from [-1,1]
+    !             to the interval [r0,r1]
+    !    n        maximum polynomial order
+    ! Returns:
+    !    T(i)  with i=1,n+1  where T(i) is the Chebyshev polynomial of
+    !    order (i-1)
+    !
+    ! The Chebyshev polynomials obey the following recurrence relation:
+    !    T[0](x) = 1
+    !    T[1](x) = x
+    !    T[n+1](x) = 2x T[n](x) - T[n-1](x)
+
+    implicit none
+
+    double precision, intent(in)     :: r, r0, r1
+    integer,          intent(in)     :: n
+    double precision, dimension(n+1) :: T
+
+    integer          :: i
+    double precision :: x
+
+    x = (2.0d0*r - r0 - r1)/(r1 - r0)
+
+    T(1) = 1.0d0
+    if (n > 0) then
+       T(2) = x
+       do i = 3, n+1
+          T(i) = 2.0d0*x*T(i-1) - T(i-2)
+       end do
+    end if
+
+  end function chebyshev_polynomial
+
+    !--------------------------------------------------------------------!
+!This subroutine comes from aenet-PyTorch. 
+subroutine bin2ascii(infile, outfile)
+    implicit none
+
+    character(len=*), intent(in)  :: infile, outfile
+
+    integer              :: nlayers, nnodesmax, Wsize, nvalues
+    integer, allocatable :: nnodes(:), fun(:), iw(:), iv(:)
+    real*8, allocatable  :: W(:)
+
+    character(len=1024)           :: description
+    character(len=100)            :: sftype
+    character(len=2)              :: atomtype
+    character(len=2), allocatable :: envtypes(:)
+    real*8                        :: rc_min, rc_max
+    integer                       :: nsf, nsfparam, neval, nenv
+    integer, allocatable          :: sf(:), sfenv(:,:)
+    real*8, allocatable           :: sfparam(:,:), sfval_min(:), sfval_max(:), sfval_avg(:), sfval_cov(:)
+
+    character(len=1024)           :: file
+    logical                       :: normalized
+    real*8                        :: scale, shift, E_min, E_max, E_avg
+    integer                       :: ntypes, natomtot, nstrucs
+    character(len=2), allocatable :: type_names(:)
+    real*8, allocatable           :: E_atom(:)
+
+
+    open(unit = 1, action = "read", status = "old", file = infile, form = "unformatted")
+    open(unit = 2, action = "write", status = "replace", file = outfile)
+
+
+    ! Network information
+    read(1) nlayers
+    read(1) nnodesmax
+    read(1) Wsize
+    read(1) nvalues
+
+    allocate(nnodes(nlayers), fun(nlayers-1), iw(nlayers), iv(nlayers), W(Wsize))
+
+    read(1) nnodes(:)
+    read(1) fun(:)
+    read(1) iw(:)
+    read(1) iv(:)
+    read(1) W(:)
+
+
+    write(2,*) nlayers
+    write(2,*) nnodesmax
+    write(2,*) Wsize
+    write(2,*) nvalues
+    write(2,*) nnodes(:)
+    write(2,*) fun(:)
+    write(2,*) iw(:)
+    write(2,*) iv(:)
+    write(2,*) W(:)
+
+    deallocate(nnodes, fun, iw, iv, W)
+
+
+
+    ! Structural Fingerprint setup information
+    read(1) description
+    read(1) atomtype
+    read(1) nenv
+
+    allocate(envtypes(nenv))
+
+    read(1) envtypes(:)
+    read(1) rc_min
+    read(1) rc_max
+    read(1) sftype
+    read(1) nsf
+    read(1) nsfparam
+
+    allocate(sf(nsf), sfparam(nsfparam,nsf), sfenv(2,nsf), sfval_min(nsf), &
+             sfval_max(nsf), sfval_avg(nsf), sfval_cov(nsf))
+
+    read(1) sf(:)
+    read(1) sfparam(:,:)
+    read(1) sfenv(:,:)
+    read(1) neval
+    read(1) sfval_min
+    read(1) sfval_max
+    read(1) sfval_avg
+    read(1) sfval_cov
+
+
+
+    write(2,*) description
+    write(2,*) atomtype
+    write(2,*) nenv
+    write(2,"(a)") envtypes(:)
+    write(2,*) rc_min
+    write(2,*) rc_max
+    write(2,*) sftype
+    write(2,*) nsf
+    write(2,*) nsfparam
+    write(2,*) sf(:)
+    write(2,*) sfparam(:,:)
+    write(2,*) sfenv(:,:)
+    write(2,*) neval
+    write(2,*) sfval_min
+    write(2,*) sfval_max
+    write(2,*) sfval_avg
+    write(2,*) sfval_cov
+
+    deallocate(sf, sfparam, sfenv, sfval_min, sfval_max, sfval_avg, sfval_cov)
+
+
+
+    ! Trainset information
+    read(1) file
+    read(1) normalized
+    read(1) scale
+    read(1) shift
+    read(1) ntypes
+
+    allocate(type_names(ntypes), E_atom(ntypes))
+
+    read(1) type_names(:)
+    read(1) E_atom(:)
+    read(1) natomtot
+    read(1) nstrucs
+    read(1) E_min, E_max, E_avg
+
+
+    write(2,*) file
+    write(2,*) normalized
+    write(2,*) scale
+    write(2,*) shift
+    write(2,*) ntypes
+    write(2,'(A, 2X, A,2X,A,2X,A,2X,A,2X)') type_names(:)
+    write(2,*) E_atom(:)
+    write(2,*) natomtot
+    write(2,*) nstrucs
+    write(2,*) E_min, E_max, E_avg
+
+    deallocate(type_names, E_atom)
+
+
+    close(unit = 1)
+    close(unit = 2)
+
+end subroutine bin2ascii
+
+subroutine makeKANdescriptor(infile,outfile,npoints,frombinary)
+    implicit none
+    character(len=*),intent(in) :: infile,outfile
+    logical,intent(in)::frombinary
+    integer,intent(in)::npoints
+    character(len=1024) :: infile_ascii
+    type(Model_parameters)::param
+
+    write(*,*) "input file is ",trim(infile)
+
+    if (frombinary) then
+        infile_ascii = trim(infile)//".ascii"
+        !write(*,*) "Binary file is converted to ascii file"
+        !write(*,*) trim(infile_ascii)
+        call bin2ascii(infile, infile_ascii)
+    else
+        infile_ascii = trim(infile)
+    end if
+    if (frombinary) then
+        write(*,*) "Binary file "//trim(infile)//" was converted to ascii file "//trim(infile_ascii)
+    end if
+
+    param = Model_parameters(infile_ascii)
+    call construct_KAN_descriptor(param,npoints)
+
+    call write_model(param,outfile)
+
+
+    write(*,*) "output file is ",trim(outfile)
+    write(*,*) "npoints is ",npoints
+
+end subroutine makeKANdescriptor 
+
+end module makeKAN
+
+
+
diff -Naru src/sub_nnASCII2bin.f90 src_modified/sub_nnASCII2bin.f90
--- src/sub_nnASCII2bin.f90	1970-01-01 09:00:00
+++ src_modified/sub_nnASCII2bin.f90	2024-09-06 10:37:30
@@ -0,0 +1,383 @@
+module aenet_nnASCII2bin
+   implicit none
+   contains 
+
+subroutine nnASCII2bin_subroutine(infile, outfile, to_bin, to_ascii)
+
+    implicit none
+    
+    character(len=*),intent(in) :: infile, outfile
+    logical,intent(in)             :: to_bin, to_ascii
+    
+    
+    
+    !call initialize(infile, outfile, to_bin, to_ascii)
+    
+    if (to_ascii .and. .not. to_bin) then
+        call bin2ascii(infile, outfile)
+    else if (to_bin .and. .not. to_ascii) then
+        call ascii2bin(infile, outfile)
+    endif
+    
+    
+    contains
+    
+    subroutine initialize(infile, outfile, to_bin, to_ascii)
+    
+        implicit none
+    
+        character(len=*), intent(out) :: infile, outfile
+        integer :: iarg, nargs
+        character(len=100) :: arg
+        logical, intent(out) :: to_bin, to_ascii
+    
+        nargs = command_argument_count()
+        if (nargs < 1) then
+           write(0,*) "Error: No input file provided."
+           call finalize()
+           stop
+        end if
+    
+        infile = ' '
+        outfile = ' '
+    
+        to_bin = .true.
+        to_ascii = .false.
+        
+        iarg = 1
+        do while(iarg <= nargs)
+           call get_command_argument(iarg, value=arg)
+           select case(trim(arg))
+           case('--to-binary')
+              to_bin = .true.
+              to_ascii = .false.
+           case('--to-ascii')
+              to_ascii = .true.
+              to_bin = .false.
+           case default
+              if (len_trim(infile) == 0) then
+                 infile = trim(arg)
+              else if (len_trim(outfile) == 0) then
+                 outfile = trim(arg)
+              else
+                 write(0,*) 'Error: Unknown argument: ', trim(arg)
+                 call finalize()
+                 stop
+              end if
+           end select
+           iarg = iarg + 1
+        end do
+    
+        if ((len(infile) == 0) .or. (len(outfile) == 0))then
+           write(0,*) 'Error: No input file specified.'
+           call finalize()
+           stop
+        end if
+    
+    end subroutine initialize
+    
+      !--------------------------------------------------------------------!
+    
+    subroutine finalize()
+    
+        implicit none
+    
+    end subroutine finalize
+    
+      !--------------------------------------------------------------------!
+    
+    subroutine ascii2bin(infile, outfile)
+        implicit none
+    
+        character(len=*), intent(in)  :: infile, outfile
+    
+        integer              :: nlayers, nnodesmax, Wsize, nvalues
+        integer, allocatable :: nnodes(:), fun(:), iw(:), iv(:)
+        real*8, allocatable  :: W(:)
+    
+        character(len=1024)           :: description
+        character(len=100)            :: sftype
+        character(len=2)              :: atomtype
+        character(len=2), allocatable :: envtypes(:)
+        real*8                        :: rc_min, rc_max
+        integer                       :: nsf, nsfparam, neval, nenv
+        integer, allocatable          :: sf(:), sfenv(:,:)
+        real*8, allocatable           :: sfparam(:,:), sfval_min(:), sfval_max(:), sfval_avg(:), sfval_cov(:)
+    
+        character(len=1024)           :: file
+        logical                       :: normalized
+        real*8                        :: scale, shift, E_min, E_max, E_avg
+        integer                       :: ntypes, natomtot, nstrucs
+        character(len=2), allocatable :: type_names(:)
+        real*8, allocatable           :: E_atom(:)
+    
+    
+        open(unit = 1, action = "read", status = "old", file = infile)
+        open(unit = 2, action = "write", status = "replace", file = outfile, form = "unformatted")
+    
+    
+        ! Network information
+        read(1,*) nlayers
+        read(1,*) nnodesmax
+        read(1,*) Wsize
+        read(1,*) nvalues
+    
+        allocate(nnodes(nlayers), fun(nlayers-1), iw(nlayers), iv(nlayers), W(Wsize))
+    
+        read(1,*) nnodes(:)
+        read(1,*) fun(:)
+        read(1,*) iw(:)
+        read(1,*) iv(:)
+        read(1,*) W(:)
+    
+    
+        write(2) nlayers
+        write(2) nnodesmax
+        write(2) Wsize
+        write(2) nvalues
+        write(2) nnodes(:)
+        write(2) fun(:)
+        write(2) iw(:)
+        write(2) iv(:)
+        write(2) W(:)
+    
+    
+        deallocate(nnodes, fun, iw, iv, W)
+    
+    
+    
+        ! Structural Fingerprint setup information
+        read(1,*) description
+        read(1,*) atomtype
+        read(1,*) nenv
+    
+        allocate(envtypes(nenv))
+    
+        read(1,*) envtypes(:)
+        read(1,*) rc_min
+        read(1,*) rc_max
+        read(1,*) sftype
+        read(1,*) nsf
+        read(1,*) nsfparam
+    
+        allocate(sf(nsf), sfparam(nsfparam,nsf), sfenv(2,nsf), sfval_min(nsf), &
+                 sfval_max(nsf), sfval_avg(nsf), sfval_cov(nsf))
+    
+        read(1,*) sf(:)
+        read(1,*) sfparam(:,:)
+        read(1,*) sfenv(:,:)
+        read(1,*) neval
+        read(1,*) sfval_min
+        read(1,*) sfval_max
+        read(1,*) sfval_avg
+        read(1,*) sfval_cov
+    
+        !print*, sfparam(:,1)
+    
+    
+        write(2) description
+        write(2) atomtype
+        write(2) nenv
+        write(2) envtypes(:)
+        write(2) rc_min
+        write(2) rc_max
+        write(2) sftype
+        write(2) nsf
+        write(2) nsfparam
+        write(2) sf(:)
+        write(2) sfparam(:,:)
+        write(2) sfenv(:,:)
+        write(2) neval
+        write(2) sfval_min
+        write(2) sfval_max
+        write(2) sfval_avg
+        write(2) sfval_cov
+    
+        deallocate(sf, sfparam, sfenv, sfval_min, sfval_max, sfval_avg, sfval_cov)
+    
+    
+    
+        ! Trainset information
+        read(1,*) file
+        read(1,*) normalized
+        read(1,*) scale
+        read(1,*) shift
+        read(1,*) ntypes
+    
+        allocate(type_names(ntypes), E_atom(ntypes))
+    
+        read(1,*) type_names(:)
+        read(1,*) E_atom(:)
+        read(1,*) natomtot
+        read(1,*) nstrucs
+        read(1,*) E_min, E_max, E_avg
+    
+    
+        write(2) file
+        write(2) normalized
+        write(2) scale
+        write(2) shift
+        write(2) ntypes
+        write(2) type_names(:)
+        write(2) E_atom(:)
+        write(2) natomtot
+        write(2) nstrucs
+        write(2) E_min, E_max, E_avg
+    
+        deallocate(type_names, E_atom)
+    
+    
+        close(unit = 1)
+        close(unit = 2)
+    
+    end subroutine ascii2bin
+    
+      !--------------------------------------------------------------------!
+    
+    subroutine bin2ascii(infile, outfile)
+        implicit none
+    
+        character(len=*), intent(in)  :: infile, outfile
+    
+        integer              :: nlayers, nnodesmax, Wsize, nvalues
+        integer, allocatable :: nnodes(:), fun(:), iw(:), iv(:)
+        real*8, allocatable  :: W(:)
+    
+        character(len=1024)           :: description
+        character(len=100)            :: sftype
+        character(len=2)              :: atomtype
+        character(len=2), allocatable :: envtypes(:)
+        real*8                        :: rc_min, rc_max
+        integer                       :: nsf, nsfparam, neval, nenv
+        integer, allocatable          :: sf(:), sfenv(:,:)
+        real*8, allocatable           :: sfparam(:,:), sfval_min(:), sfval_max(:), sfval_avg(:), sfval_cov(:)
+    
+        character(len=1024)           :: file
+        logical                       :: normalized
+        real*8                        :: scale, shift, E_min, E_max, E_avg
+        integer                       :: ntypes, natomtot, nstrucs
+        character(len=2), allocatable :: type_names(:)
+        real*8, allocatable           :: E_atom(:)
+    
+    
+        open(unit = 1, action = "read", status = "old", file = infile, form = "unformatted")
+        open(unit = 2, action = "write", status = "replace", file = outfile)
+    
+    
+        ! Network information
+        read(1) nlayers
+        read(1) nnodesmax
+        read(1) Wsize
+        read(1) nvalues
+    
+        allocate(nnodes(nlayers), fun(nlayers-1), iw(nlayers), iv(nlayers), W(Wsize))
+    
+        read(1) nnodes(:)
+        read(1) fun(:)
+        read(1) iw(:)
+        read(1) iv(:)
+        read(1) W(:)
+    
+    
+        write(2,*) nlayers
+        write(2,*) nnodesmax
+        write(2,*) Wsize
+        write(2,*) nvalues
+        write(2,*) nnodes(:)
+        write(2,*) fun(:)
+        write(2,*) iw(:)
+        write(2,*) iv(:)
+        write(2,*) W(:)
+    
+        deallocate(nnodes, fun, iw, iv, W)
+    
+    
+    
+        ! Structural Fingerprint setup information
+        read(1) description
+        read(1) atomtype
+        read(1) nenv
+    
+        allocate(envtypes(nenv))
+    
+        read(1) envtypes(:)
+        read(1) rc_min
+        read(1) rc_max
+        read(1) sftype
+        read(1) nsf
+        read(1) nsfparam
+    
+        allocate(sf(nsf), sfparam(nsfparam,nsf), sfenv(2,nsf), sfval_min(nsf), &
+                 sfval_max(nsf), sfval_avg(nsf), sfval_cov(nsf))
+    
+        read(1) sf(:)
+        read(1) sfparam(:,:)
+        read(1) sfenv(:,:)
+        read(1) neval
+        read(1) sfval_min
+        read(1) sfval_max
+        read(1) sfval_avg
+        read(1) sfval_cov
+    
+    
+    
+        write(2,*) description
+        write(2,*) atomtype
+        write(2,*) nenv
+        write(2,"(a)") envtypes(:)
+        write(2,*) rc_min
+        write(2,*) rc_max
+        write(2,*) sftype
+        write(2,*) nsf
+        write(2,*) nsfparam
+        write(2,*) sf(:)
+        write(2,*) sfparam(:,:)
+        write(2,*) sfenv(:,:)
+        write(2,*) neval
+        write(2,*) sfval_min
+        write(2,*) sfval_max
+        write(2,*) sfval_avg
+        write(2,*) sfval_cov
+    
+        deallocate(sf, sfparam, sfenv, sfval_min, sfval_max, sfval_avg, sfval_cov)
+    
+    
+    
+        ! Trainset information
+        read(1) file
+        read(1) normalized
+        read(1) scale
+        read(1) shift
+        read(1) ntypes
+    
+        allocate(type_names(ntypes), E_atom(ntypes))
+    
+        read(1) type_names(:)
+        read(1) E_atom(:)
+        read(1) natomtot
+        read(1) nstrucs
+        read(1) E_min, E_max, E_avg
+    
+    
+        write(2,*) file
+        write(2,*) normalized
+        write(2,*) scale
+        write(2,*) shift
+        write(2,*) ntypes
+        write(2,*) type_names(:)
+        write(2,*) E_atom(:)
+        write(2,*) natomtot
+        write(2,*) nstrucs
+        write(2,*) E_min, E_max, E_avg
+    
+        deallocate(type_names, E_atom)
+    
+    
+        close(unit = 1)
+        close(unit = 2)
+    
+    end subroutine bin2ascii
+    
+   end subroutine nnASCII2bin_subroutine
+
+end module aenet_nnASCII2bin
\ No newline at end of file
diff -Naru src/sub_trainbin2ASCII.f90 src_modified/sub_trainbin2ASCII.f90
--- src/sub_trainbin2ASCII.f90	1970-01-01 09:00:00
+++ src_modified/sub_trainbin2ASCII.f90	2024-09-06 10:37:30
@@ -0,0 +1,492 @@
+module aenet_trainbin2ascii
+    implicit none
+    contains 
+
+subroutine trainbin2ascii_subroutine(infile, outfile,to_bin, to_ascii)
+
+implicit none
+
+character(len=*),intent(in)    :: infile, outfile
+logical,intent(in)                :: to_bin, to_ascii
+
+!integer,intent(in)                             :: ionum
+
+!call initialize(infile, outfile, to_bin, to_ascii)
+
+if (to_ascii .and. .not. to_bin) then
+    call bin2ascii(infile, outfile)
+else if (to_bin .and. .not. to_ascii) then
+    call ascii2bin(infile, outfile)
+endif
+
+
+contains
+
+subroutine initialize(infile, outfile, to_bin, to_ascii)
+
+    implicit none
+
+    character(len=*), intent(out) :: infile, outfile
+    integer :: iarg, nargs
+    character(len=100) :: arg
+    logical, intent(out) :: to_bin, to_ascii
+
+    nargs = command_argument_count()
+    if (nargs < 1) then
+       write(0,*) "Error: No input file provided."
+       call finalize()
+       stop
+    end if
+
+    infile = ' '
+    outfile = ' '
+
+    to_bin = .false.
+    to_ascii = .true.
+    
+    iarg = 1
+    do while(iarg <= nargs)
+       call get_command_argument(iarg, value=arg)
+       select case(trim(arg))
+       case('--to-binary')
+          to_bin = .false.
+          to_ascii = .true.
+       case('--to-ascii')
+          to_ascii = .false.
+          to_bin = .true.
+       case default
+          if (len_trim(infile) == 0) then
+             infile = trim(arg)
+          else if (len_trim(outfile) == 0) then
+             outfile = trim(arg)
+          else
+             write(0,*) 'Error: Unknown argument: ', trim(arg)
+             call finalize()
+             stop
+          end if
+       end select
+       iarg = iarg + 1
+    end do
+
+    if ((len(infile) == 0) .or. (len(outfile) == 0))then
+       write(0,*) 'Error: No input file specified.'
+       call finalize()
+       stop
+    end if
+
+end subroutine initialize
+
+  !--------------------------------------------------------------------!
+
+subroutine finalize()
+
+    implicit none
+
+end subroutine finalize
+
+  !--------------------------------------------------------------------!
+
+subroutine ascii2bin(infile, outfile)
+    implicit none
+
+    character(len=*), intent(in)  :: infile, outfile
+
+    integer                       :: ntypestot, nstrucs, istruc
+    real*8                        :: E_scale, E_shift
+    logical                       :: normalized
+    character(len=2), allocatable :: type_names(:)
+    real*8, allocatable           :: E_atom(:)
+
+    integer                       :: length, natoms, ntypes, iatom, itype, jtype, nsf
+    real*8                        :: energy, cooCart(3), forCart(3)
+    character(len=1024)           :: filename
+    real*8, allocatable           :: sfval(:)
+
+    integer                       :: natomtot, nenv, neval, nsfparam
+    real*8                        :: E_avg, E_min, E_max, rc_min, rc_max
+    logical                       :: has_setups
+    character(len=1024)           :: description
+    character(len=2)              :: atomtype
+    character(len=100)            :: sftype
+    character(len=2), allocatable :: envtypes(:)
+    integer, allocatable          :: sf(:), sfenv(:,:)
+    real*8, allocatable           :: sfparam(:,:), sfval_min(:), sfval_max(:), sfval_avg(:), sfval_cov(:)
+
+    !integer,intent(in)                             :: ionum
+
+
+
+    open(unit = 1, action = "read", status = "old", file = infile)
+    open(unit = 2, action = "write", status = "replace", file = outfile, form = "unformatted")
+
+    ! Read header
+    read(1,*) ntypestot
+    read(1,*) nstrucs
+    allocate(type_names(ntypestot), E_atom(ntypestot))
+    read(1,*) type_names(:)
+    read(1,*) E_atom(:)
+    read(1,*) normalized
+    read(1,*) E_scale
+    read(1,*) E_shift
+
+    write(2) ntypestot
+    write(2) nstrucs
+    write(2) type_names(:)
+    write(2) E_atom(:)
+    write(2) normalized
+    write(2) E_scale
+    write(2) E_shift
+
+
+
+
+    ! Read dataset fingerprints
+    do istruc = 1, nstrucs
+        read(1,*) length
+        length = min(length, len(filename))
+        read(1,*) filename(1:length)
+        read(1,*) natoms, ntypes
+        read(1,*) energy
+
+        write(2) length
+        write(2) filename(1:length)
+        write(2) natoms, ntypes
+        write(2) energy
+
+        do iatom = 1, natoms
+            read(1,*) itype
+            read(1,*) cooCart(:)
+            read(1,*) forCart(:)
+            read(1,*) nsf
+            allocate(sfval(nsf))
+            read(1,*) sfval(1:nsf)
+
+            write(2) itype
+            write(2) cooCart(:)
+            write(2) forCart(:)
+            write(2) nsf
+            write(2) sfval(1:nsf)
+
+            deallocate(sfval)
+        enddo
+
+    enddo
+
+    ! Read footer information of the fingerprint setups
+    read(1,*) natomtot
+    read(1,*) E_avg, E_min, E_max
+    read(1,*) has_setups
+
+    write(2) natomtot
+    write(2) E_avg, E_min, E_max
+    write(2) has_setups
+
+    do jtype = 1, ntypestot
+        read(1,*) itype
+        read(1,*) description
+        read(1,*) atomtype
+        read(1,*) nenv
+
+        allocate(envtypes(nenv))
+
+        read(1,*) envtypes(:)
+        read(1,*) rc_min
+        read(1,*) rc_max
+        read(1,*) sftype
+        read(1,*) nsf
+        read(1,*) nsfparam
+
+        allocate(sf(nsf), sfparam(nsfparam,nsf), sfenv(2,nsf), sfval_min(nsf), &
+                 sfval_max(nsf), sfval_avg(nsf), sfval_cov(nsf))
+
+        read(1,*) sf(:)
+        read(1,*) sfparam(:,:)
+        read(1,*) sfenv(:,:)
+        read(1,*) neval
+        read(1,*) sfval_min
+        read(1,*) sfval_max
+        read(1,*) sfval_avg
+        read(1,*) sfval_cov
+
+
+
+        write(2) itype
+        write(2) description
+        write(2) atomtype
+        write(2) nenv
+        write(2,"(a)") envtypes(:)
+        write(2) rc_min
+        write(2) rc_max
+        write(2) sftype
+        write(2) nsf
+        write(2) nsfparam
+        write(2) sf(:)
+        write(2) sfparam(:,:)
+        write(2) sfenv(:,:)
+        write(2) neval
+        write(2) sfval_min
+        write(2) sfval_max
+        write(2) sfval_avg
+        write(2) sfval_cov
+
+        deallocate(sf, sfparam, sfenv, sfval_min, sfval_max, sfval_avg, sfval_cov, envtypes)
+    enddo
+
+    close(unit = 1)
+    close(unit = 2)
+
+end subroutine ascii2bin
+
+  !--------------------------------------------------------------------!
+
+subroutine bin2ascii(infile, outfile)
+    implicit none
+
+    character(len=*), intent(in)  :: infile, outfile
+
+    integer                       :: i, ntypestot, nstrucs, istruc
+    real*8                        :: E_scale, E_shift
+    logical                       :: normalized
+    character(len=2), allocatable :: type_names(:)
+    real*8, allocatable           :: E_atom(:)
+
+    integer                       :: length, natoms, ntypes, iatom, itype, jtype, nsf
+    real*8                        :: energy, cooCart(3), forCart(3)
+    character(len=1024)           :: filename
+    real*8, allocatable           :: sfval(:)
+
+    integer                       :: natomtot, nenv, neval, nsfparam
+    real*8                        :: E_avg, E_min, E_max, rc_min, rc_max
+    logical                       :: has_setups
+    character(len=1024)           :: description
+    character(len=2)              :: atomtype
+    character(len=100)            :: sftype
+    character(len=2), allocatable :: envtypes(:)
+    integer, allocatable          :: sf(:), sfenv(:,:)
+    real*8, allocatable           :: sfparam(:,:), sfval_min(:), sfval_max(:), sfval_avg(:), sfval_cov(:)
+    !integer,intent(in)                             :: ionum
+    integer::num,num1,num2,j
+
+
+
+    open(unit = 1, action = "read", status = "old", file = infile, form = "unformatted")
+    open(unit = 2, action = "write", status = "replace", file = outfile)
+
+    ! Read header
+    read(1) ntypestot
+    read(1) nstrucs
+    allocate(type_names(ntypestot), E_atom(ntypestot))
+    read(1) type_names(:)
+    read(1) E_atom(:)
+    read(1) normalized
+    read(1) E_scale
+    read(1) E_shift
+
+    write(2,*) ntypestot
+    write(2,*) nstrucs
+    write(2,"(100a4)") type_names(:)
+    write(2,*) E_atom(:)
+    write(2,*) normalized
+    write(2,*) E_scale
+    write(2,*) E_shift
+
+    close(unit=1)
+
+
+    ! Read footer information of the fingerprint setups
+    open(unit = 1, action = "read", status = "old", file = infile, form = "unformatted")
+
+    do i = 1, 7
+        read(1)
+    enddo
+    do istruc = 1, nstrucs
+        read(1) 
+        read(1) 
+        read(1) natoms, ntypes
+        read(1)
+
+        do iatom = 1, natoms
+            read(1) 
+            read(1) 
+            read(1) 
+            read(1) 
+            read(1) 
+        enddo
+
+    enddo
+
+
+    read(1) natomtot
+    read(1) E_avg, E_min, E_max
+    read(1) has_setups
+
+    write(2,*) natomtot
+    write(2,*) E_avg, E_min, E_max
+    write(2,*) has_setups
+
+    do jtype = 1, ntypestot
+        read(1) itype
+        read(1) description
+        read(1) atomtype
+        read(1) nenv
+
+        allocate(envtypes(nenv))
+
+        read(1) envtypes(:)
+        read(1) rc_min
+        read(1) rc_max
+        read(1) sftype
+        read(1) nsf
+        read(1) nsfparam
+
+        allocate(sf(nsf), sfparam(nsfparam,nsf), sfenv(2,nsf), sfval_min(nsf), &
+                 sfval_max(nsf), sfval_avg(nsf), sfval_cov(nsf))
+        
+        read(1) sf(:)
+        read(1) sfparam(:,:)
+        read(1) sfenv(:,:)
+        read(1) neval
+        read(1) sfval_min
+        read(1) sfval_max
+        read(1) sfval_avg
+        read(1) sfval_cov
+
+
+
+        write(2,*) itype
+        write(2,"(a)") description
+        write(2,"(a)") atomtype
+        write(2,*) nenv
+        write(2,"(a)") envtypes(:)
+        write(2,*) rc_min
+        write(2,*) rc_max
+        write(2,"(a)") sftype
+        write(2,*) nsf
+        write(2,*) nsfparam
+        num = ubound(sf,1)
+        do i=1,num
+            write(2,"(i6)",ADVANCE='NO') sf(i)
+        end do
+        write(2,*)
+        num1 = ubound(sfparam,1)
+        num2 = ubound(sfparam,2)
+        do j=1,num2
+            do i=1,num1
+                write(2,"(e20.10)",ADVANCE='NO') sfparam(i,j)
+            end do
+        end do
+        write(2,*)
+        !write(2,*) sf(:)
+        !write(2,*) sfparam(:,:)
+        num1 = ubound(sfenv,1)
+        num2 = ubound(sfenv,2)
+        do j=1,num2
+            do i=1,num1
+                write(2,"(i6)",ADVANCE='NO') sfenv(i,j)
+            end do
+        end do
+        write(2,*)
+        !write(2,*) sfenv(:,:)
+        write(2,*) neval
+        
+        num = ubound(sfval_min,1)
+        do i=1,num
+            write(2,"(g20.10)",ADVANCE='NO') sfval_min(i)
+        end do
+        write(2,*)
+        do i=1,num
+            write(2,"(g20.10)",ADVANCE='NO') sfval_max(i)
+        end do
+        write(2,*)
+        do i=1,num
+            write(2,"(g20.10)",ADVANCE='NO') sfval_avg(i)
+        end do
+        write(2,*)
+        do i=1,num
+            write(2,"(g20.10)",ADVANCE='NO') sfval_cov(i)
+        end do
+        write(2,*)
+        
+        !write(2,*) sfval_min
+        !write(2,*) sfval_max
+        !write(2,*) sfval_avg
+        !write(2,*) sfval_cov
+
+        deallocate(sf, sfparam, sfenv, sfval_min, sfval_max, sfval_avg, sfval_cov, envtypes)
+    enddo
+
+    close(unit = 1)
+
+
+    ! Read dataset fingerprints
+    open(unit = 1, action = "read", status = "old", file = infile, form = "unformatted")
+
+    do i = 1, 7
+        read(1)
+    enddo
+
+    do istruc = 1, nstrucs
+        read(1) length
+        length = min(length, len(filename))
+        read(1) filename(1:length)
+        read(1) natoms, ntypes
+        read(1) energy
+
+        write(2,*) length
+        write(2,*) filename(1:length)
+        write(2,*) natoms, ntypes
+        write(2,*) energy
+
+        do iatom = 1, natoms
+            read(1) itype
+            read(1) cooCart(:)
+            read(1) forCart(:)
+            read(1) nsf
+            allocate(sfval(nsf))
+            read(1) sfval(1:nsf)
+
+            write(2,*) itype
+            write(2,*) cooCart(:)
+            write(2,*) forCart(:)
+            write(2,*) nsf
+                    
+            do i=1,nsf
+                write(2,"(g20.10)",ADVANCE='NO') sfval(i)
+            end do
+            write(2,*)
+
+            !write(2,*) sfval(1:nsf)
+
+            deallocate(sfval)
+        enddo
+
+    enddo
+
+    close(unit = 1)
+
+
+
+    close(unit = 2)
+
+end subroutine bin2ascii
+
+subroutine normalize_sfval(nsf, sfval_avg, sfval_cov, sfval)
+    implicit none
+    integer, intent(in)   :: nsf
+    real*8, intent(in)    :: sfval_avg(:), sfval_cov(:)
+    real*8, intent(inout) :: sfval(:)
+
+    integer               :: isf
+    real*8                :: shift, scale
+
+    do isf = 1, nsf
+        shift = sfval_avg(isf)
+        scale = 1.0d0/sqrt(sfval_cov(isf) - shift**2)
+        sfval(isf) = ( sfval(isf) -shift )*scale
+    enddo
+
+end subroutine normalize_sfval
+
+end subroutine trainbin2ascii_subroutine
+
+end module 
\ No newline at end of file
diff -Naru src/trainbin2ASCII_modified.f90 src_modified/trainbin2ASCII_modified.f90
--- src/trainbin2ASCII_modified.f90	1970-01-01 09:00:00
+++ src_modified/trainbin2ASCII_modified.f90	2024-09-06 10:37:30
@@ -0,0 +1,72 @@
+program trainbin2ASCII_modified
+    use aenet_trainbin2ascii
+    implicit none
+
+    character(len=1024) :: infile, outfile
+    logical             :: to_bin, to_ascii
+
+    call initialize(infile, outfile, to_bin, to_ascii)
+    call trainbin2ascii_subroutine(infile, outfile,to_bin, to_ascii)
+
+    contains 
+
+    subroutine initialize(infile, outfile, to_bin, to_ascii)
+
+        implicit none
+    
+        character(len=*), intent(out) :: infile, outfile
+        integer :: iarg, nargs
+        character(len=100) :: arg
+        logical, intent(out) :: to_bin, to_ascii
+    
+        nargs = command_argument_count()
+        if (nargs < 1) then
+           write(0,*) "Error: No input file provided."
+           call finalize()
+           stop
+        end if
+    
+        infile = ' '
+        outfile = ' '
+    
+        to_bin = .false.
+        to_ascii = .true.
+        
+        iarg = 1
+        do while(iarg <= nargs)
+           call get_command_argument(iarg, value=arg)
+           select case(trim(arg))
+           case('--to-binary')
+              to_bin = .false.
+              to_ascii = .true.
+           case('--to-ascii')
+              to_ascii = .false.
+              to_bin = .true.
+           case default
+              if (len_trim(infile) == 0) then
+                 infile = trim(arg)
+              else if (len_trim(outfile) == 0) then
+                 outfile = trim(arg)
+              else
+                 write(0,*) 'Error: Unknown argument: ', trim(arg)
+                 call finalize()
+                 stop
+              end if
+           end select
+           iarg = iarg + 1
+        end do
+    
+        if ((len(infile) == 0) .or. (len(outfile) == 0))then
+           write(0,*) 'Error: No input file specified.'
+           call finalize()
+           stop
+        end if
+    
+    end subroutine initialize
+
+    subroutine finalize()
+
+        implicit none
+    
+    end subroutine finalize
+end program
\ No newline at end of file
diff -Naru src/trainset_MPI.f90 src_modified/trainset_MPI.f90
--- src/trainset_MPI.f90	1970-01-01 09:00:00
+++ src_modified/trainset_MPI.f90	2024-09-06 10:37:30
@@ -0,0 +1,543 @@
+!-----------------------------------------------------------------------
+!           trainset.f90 - handling of the training set file
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!-----------------------------------------------------------------------
+! 2013-05-09 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+module trainset_MPI
+
+  use aeio,    only: aeio_header,           &
+                     TYPELEN, PATHLEN
+
+  use io,      only: io_adjustl,            &
+                     io_unit
+
+  use sfsetup, only: Setup,                 &
+                     save_Setup,            &
+                     load_Setup,            &
+                     del_Setup,             &
+                     stp_init,              &
+                     stp_final,             &
+                     stp_normalize,         &
+                     stp_assert_moduleinit, &
+                     stp_nsf_max
+
+  use trainset, only: TrnSet
+
+  use parallel,    only: pp_init,                &
+                         pp_final,               &
+                         pp_bcast,               &
+                         pp_barrier,             &
+                         ppMaster,               &
+                         ppRank,                 &
+                         ppSize,&
+                         pp_calc_and_bcast_footer
+
+  implicit none
+  private
+  save
+
+  public  :: new_TrnSet_MPI,          &
+             close_TrnSet_MPI,        &
+             save_TrnSet_info_MPI,    &
+             ts_write_atom_info_MPI,  &
+             ts_write_header_MPI,     &
+             ts_write_sf_info_MPI,    &
+             ts_write_structure_info_MPI, &
+             ts_write_footer_MPI,     &
+             ts_parallel_footer_MPI,   &
+             ts_loadandwrite_structure_info_MPI
+
+  private :: ts_assert_init,          &
+             ts_assert_writemode,     &
+             ts_assert_readmode
+
+  !--------------------------------------------------------------------!
+  ! Basis function values and derivatives may be read and written      !
+  ! either using a basis function setup [type(Setup)] or directly into !
+  ! double precision arrays of the correct dimensions.                 !
+  !--------------------------------------------------------------------!
+
+contains
+
+  function new_TrnSet_MPI(nTypes, typeName, E_atom, nStrucs, file, scale, &
+                      shift) result(ts)
+
+    implicit none
+
+    integer,                             intent(in) :: nTypes
+    character(len=*), dimension(nTypes), intent(in) :: typeName
+    double precision, dimension(nTypes), intent(in) :: E_atom
+    integer,                             intent(in) :: nStrucs
+    character(len=*),                    intent(in) :: file
+    double precision, optional,          intent(in) :: scale
+    double precision, optional,          intent(in) :: shift
+    type(TrnSet)                                    :: ts
+
+    logical :: fexists
+
+!    if (ppMaster) then
+!       inquire(file=trim(adjustl(file)), exist=fexists)
+!       if (fexists) then
+!          write(0,*) 'Error: file already exists: ', trim(adjustl(file))
+!          stop
+!       end if
+!    end if
+
+    allocate(ts%typeName(nTypes), ts%E_atom(nTypes))
+
+    ts%file               = trim(adjustl(file))
+    ts%nTypes             = nTypes
+    ts%typeName(1:nTypes) = typeName(1:nTypes)
+    ts%E_atom(1:nTypes)   = E_atom(1:nTypes)
+    ts%nStrucs            = nStrucs
+    ts%iStruc             = 0
+    if (present(scale) .and. present(shift)) then
+       ts%normalized = .true.
+       ts%scale = scale
+       ts%shift = shift
+    else
+       ts%normalized = .false.
+       ts%scale = 1.0d0
+       ts%shift = 0.0d0
+    end if
+
+    ts%unit   = io_unit()
+!    open(ts%unit, file=trim(ts%file), status='new', action='write', &
+!         form='unformatted')
+
+    ts%nAtomsTot = 0
+
+    ts%mode = 'write'
+    ts%init = .true.
+
+    call ts_write_header_MPI(ts)
+
+  end function new_TrnSet_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine close_TrnSet_MPI(ts, stp, status)
+
+    implicit none
+
+    type(TrnSet),                        intent(inout) :: ts
+    type(Setup), dimension(:), optional, intent(in)    :: stp
+    character(len=*),          optional, intent(in)    :: status
+
+    if (.not. ts%init) return
+
+    if (trim(ts%mode) == 'write') then
+       if (present(stp)) then
+          call ts_write_footer_MPI(ts, stp=stp)
+       else
+          call ts_write_footer_MPI(ts)
+       end if
+    end if
+
+    if ((trim(ts%mode)=='read') .or. (trim(ts%mode)=='write')) then
+       if (present(status)) then
+          close(ts%unit, status=trim(status))
+       else
+          close(ts%unit)
+       end if
+    end if
+
+    deallocate(ts%typeName, ts%E_atom)
+    ts%init   = .false.
+
+  end subroutine close_TrnSet_MPI
+
+  !--------------------------------------------------------------------!
+  !              only training set info - no actual data               !
+  !--------------------------------------------------------------------!
+
+  subroutine save_TrnSet_info_MPI(ts, file, unit)
+
+    implicit none
+
+    type(TrnSet),               intent(in) :: ts
+    character(len=*), optional, intent(in) :: file
+    integer,          optional, intent(in) :: unit
+
+    integer :: u
+
+    call ts_assert_init(ts)
+    call ts_assert_readmode(ts)
+
+    if (present(unit)) then
+       u = unit
+    else if (present(file)) then
+       u = io_unit()
+       open(u, file=trim(file), status='replace', &
+            form='unformatted', action='write')
+    else
+       write(0,*) "Error: neither unit nor file specified in `save_TrnSet_info()'."
+       stop
+    end if
+
+    write(u) ts%file
+    write(u) ts%normalized
+    write(u) ts%scale
+    write(u) ts%shift
+    write(u) ts%nTypes
+    write(u) ts%typeName(1:ts%nTypes)
+    write(u) ts%E_atom(1:ts%nTypes)
+    write(u) ts%nAtomsTot
+    write(u) ts%nStrucs
+    write(u) ts%E_min, ts%E_max, ts%E_av
+
+    if (.not. present(unit)) close(u)
+
+  end subroutine save_TrnSet_info_MPI
+
+  !--------------------------------------------------------------------!
+
+  function new_TrnSet_info_MPI(nTypes) result(ts)
+
+    implicit none
+
+    integer,                             intent(in) :: nTypes
+    type(TrnSet)                                    :: ts
+
+    allocate(ts%typeName(nTypes), ts%E_atom(nTypes))
+
+    ts%nTypes     = nTypes
+    ts%normalized = .false.
+    ts%scale      = 1.0d0
+    ts%shift      = 1.0d0
+    ts%file       = ''
+    ts%unit       = -1
+    ts%nAtomsTot  = 0
+    ts%nStrucs    = 0
+    ts%iStruc     = 0
+
+    ts%init = .true.
+    ts%mode = 'info'
+
+  end function new_TrnSet_info_MPI
+
+  !--------------------------------------------------------------------!
+  !                      training set file header                      !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_header_MPI(ts)
+
+    implicit none
+
+    type(TrnSet), intent(inout) :: ts
+    integer :: ts_unit = 1234
+    integer :: ts_unitall = 12345
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    if (ppMaster) then
+       open (ts_unit, file='ts.header', form='unformatted', position='append')
+       write(ts_unit) ts%nTypes
+       write(ts_unit) ts%nStrucs
+       write(ts_unit) ts%typeName(:)
+       write(ts_unit) ts%E_atom(:)
+       write(ts_unit) ts%normalized
+       write(ts_unit) ts%scale
+       write(ts_unit) ts%shift
+       close(ts_unit)
+
+       open (ts_unitall, file='ts.all', form='unformatted', status='replace')
+       write(ts_unitall) ts%nTypes
+       write(ts_unitall) ts%nStrucs
+       write(ts_unitall) ts%typeName(:)
+       write(ts_unitall) ts%E_atom(:)
+       write(ts_unitall) ts%normalized
+       write(ts_unitall) ts%scale
+       write(ts_unitall) ts%shift
+       close(ts_unitall)
+    end if
+
+  end subroutine ts_write_header_MPI
+
+  !--------------------------------------------------------------------!
+  !           training set file footer containing statistics           !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_parallel_footer_MPI(ts, stp)
+
+    implicit none
+
+    type(TrnSet),                        intent(inout) :: ts
+    type(Setup), dimension(:), intent(inout) :: stp
+
+   call pp_calc_and_bcast_footer(ts,stp)
+
+  end subroutine ts_parallel_footer_MPI
+
+  subroutine ts_write_footer_MPI(ts, stp)
+
+    implicit none
+
+    type(TrnSet),                        intent(inout) :: ts
+    type(Setup), dimension(:), optional, intent(in) :: stp
+
+    integer :: itype, nTypes
+    logical :: has_setups
+    integer :: ts_unit = 1234
+    integer :: ts_unitall = 12345
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    if (ppMaster) then
+
+       open (ts_unit, file='ts.footer', form='unformatted', position='append')
+       open (ts_unitall, file='ts.all', form='unformatted', position='append')
+
+       write(ts_unit) ts%nAtomsTot
+       write(ts_unitall) ts%nAtomsTot
+       write(ts_unit) ts%E_av, ts%E_min, ts%E_max
+       write(ts_unitall) ts%E_av, ts%E_min, ts%E_max
+!       write(5678,*) ts%nAtomsTot
+!       write(5678,*) ts%E_av, ts%E_min, ts%E_max
+!
+       if (present(stp)) then
+          nTypes = size(stp(:))
+          if (nTypes /= ts%nTypes) then
+             write(0,*) "Error: wrong size of array stp in `ts_read_footer()'."
+             stop
+          end if
+          has_setups = .true.
+          write(ts_unit) has_setups
+          write(ts_unitall) has_setups
+!          write(5678,*) has_setups
+          do itype = 1, ts%nTypes
+             write(ts_unit) itype
+             write(ts_unitall) itype
+!             write(5678,*) itype
+             call save_Setup(stp(itype), unit=ts_unit)
+             call save_Setup(stp(itype), unit=ts_unitall)
+          end do
+       else
+          has_setups = .false.
+!          write(5678,*) has_setups
+          write(ts_unit) has_setups
+          write(ts_unitall) has_setups
+       end if
+
+       close(ts_unit)
+       close(ts_unitall)
+
+    end if
+
+  end subroutine ts_write_footer_MPI
+
+  subroutine ts_loadandwrite_structure_info_MPI(ifile)
+
+   implicit none
+
+   integer:: nAtoms
+   integer:: nTypes
+   double precision:: energy
+   integer,          intent(in)    :: ifile
+   integer :: ts_unit = 1234
+   integer :: ts_unitall = 12345
+   character(len=100)::filenameload
+   integer::iatom
+   integer::itype
+   double precision, dimension(3):: cooCart
+   double precision, dimension(3):: forCart
+
+   integer:: nsf
+   double precision, dimension(:),allocatable:: sfval
+
+   double precision :: E_atom
+   integer::l
+
+
+   open (ts_unitall, file='ts.all', form='unformatted', position='append')
+   open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', status='old')
+
+   read(ts_unit) l
+   filenameload = " "
+   l = min(l,len(filenameload))
+   read(ts_unit) filenameload(1:l)
+
+   write(ts_unitall) len_trim(filenameload)
+   write(ts_unitall) trim(filenameload)
+
+
+
+   read(ts_unit) nAtoms, nTypes
+   write(ts_unitall) nAtoms, nTypes
+
+   read(ts_unit) energy
+   write(ts_unitall) energy
+
+   atoms : do iatom = 1, nAtoms
+
+      read(ts_unit) itype
+      write(ts_unitall) itype
+
+      read(ts_unit) cooCart(1:3)
+      write(ts_unitall) cooCart(1:3)
+      read(ts_unit) forCart(1:3)
+      write(ts_unitall) forCart(1:3)
+
+      read(ts_unit) nsf
+      write(ts_unitall) nsf
+      allocate(sfval(1:nsf))
+
+      read(ts_unit) sfval(1:nsf)
+      write(ts_unitall) sfval(1:nsf)
+      deallocate(sfval)
+
+   end do atoms
+
+   close(ts_unit)
+   close(ts_unitall)
+
+
+ end subroutine ts_loadandwrite_structure_info_MPI
+
+  !--------------------------------------------------------------------!
+  !              data from structures in the training set              !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_structure_info_MPI(ts, filename, nAtoms, nTypes, energy, ifile)
+
+    implicit none
+
+    type(TrnSet),     intent(inout) :: ts
+    character(len=*), intent(in)    :: filename
+    integer,          intent(in)    :: nAtoms
+    integer,          intent(in)    :: nTypes
+    double precision, intent(in)    :: energy
+    integer,          intent(in)    :: ifile
+    integer :: ts_unit = 1234
+
+    double precision :: E_atom
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    if (ts%iStruc >= ts%nStrucs) then
+       write(0,*) "Error: too many files for training set."
+       stop
+    else
+       ts%iStruc = ts%iStruc + 1
+    end if
+
+    open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', position='append')
+    write(ts_unit) len_trim(filename)
+    write(ts_unit) trim(filename)
+    write(ts_unit) nAtoms, nTypes
+    write(ts_unit) energy
+    close(ts_unit)
+
+    ! energy stats
+    E_atom = energy/dble(nAtoms)
+    if (ts%iStruc > 1) then
+       ts%E_min = min(ts%E_min, E_atom)
+       ts%E_max = max(ts%E_max, E_atom)
+       ts%E_av  = ts%E_av + E_atom/dble(ts%nStrucs)
+    else
+       ts%E_min = E_atom
+       ts%E_max = E_atom
+       ts%E_av  = E_atom/dble(ts%nStrucs)
+    end if
+
+    ! keep track of the atoms in the training set
+    ts%nAtomsTot = ts%nAtomsTot + nAtoms
+
+  end subroutine ts_write_structure_info_MPI
+
+
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_atom_info_MPI(ts, itype, cooCart, forCart, ifile)
+
+    implicit none
+
+    type(TrnSet),                   intent(inout) :: ts
+    integer,                        intent(in)    :: itype
+    double precision, dimension(3), intent(in)    :: cooCart
+    double precision, dimension(3), intent(in)    :: forCart
+    integer,          intent(in)    :: ifile
+    integer :: ts_unit = 1234
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', position='append')
+    write(ts_unit) itype
+    write(ts_unit) cooCart(1:3)
+    write(ts_unit) forCart(1:3)
+    close(ts_unit)
+
+  end subroutine ts_write_atom_info_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_sf_info_MPI(ts, nsf, sfval, ifile)
+
+    implicit none
+
+    type(TrnSet),                       intent(inout) :: ts
+    integer,                            intent(in)    :: nsf
+    double precision, dimension(nsf),   intent(in)    :: sfval
+    integer,          intent(in)    :: ifile
+    integer :: ts_unit = 1234
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', position='append')
+    write(ts_unit) nsf
+    write(ts_unit) sfval(1:nsf)
+    close(ts_unit)
+
+  end subroutine ts_write_sf_info_MPI
+
+  !--------------------------------------------------------------------!
+  !                            state checks                            !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_assert_init(ts)
+    implicit none
+    type(TrnSet), intent(in) :: ts
+    if (.not. ts%init) then
+       write(0,*) "Error: training set not initialized."
+       stop
+    end if
+  end subroutine ts_assert_init
+
+  subroutine ts_assert_writemode(ts)
+    implicit none
+    type(TrnSet), intent(in) :: ts
+    if (trim(ts%mode) /= 'write') then
+       write(0,*) "Error: training set not in 'write' mode."
+       stop
+    end if
+  end subroutine ts_assert_writemode
+
+  subroutine ts_assert_readmode(ts)
+    implicit none
+    type(TrnSet), intent(in) :: ts
+    if (trim(ts%mode) /= 'read') then
+       write(0,*) "Error: training set not in 'read' mode."
+       stop
+    end if
+  end subroutine ts_assert_readmode
+
+end module trainset_MPI
