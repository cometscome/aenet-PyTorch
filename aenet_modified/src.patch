diff -Naru src/Makefile.inc src_modified/Makefile.inc
--- src/Makefile.inc	2024-09-06 10:37:30
+++ src_modified/Makefile.inc	2024-09-06 10:37:30
@@ -33,15 +33,17 @@
 
 OBJECTS  = aenet.o aeio.o chebyshev.o constants.o feedforward.o geometry.o \
            input.o io.o lclist.o optimize.o parallel.o potential.o random.o \
-           sfbasis.o sfsetup.o sortlib.o symmfunc.o timing.o trainset.o \
-	   xsflib.o pytorchoutput.o
+           sfbasis.o sfsetup.o sortlib.o symmfunc.o timing.o trainset.o trainset_MPI.o \
+	   xsflib.o pytorchoutput.o sub_generate.o sub_trainbin2ASCII.o sub_nnASCII2bin.o pytorchoutput_MPI.o \
+	   sub_generate_MPI.o
 
 PICOBJECTS  = aenet_pic.o aeio_pic.o chebyshev_pic.o constants_pic.o \
               feedforward_pic.o geometry_pic.o input_pic.o io_pic.o \
               lclist_pic.o optimize_pic.o parallel_pic.o potential_pic.o \
               random_pic.o sfbasis_pic.o sfsetup_pic.o sortlib_pic.o \
-              symmfunc_pic.o timing_pic.o trainset_pic.o xsflib_pic.o \
-	      pytorchoutput_pic.o
+              symmfunc_pic.o timing_pic.o trainset_pic.o xsflib_pic.o trainset_MPI_pic.o \
+	      pytorchoutput_pic.o sub_generate_pic.o sub_trainbin2ASCII_pic.o sub_nnASCII2bin_pic.o pytorchoutput_MPI_pic.o \
+		  sub_generate_MPI_pic.o
 
 #------------------------------ targets -------------------------------#
 
@@ -51,7 +53,9 @@
 TARGET1  = $(BIN)generate.x
 TARGET2  = $(BIN)train.x
 TARGET3  = $(BIN)predict.x
-TARGETS  = $(TARGET1) $(TARGET2) $(TARGET3)
+TARGET1_mpi  = $(BIN)generate_MPI.x
+TARGET_train = $(BIN)trainbin2ASCII_modified.x
+TARGETS  = $(TARGET1) $(TARGET2) $(TARGET3) $(TARGET1_mpi) $(TARGET_train)
 
 #----------------------------- versioning -----------------------------#
 
@@ -135,4 +139,8 @@
 sfbasis.o     : io.o chebyshev.o
 sfsetup.o     : aeio.o io.o sfbasis.o symmfunc.o
 trainset.o    : aeio.o io.o sfsetup.o
+trainset_MPI.o    : aeio.o io.o sfsetup.o parallel.o
 xsflib.o      : io.o
+pytorchoutput_MPI.o : io.o
+sub_generate.o :aeio.o chebyshev.o geometry.o io.o lclist.o potential.o sfbasis.o sfsetup.o timing.o sub_trainbin2ASCII.o
+trainbin2ASCII_modified.o: sub_trainbin2ASCII.o
\ No newline at end of file
diff -Naru src/aenet.f90 src_modified/aenet.f90
--- src/aenet.f90	2024-09-06 10:37:30
+++ src_modified/aenet.f90	2024-09-06 10:37:30
@@ -74,7 +74,12 @@
 
   use timing,      only: tng_timing, tng_timing2
 
-  implicit none
+ implicit none
+  interface 
+   module subroutine generate_subroutine()
+   end
+  end interface
+
   private
   save
 
@@ -93,7 +98,8 @@
             aenet_sfb_init,                 &
             aenet_sfb_final,                &
             aenet_sfb_eval,                 &
-            aenet_sfb_reconstruct_radial
+            aenet_sfb_reconstruct_radial,    &
+            aenet_atomic_energy_and_forces_novirial
 
   !---------------------------- constants -----------------------------!
 
@@ -407,10 +413,48 @@
 
   end subroutine aenet_atomic_energy
 
+  subroutine aenet_memory_allocation(dE_dG,sfval,sfderiv_i, &
+                        sfderiv_j, &
+                        values, &
+                        derivs, &
+                        jacobian,nvalues,nweights,stat,ok)
+      implicit none
+      double precision, dimension(:),     allocatable,intent(out) :: sfval
+      double precision, dimension(:,:),   allocatable,intent(out)  :: sfderiv_i
+      double precision, dimension(:,:,:), allocatable,intent(out)  :: sfderiv_j
+      double precision, dimension(:),     allocatable,intent(out)  :: values
+      double precision, dimension(:),     allocatable,intent(out)  :: derivs
+      double precision, dimension(:),     allocatable,intent(out)  :: jacobian
+      double precision, dimension(:),     allocatable,intent(out)  :: dE_dG   
+      integer,intent(in) ::nvalues,nweights
+      integer(kind=c_int),                      intent(out)   :: stat
+      integer,intent(out)                                         :: ok
+      
+                                       
+      allocate(dE_dG(aenet_nsf_max),        &
+         sfval(aenet_nsf_max),        &
+         sfderiv_i(3, aenet_nsf_max), &
+         sfderiv_j(3, aenet_nsf_max, aenet_nnb_max), &
+         values(nvalues), &
+         derivs(nvalues), &
+         jacobian(nweights), stat=ok)
+
+      !if (ok /= 0) then
+      !!   stat = AENET_ERR_MALLOC
+      !   return
+      !end if
+      !sfval(:) = 0.0d0
+      !sfderiv_i(:,:) = 0.0d0
+      !sfderiv_j(:,:,:) = 0.0d0
+
+      
+  end subroutine
+
+
   subroutine aenet_atomic_energy_and_forces( &
        coo_i, type_i, index_i, n_j, coo_j, type_j, index_j, natoms, &
-       E_i, F, stat) bind(C)
-
+       E_i, F, S, stat) bind(C)
+    !coo_i, type_i, iatom, nnb, nbcoo, nbtype, nblist, nAtoms, E_i, forCart, stat
     implicit none
 
     real(kind=c_double), dimension(3),        intent(in)    :: coo_i
@@ -423,6 +467,7 @@
     integer(kind=c_int), value,               intent(in)    :: natoms
     real(kind=c_double),                      intent(out)   :: E_i
     real(kind=c_double), dimension(3,natoms), intent(inout) :: F
+    real(kind=c_double), dimension(3,3), intent(inout) :: S
     integer(kind=c_int),                      intent(out)   :: stat
 
     double precision, dimension(1)                  :: E_i_arr
@@ -436,7 +481,9 @@
     integer                                         :: nsf, j
     double precision, dimension(:),     allocatable :: dE_dG
     integer                                         :: ok
+    integer                                         :: x1,x2,d
 
+    
     stat = AENET_OK
     if (.not. (aenet_is_init .and. aenet_is_loaded)) then
        stat = aenet_ERR_INIT
@@ -445,6 +492,13 @@
 
     nvalues = aenet_pot(type_i)%net%nvalues
     nweights = aenet_pot(type_i)%net%Wsize
+
+    !call  aenet_memory_allocation(dE_dG,sfval,sfderiv_i, &
+    !     sfderiv_j, &
+    !     values, &
+    !     derivs, &
+    !     jacobian,nvalues,nweights,stat,ok)
+
     allocate(dE_dG(aenet_nsf_max),        &
              sfval(aenet_nsf_max),        &
              sfderiv_i(3, aenet_nsf_max), &
@@ -452,11 +506,119 @@
              values(nvalues), &
              derivs(nvalues), &
              jacobian(nweights), stat=ok)
+    
+   if (ok /= 0) then
+       stat = AENET_ERR_MALLOC
+       return
+   end if
+    sfval(:) = 0.0d0
+    !sfderiv_i(:,:) = 0.0d0
+    !sfderiv_j(:,:,:) = 0.0d0
+
+    nsf = aenet_pot(type_i)%stp%nsf
+    call stp_eval(type_i, coo_i, n_j, coo_j, type_j, &
+                  aenet_pot(type_i)%stp, sfval=sfval, &
+                  sfderiv_i=sfderiv_i, sfderiv_j=sfderiv_j, scaled=.true.)
+
+    call ff_eval(aenet_pot(type_i)%net, nsf, sfval, 1, values, derivs, E_i_arr)
+    call ff_deriv(aenet_pot(type_i)%net, nsf, 1, derivs, jacobian, dE_dG(1:nsf))
+
+    E_i = aenet_pot(type_i)%E_scale*E_i_arr(1) + aenet_pot(type_i)%E_shift
+    E_i = E_i + aenet_pot(type_i)%E_atom
+
+    F(1:3, index_i) = F(1:3, index_i) - aenet_pot(type_i)%E_scale &
+                    * matmul(sfderiv_i(1:3,1:nsf), dE_dG(1:nsf))
+
+    do j = 1, n_j
+       F(1:3, index_j(j)) = F(1:3, index_j(j)) - aenet_pot(type_i)%E_scale &
+                          * matmul(sfderiv_j(1:3,1:nsf,j), dE_dG(1:nsf))
+    end do
+
+    !stress tensor
+    do x1=1,3
+       do x2 = x1,3
+          do j =1, n_j
+             do d = 1, nsf
+                S(x2,x1) = S(x2,x1) + (coo_i(x2)-coo_j(x2,j))*aenet_pot(type_i)%E_scale&
+                     * sfderiv_j(x1,d,j)*dE_dG(d)
+             end do
+          end do
+       end do
+    end do
+
+
+    deallocate(dE_dG, sfval, sfderiv_i, sfderiv_j, &
+               values, derivs, jacobian, stat=ok)
     if (ok /= 0) then
        stat = AENET_ERR_MALLOC
        return
     end if
 
+  end subroutine aenet_atomic_energy_and_forces
+
+ subroutine aenet_atomic_energy_and_forces_novirial( &
+       coo_i, type_i, index_i, n_j, coo_j, type_j, index_j, natoms, &
+       E_i, F, stat) bind(C)
+    !coo_i, type_i, iatom, nnb, nbcoo, nbtype, nblist, nAtoms, E_i, forCart, stat
+    implicit none
+
+    real(kind=c_double), dimension(3),        intent(in)    :: coo_i
+    integer(kind=c_int), value,               intent(in)    :: type_i
+    integer(kind=c_int), value,               intent(in)    :: index_i
+    integer(kind=c_int), value,               intent(in)    :: n_j
+    real(kind=c_double), dimension(3,n_j),    intent(in)    :: coo_j
+    integer(kind=c_int), dimension(n_j),      intent(in)    :: type_j
+    integer(kind=c_int), dimension(n_j),      intent(in)    :: index_j
+    integer(kind=c_int), value,               intent(in)    :: natoms
+    real(kind=c_double),                      intent(out)   :: E_i
+    real(kind=c_double), dimension(3,natoms), intent(inout) :: F
+    integer(kind=c_int),                      intent(out)   :: stat
+
+    double precision, dimension(1)                  :: E_i_arr
+    double precision, dimension(:),     allocatable :: sfval
+    double precision, dimension(:,:),   allocatable :: sfderiv_i
+    double precision, dimension(:,:,:), allocatable :: sfderiv_j
+    double precision, dimension(:),     allocatable :: values
+    double precision, dimension(:),     allocatable :: derivs
+    double precision, dimension(:),     allocatable :: jacobian
+    integer                                         :: nvalues, nweights
+    integer                                         :: nsf, j
+    double precision, dimension(:),     allocatable :: dE_dG
+    integer                                         :: ok
+    integer                                         :: x1,x2,d
+
+    
+    stat = AENET_OK
+    if (.not. (aenet_is_init .and. aenet_is_loaded)) then
+       stat = aenet_ERR_INIT
+       return
+    end if
+
+    nvalues = aenet_pot(type_i)%net%nvalues
+    nweights = aenet_pot(type_i)%net%Wsize
+
+    !call  aenet_memory_allocation(dE_dG,sfval,sfderiv_i, &
+    !     sfderiv_j, &
+    !     values, &
+    !     derivs, &
+    !     jacobian,nvalues,nweights,stat,ok)
+
+    allocate(dE_dG(aenet_nsf_max),        &
+             sfval(aenet_nsf_max),        &
+             sfderiv_i(3, aenet_nsf_max), &
+             sfderiv_j(3, aenet_nsf_max, aenet_nnb_max), &
+             values(nvalues), &
+             derivs(nvalues), &
+             jacobian(nweights), stat=ok)
+    
+   if (ok /= 0) then
+       stat = AENET_ERR_MALLOC
+       return
+   end if
+    sfval(:) = 0.0d0
+    !sfderiv_i(:,:) = 0.0d0
+    !sfderiv_j(:,:,:) = 0.0d0
+
     nsf = aenet_pot(type_i)%stp%nsf
     call stp_eval(type_i, coo_i, n_j, coo_j, type_j, &
                   aenet_pot(type_i)%stp, sfval=sfval, &
@@ -476,6 +638,7 @@
                           * matmul(sfderiv_j(1:3,1:nsf,j), dE_dG(1:nsf))
     end do
 
+
     deallocate(dE_dG, sfval, sfderiv_i, sfderiv_j, &
                values, derivs, jacobian, stat=ok)
     if (ok /= 0) then
@@ -483,7 +646,8 @@
        return
     end if
 
-  end subroutine aenet_atomic_energy_and_forces
+  end subroutine aenet_atomic_energy_and_forces_novirial
+
 
   !--------------------------------------------------------------------!
   !                       convert atom type IDs                        !
diff -Naru src/aenet.h src_modified/aenet.h
--- src/aenet.h	2024-09-06 10:37:30
+++ src_modified/aenet.h	2024-09-06 10:37:30
@@ -1,40 +1,40 @@
 #ifndef AENET_H_INCLUDED
 #define AENET_H_INCLUDED
 
-void aenet_init(int ntypes, char* atom_types[], int* stat);
-void aenet_final(int* stat);
+void aenet_init(int ntypes, char *atom_types[], int *stat);
+void aenet_final(int *stat);
 void aenet_print_info(void);
-void aenet_load_potential(int type_id, char* filename, int* stat);
+void aenet_load_potential(int type_id, char *filename, int *stat);
 _Bool aenet_all_loaded(void);
 
 double aenet_free_atom_energy(int type_id);
 
 void aenet_atomic_energy(double coo_i[3], int type_i, int n_j,
-                         double coo_j[], int type_j[], double* E_i,
-                         int* stat);
+                         double coo_j[], int type_j[], double *E_i,
+                         int *stat);
 
 void aenet_atomic_energy_and_forces(double coo_i[3], int type_i, int index_i,
                                     int n_j, double coo_j[], int type_j[],
-                                    int index_j[], int natoms, double* E_i,
-                                    double F[], int* stat);
+                                    int index_j[], int natoms, double *E_i,
+                                    double F[], double S[], int *stat);
 
-void aenet_convert_atom_types(int ntypes_in, char* atom_types[],
+void aenet_convert_atom_types(int ntypes_in, char *atom_types[],
                               int natoms_in, int type_id_in[],
-                              int type_id_out[], int* stat);
+                              int type_id_out[], int *stat);
 
-void aenet_sfb_init(int ntypes, char* atom_types[], int radial_order,
+void aenet_sfb_init(int ntypes, char *atom_types[], int radial_order,
                     int angular_order, double radial_Rc, double angular_Rc,
-                    int* stat);
+                    int *stat);
 
-void aenet_sfb_final(int* stat);
+void aenet_sfb_final(int *stat);
 
 int aenet_sfb_nvalues(void);
 
 void aenet_sfb_eval(int itype0, double coo0[3], int nat, int itype1[],
-                    double coo1[], int nv, double values[], int* stat);
+                    double coo1[], int nv, double values[], int *stat);
 
 void aenet_sfb_reconstruct_radial(int nv, double values[], int nx,
-                                  double x[], double y[], int* stat);
+                                  double x[], double y[], int *stat);
 
 extern int AENET_OK;
 extern int AENET_ERR_INIT;
diff -Naru src/aenet_mpimodule.mod src_modified/aenet_mpimodule.mod
--- src/aenet_mpimodule.mod	1970-01-01 09:00:00
+++ src_modified/aenet_mpimodule.mod	2024-09-06 15:33:03
@@ -0,0 +1,5 @@
+ã      swÛ
+	rÙS»ÕO)ÕIU(K-*ŒÃœSP74UWH.JM,IMQH+ œU(H,JÃ…IÕ—s≥4‡“––T†‚Ç14πÄL,ÿHA=15/µ$>∑ ‚Dul"Í
+Ü
+æ˛.°>Æ
+°~ﬁ~˛·~∫û~!Æ~!\0n@êø3LN(@\Ä$ Ü0>–i`>ƒ≠«ÉtrÅúàÈ#M. %;õÛZ  
\ No newline at end of file
diff -Naru src/ext/chebyshev.f90 src_modified/ext/chebyshev.f90
--- src/ext/chebyshev.f90	2024-09-06 10:37:30
+++ src_modified/ext/chebyshev.f90	2024-09-06 10:37:30
@@ -38,7 +38,7 @@
   !                   Evaluate Chebyshev polynomials                   !
   !--------------------------------------------------------------------!
 
-  function chebyshev_polynomial(r, r0, r1, n) result(T)
+  pure function chebyshev_polynomial(r, r0, r1, n) result(T)
     ! Arguments:
     !    r        function argument
     !    r0, r1   the Chebyshev polynomials will be rescaled from [-1,1]
@@ -78,7 +78,7 @@
   !             First derivative of Chebyshev polynomials              !
   !--------------------------------------------------------------------!
 
-  function chebyshev_polynomial_d1(r, r0, r1, n) result(dT)
+  pure function chebyshev_polynomial_d1(r, r0, r1, n) result(dT)
     ! Arguments:
     !    r        function argument
     !    r0, r1   the Chebyshev polynomials will be rescaled from [-1,1]
diff -Naru src/ext/feedforward.mod src_modified/ext/feedforward.mod
--- src/ext/feedforward.mod	2024-09-06 15:36:47
+++ src_modified/ext/feedforward.mod	1970-01-01 09:00:00
@@ -1,9 +0,0 @@
-ã      Âú[s‚∏«ﬂı)ÙfÚ0ß,ﬂ˝Ë'K- @Ê‰…≈Äô¯úƒ§Ä	ì˝Ù€í1Xé|ÂñŸ≠Ijb–Ø[›ˇñd)w∑oÏ9}¸≤úˇ|[∞ZáÀKDólL7¡/VÀºÇ˘bπ⁄NWÛˇ,lµZ7¯_(˘·¡è›í¢`≥]Æ˛/a)’®Ñï˝KíoK}Òk%	‹ju\Ø˚‡v§ˇg≠ˇ•€ª˝Ò˛rË⁄hwë‹ƒ2¸szΩA€oÓá@÷R±F·F¬≠ﬁ‡Æ€vzXcØíqrMÈ6%€+jæIhæ8Ì∂;·V{–çxkQ€Ï˛á∂5$Ω/ÎØ pi´wÆ∑KrMﬂ"¬Euqqó~∞é§Ëy˙ët5¢Â<(% p£„ﬁ∫ûQáa¬Ñöwc?Œÿ˘⁄sQß{ÔˆG›A_åj‚™ˇ2˝Uå{¶£‰è?≠È-îÚVs îr.qñç•-@z.ƒΩµ#dÃ;ùY/_™·îÇ¢¶A◊<r8ÖΩM¯±ñFë9†›·€ß8⁄ΩMüä§ïâY2îvïÄ·'_{›ˆ˛sw~í˜&Ì
-¿N†§™kÚ}Ω%+∂f∆"ñ|∂å†‹o¸PÛCJf+å6´0Zá≥õ}•§ng‚πSPi8ﬁN˙Ì1¯ª=\<Ü$¬Áƒ@â„,Ù±”„ZFø ≥ï2 ∏u =>≠«~™‚˚≈„Ä«Î21Æ*›˚!¯ª;˛2r‹8µºq˜nÅc«ªs«±'£e◊!…5oÖú5¬†Fºm¶ﬂ/g@Lç Êw˘ú∞≥º√øø5Ëwü][“∆èC1-ı…öÆüJµµ<KC2pù±õ}•>®~í[“nF†R˘ÖµÑº®ëjª„ÖOQÄ≈~mÇhN´∞óO¢Óx8†ØÙ8(/˚,ïäÛ‰4áE	NÒ@≠µ{}ó“"™®TÙ40£…Wo0w˚.‚µJÙ7Áq‰ªˇçÛ”è≥¿áPàã <@˝ÎvXπ:PFC∑MÕ≈√aõ¶òL—™Èã0ö>ÛVÍ,\≈V6ØTiIÃ±"ë¨≤‹¬§Te™_ô·(6‹`—6}~^Œ`∫* ÉÒ˚“V[ñÃ€érz∞‘⁄ÉáI%ı^®–T–ËyÏÁL£À*˚˝†3Èπ±ı∑›À3=©2˛°¨sƒà'V®¸µ[XVT9)Bé…Í‡húâb.P≤Låfõç≈÷y\Y,qâ(2@• ⁄RU¨jX’±jàùl2cfO”ËGêÿ.£3YUÍw§≤êPm¨…X#BfMaÃÛ`E'µ8qä√â5Z)ZöÜ5i÷L¨YXG≤.3‡‡çÍïxu:mjÈ
-÷U§kX◊±n`›ƒ∫%F∂Úè`„G€ ¸Ò¥Yü4$íô ?Ù≠o,ç8%√i®åì˝œ¡Y'tçëÍÿ0∞a
-›jXwøwèä4∏®ÿ6•4cI4IÿåsÌÊÄ0)åÀs…]Vﬂ≤ﬁFŸÄ6Yö6u°´MÉëØ¶—|˘R+@≤µø¢	»Ò<Á—á◊Û;Ó–Ìw‹~˚±<5MìYrHDî6#NƒüØs®5Wqã%£E∞•`K˙›“ˆ∫ÚlÈ‘¿ñâ,[6∂ell+Bhd‰y9ùüe|¥œLaås!ƒOÑl¶(∂éÌ∏z€fñ€‚π˝ÈzÜüÖû)ëeL‰Xæâú’o"”≈¥FNÁy˘‹wn†⁄Uá|H¥¬!kîr{ﬁ‡Ñ[‰nT8k&≤˚€ÿ˘:,DÜhYOﬂÇsœjk9ë„P!*Ñ¿∑8K	]yMpÜp? ¢≈fË£ﬂ‚AÄ¢∆+≠ØÔUóÀàUTü∏πÈÉRìÚ ãs:ƒ∆Dë≈V≤uY∂¯P’L•∞W63I(‰πÌâ7Ç€W¥f»Ï#äP*"ä∆ﬁë¨Jl¥ôx1z¯R¨‘™,|¯∫¸¡Cgrˇ(S\u˘¶x“f}B˘¬≈æ}TÓq˚†çøN“æ^QÀbÔ‚ñ´∏˛®¶at9?æm6“´›6uÍU¢N£è5Ÿ˝<éZÕBO£K1ÙπCcÜt?¥ˇp<ß£wLvá;-∂Ñ_@¢q}¢©WÈ»áËW√§@É¨àﬁØ	¿ñ9a‚±nqÿõÅSRú£4^ˆ¯-î˚Ñ(cÖDÿ£°‹eqî}DY´Ew ˙¥"BuRŸÚıç¿0÷˚ﬂt∂¸N#±/™≈‰Ô‰íÎ;≠÷óqÉr)7±•7O&≈m†¸«1Ÿ6í«1ÇÖBÖ>ù\C¯t5-|YÜËéû5h?	/‘0À=_¯$º<ºo@Ò¿µπ]Øß’˛^árìÏ√A¸Ó
-ß+ïÂ^ˇP¯˛ΩÆ∞R≥ÇòÚì— úÚ·f"l–J∞MÂ30(ˆh“´:M”Ëº?¥k‘%√‡\¢]\!êÖ√3Éfü9!åd#x˛#Û`_<!LH…√ì>EÖ¨‡ˆ◊ìÒﬁìü¶ögh«8ÚÚ-X}_ÆÉ∆h0§Î{s©Ä,?
-!ƒ±xáò◊ê	ã◊nKæ
-'ﬂYÜhïÉ¯-}–Ÿò·3+ï•‰*ïe›Ø_•˚MÆ˚ıÀwøïûM\¿ŒŒ&jC|Í 4*è†m9;ô¯◊zÇ|\E˚á˚"wÕVË"ö?œâﬂ}Ù'Ë3Æ£Yfn∞a\¥ü˜É"ªˆ0]4(jHÌâ†,˝dõıOI‘Lõmì+ë<J≥…eÖ˝,˘≈Òxtèﬂ{ug'Ô="ìL˜ù©Y˜—}?\ˇù`‘®ˇPƒ˙t5{J È^öSà|wz˙p4ö‹ªÙá3,:bî'r;AAúM|ŒdL˙N'rÚSt∫€àK‹˙ßœ\z6ùπ'bjò∫Ñ_H£{ú.ﬂKF¶ójCú°óÃL/ùÜ©i/¡‰eΩö`jo∆Hm†:j2â(=r8_orq*OK§PÖ_M˜3Ãx∑Ÿ1L{¡πwÔ&É…®2(äÈ˝D˚=ßˇß†gÈn¡ÔÔõ¿_oV·<»¡/êsÒ08ÿÒ‡Ù&Æ(3gSQI“√Üã0
-˝Ÿ≤»—ß$M÷¯íÙ›]óê“øs¯12V êÀòË®Ñ6º¬(9/1
-73!e¨ ôfpã†úcZ;3}J∆ª„QÒi#Î2˙xín€ÇÉ32ﬁùßŸ/[√eOÄ»xw,Dx∏~kœ,»…aÜÌûï‡˜›À8ª?Ÿ‰øî‘w{«∑>wOÀÓq¶7·ç¢}√tª±zÉ˛ÈF<rÒH  
\ No newline at end of file
diff -Naru src/ext/sfbasis.f90 src_modified/ext/sfbasis.f90
--- src/ext/sfbasis.f90	2024-09-06 10:37:30
+++ src_modified/ext/sfbasis.f90	2024-09-06 10:37:30
@@ -433,10 +433,316 @@
 
   end function load_SFBasis_ASCII
 
+  subroutine cleararray(nv,nat,deriv0,deriv1)
+   implicit none
+   integer,intent(in) :: nv,nat
+   double precision, dimension(3,nv),     intent(out)   :: deriv0
+   double precision, dimension(3,nv,nat), intent(out)   :: deriv1
+   deriv0(:,:) = 0.0d0
+   deriv1(:,:,:) = 0.0d0
+  end subroutine
 
+  subroutine update_deriv_r(i1,i2,j,N,sfb_values,sfb_deriv_i,sfb_deriv_j,&
+      values,deriv0,deriv1)
+   implicit none
+   integer::i1,i2,j,k,N
+   double precision, dimension(:),     intent(in)   ::sfb_values
+   double precision, dimension(:,:),     intent(in)   :: sfb_deriv_i
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_j
+   double precision, dimension(:),     intent(inout)   ::values
+   double precision, dimension(:,:),     intent(inout)   :: deriv0
+   double precision, dimension(:,:,:), intent(inout)   :: deriv1
+
+
+   values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+   deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
+   deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
+
+   return
+  end subroutine
+
+  subroutine update_deriv_r_multi(i1,i2,j,N,sfb_values,sfb_deriv_i,sfb_deriv_j,&
+      values,deriv0,deriv1,s_j,do_deriv)
+   implicit none
+   integer::i1,i2,j,k,N
+   double precision, dimension(:),     intent(in)   ::sfb_values
+   double precision, dimension(:,:),     intent(in)   :: sfb_deriv_i
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_j
+   double precision, dimension(:),     intent(inout)   ::values
+   double precision, dimension(:,:),     intent(inout)   :: deriv0
+   double precision, dimension(:,:,:), intent(inout)   :: deriv1
+   double precision,intent(in):: s_j
+   logical,intent(in)::do_deriv
+
+   values(i1:i2) = values(i1:i2) + s_j*sfb_values(1:N)
+   if (do_deriv) then
+      deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
+                         + s_j*sfb_deriv_i(1:3, 1:N)
+      deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) &
+                            + s_j*sfb_deriv_j(1:3, 1:N)
+   end if
+
+   return
+  end subroutine
+
+  subroutine update_deriv(i1,i2,j,k,N,sfb_values,sfb_deriv_i,sfb_deriv_j,sfb_deriv_k,&
+      values,deriv0,deriv1)
+   implicit none
+   integer::i1,i2,j,k,N
+   double precision, dimension(:),     intent(in)   ::sfb_values
+   double precision, dimension(:,:),     intent(in)   :: sfb_deriv_i
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_j
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_k
+   double precision, dimension(:),     intent(inout)   ::values
+   double precision, dimension(:,:),     intent(inout)   :: deriv0
+   double precision, dimension(:,:,:), intent(inout)   :: deriv1
+
+
+   values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+   deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
+   deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
+   deriv1(1:3, i1:i2, k) = deriv1(1:3, i1:i2, k) + sfb_deriv_k(1:3, 1:N)
+
+   return
+  end subroutine
+
+  subroutine update_deriv_multi(i1,i2,j,k,N,sfb_values,sfb_deriv_i,sfb_deriv_j,sfb_deriv_k,&
+      values,deriv0,deriv1,do_deriv,s_j,s_k)
+   implicit none
+   integer::i1,i2,j,k,N
+   double precision, dimension(:),     intent(in)   ::sfb_values
+   double precision, dimension(:,:),     intent(in)   :: sfb_deriv_i
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_j
+   double precision, dimension(:,:), intent(in)   :: sfb_deriv_k
+   double precision, dimension(:),     intent(inout)   ::values
+   double precision, dimension(:,:),     intent(inout)   :: deriv0
+   double precision, dimension(:,:,:), intent(inout)   :: deriv1
+   logical,intent(in)::do_deriv
+   double precision,intent(in) ::s_j,s_k
+
+   values(i1:i2) = values(i1:i2) + s_j*s_k*sfb_values(1:N)
+   if (do_deriv) then
+      deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
+                         + s_j*s_k*sfb_deriv_i(1:3, 1:N)
+      deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) &
+                            + s_j*s_k*sfb_deriv_j(1:3, 1:N)
+      deriv1(1:3, i1:i2, k) = deriv1(1:3, i1:i2, k) &
+                            + s_j*s_k*sfb_deriv_k(1:3, 1:N)
+   end if
+   
+
+   return
+  end subroutine
+
+
   !========================= basis evaluation =========================!
 
+    subroutine sfb_eval_deriv(sfb, itype0, coo0, nat, itype1, coo1, nv, &
+                      values, deriv0, deriv1)
 
+    implicit none
+
+    type(FingerprintBasis),                          intent(inout) :: sfb
+    integer,                                         intent(in)    :: itype0
+    double precision, dimension(3),                  intent(in)    :: coo0
+    integer,                                         intent(in)    :: nat
+    integer,          dimension(nat),                intent(in)    :: itype1
+    double precision, dimension(3,nat),              intent(in)    :: coo1
+    integer,                                         intent(in)    :: nv
+    double precision, dimension(nv),                 intent(out)   :: values
+    double precision, dimension(3,nv),      intent(out)   :: deriv0
+    double precision, dimension(3,nv,nat),  intent(out)   :: deriv1
+
+    double precision, dimension(sfb%num_values)   :: sfb_values
+    double precision, dimension(:,:), allocatable :: sfb_deriv_i
+    double precision, dimension(:,:), allocatable :: sfb_deriv_j
+    double precision, dimension(:,:), allocatable :: sfb_deriv_k
+
+    logical                        :: do_deriv
+    double precision, dimension(3) :: R_ij, R_ik
+    double precision               :: d_ij, d_ik
+    double precision               :: cos_ijk
+    double precision               :: s_j, s_k
+    integer                        :: j, k, i1, i2, N
+    integer ::ii,kk
+    double precision::fc_j,dfc_j,id_ij2
+
+    call sfb_assert_init(sfb)
+
+    if (nv /= sfb%N) then
+       write(0,*) "Error: wrong number of basis functions in `sfb_eval'."
+       stop
+    end if
+
+    !if (present(deriv0) .and. present(deriv1)) then
+    !   do_deriv = .true.
+       deriv0(:,:) = 0.0d0
+       deriv1(:,:,:) = 0.0d0
+       !call cleararray(nv,nat,deriv0,deriv1)
+       allocate(sfb_deriv_i(3, sfb%num_values), &
+                sfb_deriv_j(3, sfb%num_values), &
+                sfb_deriv_k(3, sfb%num_values))
+    !else
+    !   do_deriv = .false.
+    !end if
+
+    values(1:sfb%N) = 0.0d0
+    s_j = 1.0d0
+
+    for_j : do j = 1, nat
+       R_ij = coo1(1:3, j) - coo0(1:3)
+       d_ij = sqrt(dot_product(R_ij, R_ij))
+       if ((d_ij <= sfb%r_Rc) .and. (d_ij > EPS)) then
+
+          ! evaluate radial basis functions
+          i1 = sfb%r_i1
+          i2 = sfb%r_f1
+          N = sfb%r_N
+          !if (do_deriv) then
+             call sfb_radial(sfb, R_ij, d_ij, sfb_values, &
+                             deriv_i=sfb_deriv_i, deriv_j=sfb_deriv_j)
+            !call update_deriv_r(i1,i2,j,N,sfb_values,sfb_deriv_i,sfb_deriv_j,&
+            !   values,deriv0,deriv1)
+            
+            !values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+            do concurrent (ii=1:N)
+               values(i1+ii-1) = values(i1+ii-1) + sfb_values(ii)
+            end do
+
+            do concurrent (kk=1:3,ii=1:N)
+               deriv0(kk, i1+ii-1) = deriv0(kk, i1+ii-1) + sfb_deriv_i(kk, ii)
+               deriv1(kk, i1+ii-1, j) = deriv1(kk, i1+ii-1, j) + sfb_deriv_j(kk, ii)
+            end do
+             !deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
+             !deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
+          !else
+          !   call sfb_radial(sfb, R_ij, d_ij, sfb_values)
+          !   values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+          !end if
+
+          ! redundant radial basis in case of multi-component systems
+          i1 = sfb%r_i2
+          i2 = sfb%r_f2
+          N = sfb%r_N
+          if (sfb%multi) then
+             s_j = sfb%typespin(sfb%typeid(itype1(j)))
+             !call update_deriv_r_multi(i1,i2,j,N,sfb_values,&
+             !  sfb_deriv_i,sfb_deriv_j,&
+             !  values,deriv0,deriv1,s_j,do_deriv)
+            do concurrent (ii=1:N)
+               values(i1+ii-1) = values(i1+ii-1) + s_j*sfb_values(ii)
+            end do
+            do concurrent (kk=1:3,ii=1:N)
+               deriv0(kk, i1+ii-1) = deriv0(kk, i1+ii-1) + s_j*sfb_deriv_i(kk, ii)
+               deriv1(kk, i1+ii-1, j) = deriv1(kk, i1+ii-1, j) + s_j*sfb_deriv_j(kk, ii)
+            end do
+
+             !values(i1:i2) = values(i1:i2) + s_j*sfb_values(1:N)
+             !if (do_deriv) then
+               
+                !deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
+                !                   + s_j*sfb_deriv_i(1:3, 1:N)
+                !deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) &
+                !                      + s_j*sfb_deriv_j(1:3, 1:N)
+             !end if
+          end if
+
+       end if  ! within radial cutoff
+
+       if (d_ij > sfb%a_Rc) cycle for_j
+       id_ij2 = 1.0d0/(d_ij*d_ij)
+       fc_j = sfb_fc(d_ij, sfb%a_Rc)
+       dfc_j = sfb_fc_d1(d_ij, sfb%a_Rc)
+
+       for_k : do k = j+1, nat
+          R_ik = coo1(1:3, k) - coo0(1:3)
+          d_ik = sqrt(dot_product(R_ik, R_ik))
+          if ((d_ik > sfb%a_Rc) .or. (d_ik < EPS)) cycle for_k
+          cos_ijk = dot_product(R_ij, R_ik)/(d_ij*d_ik)
+
+          ! evaluate angular basis functions
+          i1 = sfb%a_i1
+          i2 = sfb%a_f1
+          N = sfb%a_N
+          !if (do_deriv) then
+             call sfb_angular_deriv(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, &
+                              sfb_values, &
+                              fc_j,dfc_j,id_ij2,&
+                              deriv_i=sfb_deriv_i,      &
+                              deriv_j=sfb_deriv_j, deriv_k=sfb_deriv_k)
+             !call update_deriv(i1,i2,j,k,N,sfb_values,sfb_deriv_i,sfb_deriv_j,sfb_deriv_k,&
+             !           values,deriv0,deriv1)
+             !values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+             do concurrent (ii=1:N)
+               values(i1+ii-1) = values(i1+ii-1) + sfb_values(ii)
+             end do
+             !deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
+             !deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
+             !deriv1(1:3, i1:i2, k) = deriv1(1:3, i1:i2, k) + sfb_deriv_k(1:3, 1:N)
+            do concurrent (kk=1:3,ii=1:N)
+               deriv0(kk, i1+ii-1) = deriv0(kk, i1+ii-1) + sfb_deriv_i(kk, ii)
+               deriv1(kk, i1+ii-1, j) = deriv1(kk, i1+ii-1, j) + sfb_deriv_j(kk, ii)
+               deriv1(kk, i1+ii-1, k) = deriv1(kk, i1+ii-1, k) + sfb_deriv_k(kk, ii)
+            end do
+             !do ii = 1, N
+             !do concurrent (ii=1:N)
+             !  deriv0(1, i1+ii-1) = deriv0(1, i1+ii-1) + sfb_deriv_i(1, ii)
+             !  deriv0(2, i1+ii-1) = deriv0(2, i1+ii-1) + sfb_deriv_i(2, ii)
+             !  deriv0(3, i1+ii-1) = deriv0(3, i1+ii-1) + sfb_deriv_i(3, ii)
+             !end do
+
+             !do concurrent (ii=1:N)
+             !  deriv1(1, i1+ii-1, j) = deriv1(1, i1+ii-1, j) + sfb_deriv_j(1, ii)
+             !  deriv1(2, i1+ii-1, j) = deriv1(2, i1+ii-1, j) + sfb_deriv_j(2, ii)
+             !  deriv1(3, i1+ii-1, j) = deriv1(3, i1+ii-1, j) + sfb_deriv_j(3, ii)
+             !end do
+
+             !do concurrent (ii=1:N)
+             !  deriv1(1, i1+ii-1, k) = deriv1(1, i1+ii-1, k) + sfb_deriv_k(1, ii)
+             !  deriv1(2, i1+ii-1, k) = deriv1(2, i1+ii-1, k) + sfb_deriv_k(2, ii)
+             !  deriv1(3, i1+ii-1, k) = deriv1(3, i1+ii-1, k) + sfb_deriv_k(3, ii)
+             !end do
+
+          !else
+          !   call sfb_angular(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, sfb_values)
+          !   values(i1:i2) = values(i1:i2) + sfb_values(1:N)
+          !end if
+
+          ! redundant angular basis in case of multi-component systems
+          i1 = sfb%a_i2
+          i2 = sfb%a_f2
+          N = sfb%a_N
+          if (sfb%multi) then
+             s_k = sfb%typespin(sfb%typeid(itype1(k)))
+             !call update_deriv_multi(i1,i2,j,k,N,sfb_values,sfb_deriv_i,&
+             !     sfb_deriv_j,sfb_deriv_k,&
+             !     values,deriv0,deriv1,do_deriv,s_j,s_k)
+
+             !values(i1:i2) = values(i1:i2) + s_j*s_k*sfb_values(1:N)
+             do concurrent (ii=1:N)
+               values(i1+ii-1) = values(i1+ii-1) + s_j*s_k*sfb_values(ii)
+             end do
+             !if (do_deriv) then
+                !deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
+                !                   + s_j*s_k*sfb_deriv_i(1:3, 1:N)
+                !deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) &
+                !                      + s_j*s_k*sfb_deriv_j(1:3, 1:N)
+                !deriv1(1:3, i1:i2, k) = deriv1(1:3, i1:i2, k) &
+                !                      + s_j*s_k*sfb_deriv_k(1:3, 1:N)
+             !end if
+             do concurrent (kk=1:3,ii=1:N)
+               deriv0(kk, i1+ii-1) = deriv0(kk, i1+ii-1) + s_j*s_k*sfb_deriv_i(kk, ii)
+               deriv1(kk, i1+ii-1, j) = deriv1(kk, i1+ii-1, j) + s_j*s_k*sfb_deriv_j(kk, ii)
+               deriv1(kk, i1+ii-1, k) = deriv1(kk, i1+ii-1, k) +s_j*s_k*sfb_deriv_k(kk, ii)
+              end do
+          end if
+       end do for_k
+    end do for_j
+
+    deallocate(sfb_deriv_i, sfb_deriv_j, sfb_deriv_k)
+
+  end subroutine sfb_eval_deriv
+
   subroutine sfb_eval(sfb, itype0, coo0, nat, itype1, coo1, nv, &
                       values, deriv0, deriv1)
 
@@ -465,6 +771,12 @@
     double precision               :: s_j, s_k
     integer                        :: j, k, i1, i2, N
 
+    !if (present(deriv0) .and. present(deriv1)) then
+    !  call sfb_eval_deriv(sfb, itype0, coo0, nat, itype1, coo1, nv, &
+    !!                  values, deriv0, deriv1)
+    !  return
+    !end if
+
     call sfb_assert_init(sfb)
 
     if (nv /= sfb%N) then
@@ -476,6 +788,7 @@
        do_deriv = .true.
        deriv0(:,:) = 0.0d0
        deriv1(:,:,:) = 0.0d0
+       !call cleararray(nv,nat,deriv0,deriv1)
        allocate(sfb_deriv_i(3, sfb%num_values), &
                 sfb_deriv_j(3, sfb%num_values), &
                 sfb_deriv_k(3, sfb%num_values))
@@ -498,6 +811,9 @@
           if (do_deriv) then
              call sfb_radial(sfb, R_ij, d_ij, sfb_values, &
                              deriv_i=sfb_deriv_i, deriv_j=sfb_deriv_j)
+            !call update_deriv_r(i1,i2,j,N,sfb_values,sfb_deriv_i,sfb_deriv_j,&
+            !   values,deriv0,deriv1)
+
              values(i1:i2) = values(i1:i2) + sfb_values(1:N)
              deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
              deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
@@ -511,7 +827,13 @@
           i2 = sfb%r_f2
           N = sfb%r_N
           if (sfb%multi) then
+            !write(*,*) "j",j,itype1(j)
+            !write(*,*) sfb%typeid(itype1(j))
+            !write(*,*) sfb%typespin(sfb%typeid(itype1(j)))
              s_j = sfb%typespin(sfb%typeid(itype1(j)))
+             !call update_deriv_r_multi(i1,i2,j,N,sfb_values,&
+             !  sfb_deriv_i,sfb_deriv_j,&
+             !  values,deriv0,deriv1,s_j,do_deriv)
              values(i1:i2) = values(i1:i2) + s_j*sfb_values(1:N)
              if (do_deriv) then
                 deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
@@ -524,6 +846,9 @@
        end if  ! within radial cutoff
 
        if (d_ij > sfb%a_Rc) cycle for_j
+       
+
+
        for_k : do k = j+1, nat
           R_ik = coo1(1:3, k) - coo0(1:3)
           d_ik = sqrt(dot_product(R_ik, R_ik))
@@ -538,6 +863,8 @@
              call sfb_angular(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, &
                               sfb_values, deriv_i=sfb_deriv_i,      &
                               deriv_j=sfb_deriv_j, deriv_k=sfb_deriv_k)
+             !call update_deriv(i1,i2,j,k,N,sfb_values,sfb_deriv_i,sfb_deriv_j,sfb_deriv_k,&
+             !           values,deriv0,deriv1)
              values(i1:i2) = values(i1:i2) + sfb_values(1:N)
              deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) + sfb_deriv_i(1:3, 1:N)
              deriv1(1:3, i1:i2, j) = deriv1(1:3, i1:i2, j) + sfb_deriv_j(1:3, 1:N)
@@ -553,6 +880,10 @@
           N = sfb%a_N
           if (sfb%multi) then
              s_k = sfb%typespin(sfb%typeid(itype1(k)))
+             !call update_deriv_multi(i1,i2,j,k,N,sfb_values,sfb_deriv_i,&
+             !     sfb_deriv_j,sfb_deriv_k,&
+             !     values,deriv0,deriv1,do_deriv,s_j,s_k)
+
              values(i1:i2) = values(i1:i2) + s_j*s_k*sfb_values(1:N)
              if (do_deriv) then
                 deriv0(1:3, i1:i2) = deriv0(1:3, i1:i2) &
@@ -716,7 +1047,7 @@
   !====================================================================!
 
 
-  function sfb_fc(Rij, Rc) result(fc)
+  pure function sfb_fc(Rij, Rc) result(fc)
 
     implicit none
 
@@ -733,7 +1064,7 @@
 
   !--------------------------------------------------------------------!
 
-  function sfb_fc_d1(Rij, Rc) result(dfc)
+  pure function sfb_fc_d1(Rij, Rc) result(dfc)
 
     implicit none
 
@@ -794,6 +1125,96 @@
 
   !--------------------------------------------------------------------!
 
+subroutine sfb_angular_deriv(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, values, &
+                        fc_j,dfc_j,id_ij2,&
+                         deriv_i, deriv_j, deriv_k)
+
+    implicit none
+
+    type(FingerprintBasis),                     intent(inout) :: sfb
+    double precision, dimension(3),             intent(in)    :: R_ij, R_ik
+    double precision,                           intent(in)    :: d_ij, d_ik
+    double precision,                           intent(in)    :: cos_ijk
+    double precision, dimension(:),             intent(out)   :: values
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_i
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_j
+    double precision, dimension(:,:), optional, intent(out)   :: deriv_k
+
+    double precision                     :: w_ijk
+    double precision                     :: fc_k, dfc_k !fc_j, dfc_j
+    double precision, dimension(sfb%a_N) :: f, df
+    double precision                     :: id_ik2, id_ij_ik!,id_ij2
+    double precision, dimension(3)       :: di_cos_ikj, dj_cos_ikj, dk_cos_ikj
+    double precision, dimension(3)       :: di_w_ijk, dj_w_ijk, dk_w_ijk
+    integer                              :: i
+    integer::k
+    double precision,intent(in) ::fc_j,dfc_j,id_ij2
+
+    !call sfb_assert_init(sfb)
+
+    !fc_j = sfb_fc(d_ij, sfb%a_Rc)
+    fc_k = sfb_fc(d_ik, sfb%a_Rc)
+    w_ijk = fc_j*fc_k
+
+    f = chebyshev_polynomial(cos_ijk, -1.0d0, 1.0d0, sfb%a_order)
+
+    values(1:sfb%a_N) = w_ijk*f
+
+    !if (present(deriv_i) .and. present(deriv_j) .and. present(deriv_k)) then
+       !dfc_j = sfb_fc_d1(d_ij, sfb%a_Rc)
+       dfc_k = sfb_fc_d1(d_ik, sfb%a_Rc)
+       df = chebyshev_polynomial_d1(cos_ijk, -1.0d0, 1.0d0, sfb%a_order)
+       !id_ij2 = 1.0d0/(d_ij*d_ij)
+       id_ik2 = 1.0d0/(d_ik*d_ik)
+       id_ij_ik = 1.0d0/(d_ij*d_ik)
+       ! d/dR_i (cos_ijk)
+       !di_cos_ikj = cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
+       ! d/dR_j (cos_ijk)
+       !dj_cos_ikj = -cos_ijk*R_ij*id_ij2 + R_ik*id_ij_ik
+       ! d/dR_k (cos_ijk)
+       !dk_cos_ikj = -cos_ijk*R_ik*id_ik2 + R_ij*id_ij_ik
+       ! d/dR_i (cos_ijk)
+       !di_cos_ikj = -dj_cos_ikj - dk_cos_ikj!cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
+       ! d/dR_i (w_ijk)
+       !di_w_ijk = -(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
+       ! d/dR_j (w_ijk)
+       !dj_w_ijk = dfc_j*fc_k*R_ij/d_ij
+       ! d/dR_k (w_ijk)
+       !dk_w_ijk = fc_j*dfc_k*R_ik/d_ik
+       do concurrent(k=1:3)
+         ! d/dR_j (cos_ijk)
+         dj_cos_ikj(k) = -cos_ijk*R_ij(k)*id_ij2 + R_ik(k)*id_ij_ik
+         ! d/dR_k (cos_ijk)
+         dk_cos_ikj(k) = -cos_ijk*R_ik(k)*id_ik2 + R_ij(k)*id_ij_ik
+         ! d/dR_j (w_ijk)
+         dj_w_ijk(k) = dfc_j*fc_k*R_ij(k)/d_ij
+         ! d/dR_k (w_ijk)
+         dk_w_ijk(k) = fc_j*dfc_k*R_ik(k)/d_ik
+       end do
+       ! d/dR_i (w_ijk)
+       !di_w_ijk = -dj_w_ijk  - dk_w_ijk!-(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
+       !forall (i=1:sfb%a_N)
+       do concurrent(k=1:3,i=1:sfb%a_N)
+          ! d/dR_i (w_ijk*f)
+          !deriv_i(:,i) = di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+          ! d/dR_j (w_ijk*f)
+          !deriv_j(:,i) = dj_w_ijk(:)*f(i) + w_ijk*df(i)*dj_cos_ikj(:)
+          ! d/dR_k (w_ijk*f)
+          !deriv_k(:,i) = dk_w_ijk(:)*f(i) + w_ijk*df(i)*dk_cos_ikj(:)
+          ! d/dR_i (w_ijk*f)
+          !deriv_i(:,i) = -deriv_j(:,i) -deriv_k(:,i)  !di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+          deriv_j(k,i) = dj_w_ijk(k)*f(i) + w_ijk*df(i)*dj_cos_ikj(k)
+          ! d/dR_k (w_ijk*f)
+          deriv_k(k,i) = dk_w_ijk(k)*f(i) + w_ijk*df(i)*dk_cos_ikj(k)
+          ! d/dR_i (w_ijk*f)
+          deriv_i(k,i) = -deriv_j(k,i) -deriv_k(k,i)  !di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+           
+       end do
+       !end forall
+    !end if
+
+  end subroutine sfb_angular_deriv
+
   subroutine sfb_angular(sfb, R_ij, R_ik, d_ij, d_ik, cos_ijk, values, &
                          deriv_i, deriv_j, deriv_k)
 
@@ -815,6 +1236,7 @@
     double precision, dimension(3)       :: di_cos_ikj, dj_cos_ikj, dk_cos_ikj
     double precision, dimension(3)       :: di_w_ijk, dj_w_ijk, dk_w_ijk
     integer                              :: i
+    integer::k
 
     call sfb_assert_init(sfb)
 
@@ -834,25 +1256,39 @@
        id_ik2 = 1.0d0/(d_ik*d_ik)
        id_ij_ik = 1.0d0/(d_ij*d_ik)
        ! d/dR_i (cos_ijk)
-       di_cos_ikj = cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
+       !di_cos_ikj = cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
        ! d/dR_j (cos_ijk)
        dj_cos_ikj = -cos_ijk*R_ij*id_ij2 + R_ik*id_ij_ik
        ! d/dR_k (cos_ijk)
        dk_cos_ikj = -cos_ijk*R_ik*id_ik2 + R_ij*id_ij_ik
+       ! d/dR_i (cos_ijk)
+       !di_cos_ikj = -dj_cos_ikj - dk_cos_ikj!cos_ijk*(R_ij*id_ij2 + R_ik*id_ik2) - (R_ij+R_ik)*id_ij_ik
        ! d/dR_i (w_ijk)
-       di_w_ijk = -(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
+       !di_w_ijk = -(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
        ! d/dR_j (w_ijk)
        dj_w_ijk = dfc_j*fc_k*R_ij/d_ij
        ! d/dR_k (w_ijk)
        dk_w_ijk = fc_j*dfc_k*R_ik/d_ik
-       forall (i=1:sfb%a_N)
+       ! d/dR_i (w_ijk)
+       !di_w_ijk = -dj_w_ijk  - dk_w_ijk!-(dfc_j*fc_k*R_ij/d_ij + fc_j*dfc_k*R_ik/d_ik)
+       !forall (i=1:sfb%a_N)
+       do concurrent(k=1:3,i=1:sfb%a_N)
           ! d/dR_i (w_ijk*f)
-          deriv_i(:,i) = di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+          !deriv_i(:,i) = di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
           ! d/dR_j (w_ijk*f)
-          deriv_j(:,i) = dj_w_ijk(:)*f(i) + w_ijk*df(i)*dj_cos_ikj(:)
+          !deriv_j(:,i) = dj_w_ijk(:)*f(i) + w_ijk*df(i)*dj_cos_ikj(:)
           ! d/dR_k (w_ijk*f)
-          deriv_k(:,i) = dk_w_ijk(:)*f(i) + w_ijk*df(i)*dk_cos_ikj(:)
-       end forall
+          !deriv_k(:,i) = dk_w_ijk(:)*f(i) + w_ijk*df(i)*dk_cos_ikj(:)
+          ! d/dR_i (w_ijk*f)
+          !deriv_i(:,i) = -deriv_j(:,i) -deriv_k(:,i)  !di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+          deriv_j(k,i) = dj_w_ijk(k)*f(i) + w_ijk*df(i)*dj_cos_ikj(k)
+          ! d/dR_k (w_ijk*f)
+          deriv_k(k,i) = dk_w_ijk(k)*f(i) + w_ijk*df(i)*dk_cos_ikj(k)
+          ! d/dR_i (w_ijk*f)
+          deriv_i(k,i) = -deriv_j(k,i) -deriv_k(k,i)  !di_w_ijk(:)*f(i) + w_ijk*df(i)*di_cos_ikj(:)
+           
+       end do
+       !end forall
     end if
 
   end subroutine sfb_angular
diff -Naru src/generate.f90 src_modified/generate.f90
--- src/generate.f90	2024-09-06 10:37:30
+++ src_modified/generate.f90	2024-09-06 10:37:30
@@ -25,518 +25,87 @@
 !-----------------------------------------------------------------------
 
 program generate
+    use aeio,     only: aeio_readline,        &
+                    aeio_header,          &
+                    aeio_timestamp,       &
+                    aeio_print_copyright, &
+                    PATHLEN, LINELEN
+    use aenet_generate 
 
-  use aeio,     only: aeio_readline,        &
-                      aeio_header,          &
-                      aeio_timestamp,       &
-                      aeio_print_copyright, &
-                      PATHLEN, LINELEN
 
-  use geometry, only: geo_init,          &
-                      geo_final,         &
-                      geo_itype_of_name, &
-                      geo_type_conv,     &
-                      pbc,               &
-                      latticeVec,        &
-                      nAtoms,            &
-                      nTypes,            &
-                      atomType,          &
-                      atomTypeName,      &
-                      cooLatt,           &
-                      cooCart,           &
-                      forCart,           &
-                      hasEnergy,         &
-                      hasForces,         &
-                      cohesiveEnergy,    &
-                      totalEnergy
+    implicit none
+    character(len=PATHLEN)                         :: inFile
+    integer::ionum
 
-  use input,    only: InputData,         &
-                      read_InpGenerate,  &
-                      del_InputData
 
-  use io,       only: io_adjustl,        &
-                      io_center,         &
-                      io_lower,          &
-                      io_readnext,       &
-                      io_unit
+    ionum= 139
+    call initialize(inFile)
+    call generate_subroutine(inFile,ionum)
 
-  use lclist,   only: lcl_init,          &
-                      lcl_final,         &
-                      lcl_print_info,    &
-                      lcl_nmax_nbdist,   &
-                      lcl_nbdist_cart
 
-  use sfsetup,  only: Setup,                 &
-                      read_Setup_parameters, &
-                      save_Setup,            &
-                      del_Setup,             &
-                      stp_init,              &
-                      stp_final,             &
-                      stp_get_range,         &
-                      stp_print_info,        &
-                      stp_eval,              &
-                      nsf_max
-
-  use timing,   only: tng_init,          &
-                      tng_final,         &
-                      tng_timing,        &
-                      tng_timing2,       &
-                      tng_timing3,       &
-                      tng_dump
-
-  use trainset, only: TrnSet,                 &
-                      new_TrnSet,             &
-                      close_TrnSet,           &
-                      ts_print_info,          &
-                      ts_write_header,        &
-                      ts_write_sf_info,       &
-                      ts_write_atom_info,     &
-                      ts_write_structure_info
-
-  use pytorchoutput, only: pyo_write_init,               &
-                           pyo_write_final,              &
-                           pyo_write_header_info,        &
-                           pyo_write_structure_info,     &
-                           pyo_write_atom_sf_info,       &
-                           pyo_select_force_structures!, &
-
-  implicit none
-
-  !--------------------------------------------------------------------!
-  ! stp(i)         structural fingerprint basis setup for atom type i  !
-  ! r_min, r_max   lower and upper bound for atomic interactions       !
-  ! ts             training set reference                              !
-  !                                                                    !
-  ! nnb_max, nnb   max. and actual number of neighboring atoms         !
-  ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
-  !                neighboring atom                                    !
-  ! nbdist(i)      distance of the i-th neighbor                       !
-  !                                                                    !
-  ! sfval(i)         value of the i-th basis function                  !
-  ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
-  !                  with respect to the central atom                  !
-  !                  sfderiv_i(3,nsf_max)                              !
-  ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
-  !                  with respect to the coordinates of atom k         !
-  !                  sfderiv_j(3,nsf_max,nnb_max)                      !
-  !                                                                    !
-  ! E_coh          cohesive energy                                     !
-  ! nFiles_inv     = 1/inp%nStrucs                                     !
-  !                                                                    !
-  ! inFile         name of the input file for the generate.x program   !
-  ! cooFile        name of the currently active structure file         !
-  ! keyword        the last keyword read from the input file           !
-  !                                                                    !
-  ! do_debug       if .true., additional files containing debugging    !
-  !                info will be created                                !
-  !                                                                    !
-  ! u_*            file units                                          !
-  !--------------------------------------------------------------------!
-
-  type(InputData)                                :: inp
-
-  type(Setup),       dimension(:),   allocatable :: stp
-  double precision                               :: r_min, r_max
-  type(TrnSet)                                   :: ts
-
-  integer                                        :: nnb_max, nnb
-  double precision,  dimension(:,:), allocatable :: nbcoo
-  double precision,  dimension(:),   allocatable :: nbdist
-  integer,  dimension(:),   allocatable :: nblist
-  integer,           dimension(:),   allocatable :: nbtype
-
-  double precision, dimension(:),     allocatable :: sfval
-  double precision, dimension(:,:),   allocatable :: sfderiv_i
-  double precision, dimension(:,:,:), allocatable :: sfderiv_j
-
-  double precision                               :: E_coh
-  integer                                        :: ifile
-  double precision                               :: nFiles_inv
-
-  character(len=PATHLEN)                         :: inFile
-  character(len=PATHLEN)                         :: cooFile
-  character(len=LINELEN)                         :: keyword
-
-  integer                                        :: itype1
-  integer                                        :: itype, iatom
-
-  integer                                        :: iline
-  character(len=1024)                            :: line
-
-  integer                                        :: u_in, u_tng
-  logical                                        :: do_debug = .false.
-  integer                                        :: u_dbg, idbg
-
-  integer                                        :: u_pyo, max_nnb_trainset, pyo_forces_struc
-  integer, allocatable                           :: struc_write_force(:)
-
-  integer :: i
-
-  ! timing registers
-  integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
-
-  !-------------------------- initialization --------------------------!
-
-  call initialize(inFile)
-
-  inp = read_InpGenerate(inFile)
-  allocate(stp(inp%nTypes))
-  call load_symmfunc_setups(inp, stp)
-
-  ! call parse_input(inFile)
-
-  if (inp%do_timing) then
-     u_tng = io_unit()
-     call tng_init(unit=u_tng, file='generate.time', registers=3)
-     write(*,*) 'Timing info will be written to: ', 'generate.time'
-     write(*,*)
-  end if
-  if (do_debug) then
-     u_dbg = io_unit()
-     open(u_dbg, file='generate.debug', status='replace', action='write')
-  end if
-
-  ! get interaction range and max. number of atoms within range
-  call stp_get_range(inp%nTypes, stp, r_min, r_max)
-  nnb_max = lcl_nmax_nbdist(r_min, r_max)
-  allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nblist(nnb_max),nbtype(nnb_max))
-
-  ! initialize workspace for structural fingerprint basis:
-  call stp_init(inp%nTypes, stp, nnb_max)
-  if (inp%do_timing) call tng_timing('Structural fingerprint basis initialized.')
-
-  ! allocate workspace for basis function evaluation:
-  allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
-  sfval(:) = 0.0d0
-  sfderiv_i(:,:) = 0.0d0
-  sfderiv_j(:,:,:) = 0.0d0
-
-  call aeio_header('Generation of training set started')
-  write(*,*)
-
-  write(*,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
-  write(*,'(1x,"types                 : ")', advance='no')
-  do itype = 1, inp%nTypes
-     if (mod(itype,7) == 0) write(*,'(29x)')
-     write(*,'(A5,1x)', advance='no') inp%typeName(itype)
-  end do
-  write(*,*)
-  write(*,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
-  write(*,*)
-
-  !-------------- write basis function settings to stdout -------------!
-
-  call aeio_header("Structural fingerprint basis set-up")
-  write(*,*)
-
-  do itype1 = 1, inp%nTypes
-     call stp_print_info(stp(itype1))
-  end do
-
-  !----------- write training set header to the output file -----------!
-
-  ts = new_TrnSet(inp%nTypes, inp%typeName, inp%atomicEnergy, &
-                  inp%nStrucs, trim(inp%outFileName))
-
-  if (inp%do_timing) call tng_timing('Training set file started.')
-
-  !--------------- write pytorch force training header ----------------!
+    contains !=============================================================!
   
-  if (inp%pyo_forces) then
-    u_pyo = io_unit()
-    call pyo_write_init(u_pyo, trim(inp%outFileName)//".forces")
-    call pyo_write_header_info(u_pyo, inp%nStrucs)
-    call pyo_select_force_structures(inp%nStrucs, inp%pyo_forces_percent, struc_write_force)
-    max_nnb_trainset = 0
-  endif
-
-  !------------------ iterate over coordinates files ------------------!
-
-  call aeio_header("Adding structures to the training set")
-  write(*,*)
-
-  u_in = io_unit()
-  open(u_in, file=inFile, status='old', action='read')
-  rewind(u_in)
-
-  iline = 0
-  do
-     ! forward until the FILES keyword:
-     call aeio_readline(u_in, iline, line)
-     read(line,*) keyword
-     if (trim(keyword) == 'FILES') then
-        read(u_in,*)
-        exit
-     end if
-  end do
-
-  ! header for stdout
-  write(*,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
-       'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
-
-  nFiles_inv = 1.0d0/dble(inp%nStrucs)
-  structures : do ifile = 1, inp%nStrucs
-
-     if (inp%do_timing) call tng_timing('Structure: '// io_adjustl(ifile))
-
-     call aeio_readline(u_in, iline, line)
-     cooFile = trim(line)
-
-     call geo_init(cooFile, 'xsf')
-     if (inp%do_timing) call tng_timing3(register=R_GEO)
-     if (.not. (hasForces .and. hasEnergy)) then
-        write(0,*) ">>>", hasForces, hasEnergy
-        write(0,*) "Error: incomplete output data in : ", trim(cooFile)
-        call finalize()
-        stop
-     end if
-
-     if (nTypes > inp%nTypes) then
-        write(*,*) 'Skipping ', trim(adjustl(cooFile)), &
-                   ': too many atomic species'
-        call geo_final()
-        cycle structures
-     end if
-
-     if (abs(cohesiveEnergy) /= 0.0d0) then
-        E_coh = cohesiveEnergy
-     else
-        ! if only the total energy is available, we have to calculate
-        ! the cohesive energy at this point
-        E_coh = totalEnergy
-        do iatom = 1, nAtoms
-           itype1 = atomType(iatom)
-           itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
-                                  inp%nTypes, inp%typeName)
-           E_coh = E_coh - inp%atomicEnergy(itype1)
-        end do
-     end if
-
-     write(*,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
-          ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
-          trim(adjustl(cooFile))
-
-     call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
-     if (inp%do_timing) call tng_timing3(register=R_NBL)
-
-     ! write structure info (atoms, types, energy) to training set file:
-     call ts_write_structure_info(ts, cooFile, nAtoms, nTypes, E_coh)
-     
-     ! write structure info (atoms, types) to pytorch forces file:
-     if (inp%pyo_forces) then
-       pyo_forces_struc = struc_write_force(ifile)
-       call pyo_write_structure_info(u_pyo, cooFile, nAtoms, nTypes, pyo_forces_struc)
-     end if
-
-     atoms : do iatom = 1, nAtoms
-
-        ! determine the training atom type of atom `iatom' in global
-        ! index terms
-        itype1 = atomType(iatom)
-        itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
-                               inp%nTypes, inp%typeName)
-
-        ! assert that atom type is included in the set-ups:
-        if (itype1 == 0) then
-           write(0,*) "Error: not a valid structure    : ", trim(cooFile)
-           write(0,*) "       Additional species found."
-           call finalize()
-           stop
-        end if
-
-        ! write atom info (species, forces) to training set file:
-        call ts_write_atom_info(ts, itype1, cooCart(iatom), forCart(iatom))
-
-        ! get all atoms within cut-off:
-        nnb = nnb_max
-        call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nblist=nblist, nbtype=nbtype)
-
-        if (inp%do_timing) call tng_timing3(register=R_NBL)
-        write(*,'(1x,I6,2x,A2,2x,I6)') &
-             iatom, trim(atomTypeName(atomType(iatom))), nnb
-
-        ! convert atom types to global index:
-        do i = 1, nnb
-           nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
-                                    inp%nTypes, inp%typeName)
-           if (nbtype(i) == 0) then
-              write(0,*) "Error: atom type not found in setup."
-              call finalize()
-              stop
-           end if
-        end do
-
-        ! evaluate the structural fingerprint basis function set-up:
-        call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
-                      stp(itype1), sfval=sfval, sfderiv_i=sfderiv_i, &
-                      sfderiv_j=sfderiv_j)
-
-        if (do_debug) then
-           do idbg = 1, stp(itype1)%nsf
-              write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
-           end do
-           write(u_dbg,*)
-        end if
-
-        if (inp%do_timing) call tng_timing3(register=R_SF)
-
-        ! write basis function values and derivatives
-        ! to the training set file:
-        call ts_write_sf_info(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf))
-
-        ! write basis function derivatives and neighbor list to pytorch output
-        if (inp%pyo_forces .and. pyo_forces_struc==1) then
-          max_nnb_trainset = max(max_nnb_trainset, nnb)
-          call pyo_write_atom_sf_info(u_pyo, itype1, nnb, stp(itype1)%nsf, nblist(:nnb), &
-                                      sfderiv_i(1:3,1:stp(itype1)%nsf), &
-                                      sfderiv_j(1:3,1:stp(itype1)%nsf,1:nnb) )
-        end if
-
-     end do atoms
-
-     if (inp%do_timing) then
-        call tng_dump(R_GEO, 'time spent reading geometries (so far)')
-        call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
-        call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
-     end if
-
-     call lcl_final()
-     call geo_final()
-
-  end do structures
-  write(*,*)
-
-  if (inp%do_timing) then
-     call tng_timing('Loop over structures done.')
-     call tng_dump(R_GEO, 'total time spent reading geometries')
-     call tng_dump(R_NBL, 'total time spent in the neighbor list')
-     call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
-  end if
-
-  !--------- save basis function setups with final statistics ---------!
-
-  call ts_print_info(ts)
-
-  !----------------------------- finalize -----------------------------!
-
-  deallocate(nbcoo, nbdist, nblist, nbtype)
-  close(u_in)
   
-  if (inp%pyo_forces) then
-    call pyo_write_final(u_pyo, max_nnb_trainset)
-  end if
+    subroutine initialize(inFile)
+  
+      implicit none
+  
+      character(len=*), intent(out) :: inFile
+  
+      integer :: nargs
+      logical :: fexists
+  
+      call aeio_header("generate.x - training set generation", char='=')
+      write(ionum,*)
+  
+      call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+  
+      nargs = command_argument_count()
+      if (nargs < 1) then
+         write(0,*) "Error: No input file provided."
+         call print_usage()
+         call finalize()
+         stop
+      end if
+  
+      call get_command_argument(1, value=inFile)
+      inquire(file=trim(inFile), exist=fexists)
+      if (.not. fexists) then
+         write(0,*) "Error: File not found: ", trim(inFile)
+         call print_usage()
+         call finalize()
+         stop
+      end if
+  
+    end subroutine initialize
 
-  call close_TrnSet(ts, stp=stp(1:inp%nTypes))
-  call finalize()
+    subroutine print_usage()
 
+        implicit none
 
-contains !=============================================================!
+        write(ionum,*)
+        write(ionum,*) "generate.x -- Generate training sets for use with `train.x'"
+        write(ionum,'(1x,70("-"))')
+        write(ionum,*) 'Usage: generate.x <input-file>'
+        write(ionum,*)
+        write(ionum,*) 'See the documentation or the source code for a description of the '
+        write(ionum,*) 'input file format.'
+        write(ionum,*)
 
-
-  subroutine initialize(inFile)
-
-    implicit none
-
-    character(len=*), intent(out) :: inFile
-
-    integer :: nargs
-    logical :: fexists
-
-    call aeio_header("generate.x - training set generation", char='=')
-    write(*,*)
-
-    call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
-
-    nargs = command_argument_count()
-    if (nargs < 1) then
-       write(0,*) "Error: No input file provided."
-       call print_usage()
-       call finalize()
-       stop
-    end if
-
-    call get_command_argument(1, value=inFile)
-    inquire(file=trim(inFile), exist=fexists)
-    if (.not. fexists) then
-       write(0,*) "Error: File not found: ", trim(inFile)
-       call print_usage()
-       call finalize()
-       stop
-    end if
-
-  end subroutine initialize
-
-  !--------------------------------------------------------------------!
-
-  subroutine finalize()
-
-    implicit none
-
-    integer :: itype
-
-    if (allocated(sfval)) then
-       deallocate(sfval, sfderiv_i, sfderiv_j)
-    end if
-
-    if (allocated(stp)) then
-       call stp_final(inp%nTypes, stp)
-       do itype = 1, inp%nTypes
-          call del_Setup(stp(itype))
-       end do
-       deallocate(stp, inp%typeName, inp%atomicEnergy)
-    end if
-
-    if (ts%init) call close_TrnSet(ts)
-
-    if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
-
-    if (inp%do_timing) call tng_final()
-    if (do_debug)  close(u_dbg)
-
-    call aeio_header(aeio_timestamp(), char=' ')
-    call aeio_header("Training set generation done.", char='=')
-
-  end subroutine finalize
-
-  !--------------------------------------------------------------------!
-
-  subroutine print_usage()
-
-    implicit none
-
-    write(*,*)
-    write(*,*) "generate.x -- Generate training sets for use with `train.x'"
-    write(*,'(1x,70("-"))')
-    write(*,*) 'Usage: generate.x <input-file>'
-    write(*,*)
-    write(*,*) 'See the documentation or the source code for a description of the '
-    write(*,*) 'input file format.'
-    write(*,*)
-
   end subroutine print_usage
 
-  !--------------------------------------------------------------------!
-
-  subroutine load_symmfunc_setups(inp, stp)
-
-    implicit none
-
-    type(InputData),           intent(in)  :: inp
-    type(Setup), dimension(:), intent(out) :: stp
-
-    integer :: i
-
-    do i = 1, inp%nTypes
-       stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
-       if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
-          write(0,*) "Error: Inconsistent atom type in setup:"
-          write(0,*) "       type expected : ", trim(inp%typeName(i))
-          write(0,*) "       type found    : ", trim(stp(i)%atomtype)
-          call finalize()
-          stop
-       end if
-    end do
-
-  end subroutine load_symmfunc_setups
-
-end program generate
+  
+    !--------------------------------------------------------------------!
+  
+    subroutine finalize()
+  
+      implicit none
+  
+      integer :: itype
+  
+  
+      call aeio_header(aeio_timestamp(), char=' ')
+      call aeio_header("Training set generation done.", char='=')
+  
+    end subroutine finalize
+end program generate
\ No newline at end of file
diff -Naru src/generate_MPI.F90 src_modified/generate_MPI.F90
--- src/generate_MPI.F90	1970-01-01 09:00:00
+++ src_modified/generate_MPI.F90	2024-09-06 22:00:25
@@ -0,0 +1,131 @@
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2019 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!+ ---------------------------------------------------------------------
+!+ If you make use of AENET for your publication, please cite:
+!+ [1] N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.
+!+ [2] J. Behler and M. Parrinello, Phys. Rev. Lett. 98 (2007) 146401.
+!+
+!+ If you used the Chebyshev descriptor, please cite:
+!+ [3] N. Artrith, A. Urban, and G. Ceder, PRB 96 (2017) 014112.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+program generate
+   use aeio,     only: aeio_readline,        &
+                   aeio_header,          &
+                   aeio_timestamp,       &
+                   aeio_print_copyright, &
+                   PATHLEN, LINELEN
+   use aenet_generate_MPI,only:generate_subroutine_MPI 
+
+  use parallel,    only: pp_init,                &
+                         pp_final,               &
+                         pp_bcast,               &
+                         pp_barrier,             &
+                         ppMaster,               &
+                         ppRank,                 &
+                         ppSize,                 &
+                         pp_bcast_InputData,     &
+                         pp_bcast_Setup   
+
+   use aenet_mpimodule
+
+
+   implicit none
+   character(len=PATHLEN)                         :: inFile
+   integer::ionum
+   integer::ierr
+
+
+   ionum= 139
+   call initialize_MPI(inFile)
+   call generate_subroutine_MPI(inFile,ionum)
+
+
+   contains 
+
+   subroutine initialize_MPI(inFile)
+
+    implicit none
+#ifdef PARALLEL
+    include 'mpif.h'
+#endif
+
+    character(len=*), intent(out) :: inFile
+
+    integer :: nargs
+    logical :: fexists
+    logical :: stopnow
+    integer::ierr
+
+#ifdef PARALLEL
+    call MPI_Init(ierr)
+#endif
+
+    call pp_init()
+
+    stopnow = .false.
+
+    if (ppMaster) then
+
+       !call aeio_header("generate.x - training set generation", char='=')
+       !write(*,*)
+
+       !call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+
+       nargs = command_argument_count()
+       if (nargs < 1) then
+          write(0,*) "Error: No input file provided."
+          call print_usage()
+          stopnow = .true.
+       end if
+
+       call get_command_argument(1, value=inFile)
+       inquire(file=trim(inFile), exist=fexists)
+       if (.not. fexists) then
+          write(0,*) "Error: File not found: ", trim(inFile)
+          stopnow = .true.
+       end if
+
+    end if
+
+    call pp_bcast(stopnow)
+    if (stopnow) then
+       stop
+    end if
+
+    call pp_bcast(inFile)
+
+  end subroutine initialize_MPI
+
+
+  subroutine print_usage()
+
+   implicit none
+
+   write(*,*)
+   write(*,*) "generate.x -- Generate training sets for use with `train.x'"
+   write(*,'(1x,70("-"))')
+   write(*,*) 'Usage: generate.x <input-file>'
+   write(*,*)
+   write(*,*) 'See the documentation or the source code for a description of the '
+   write(*,*) 'input file format.'
+   write(*,*)
+
+ end subroutine print_usage
+
+end program
\ No newline at end of file
diff -Naru src/generate_original.f90 src_modified/generate_original.f90
--- src/generate_original.f90	1970-01-01 09:00:00
+++ src_modified/generate_original.f90	2024-09-06 10:37:30
@@ -0,0 +1,542 @@
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2019 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!+ ---------------------------------------------------------------------
+!+ If you make use of AENET for your publication, please cite:
+!+ [1] N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.
+!+ [2] J. Behler and M. Parrinello, Phys. Rev. Lett. 98 (2007) 146401.
+!+
+!+ If you used the Chebyshev descriptor, please cite:
+!+ [3] N. Artrith, A. Urban, and G. Ceder, PRB 96 (2017) 014112.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+program generate
+
+  use aeio,     only: aeio_readline,        &
+                      aeio_header,          &
+                      aeio_timestamp,       &
+                      aeio_print_copyright, &
+                      PATHLEN, LINELEN
+
+  use geometry, only: geo_init,          &
+                      geo_final,         &
+                      geo_itype_of_name, &
+                      geo_type_conv,     &
+                      pbc,               &
+                      latticeVec,        &
+                      nAtoms,            &
+                      nTypes,            &
+                      atomType,          &
+                      atomTypeName,      &
+                      cooLatt,           &
+                      cooCart,           &
+                      forCart,           &
+                      hasEnergy,         &
+                      hasForces,         &
+                      cohesiveEnergy,    &
+                      totalEnergy
+
+  use input,    only: InputData,         &
+                      read_InpGenerate,  &
+                      del_InputData
+
+  use io,       only: io_adjustl,        &
+                      io_center,         &
+                      io_lower,          &
+                      io_readnext,       &
+                      io_unit
+
+  use lclist,   only: lcl_init,          &
+                      lcl_final,         &
+                      lcl_print_info,    &
+                      lcl_nmax_nbdist,   &
+                      lcl_nbdist_cart
+
+  use sfsetup,  only: Setup,                 &
+                      read_Setup_parameters, &
+                      save_Setup,            &
+                      del_Setup,             &
+                      stp_init,              &
+                      stp_final,             &
+                      stp_get_range,         &
+                      stp_print_info,        &
+                      stp_eval,              &
+                      nsf_max
+
+  use timing,   only: tng_init,          &
+                      tng_final,         &
+                      tng_timing,        &
+                      tng_timing2,       &
+                      tng_timing3,       &
+                      tng_dump
+
+  use trainset, only: TrnSet,                 &
+                      new_TrnSet,             &
+                      close_TrnSet,           &
+                      ts_print_info,          &
+                      ts_write_header,        &
+                      ts_write_sf_info,       &
+                      ts_write_atom_info,     &
+                      ts_write_structure_info
+
+  use pytorchoutput, only: pyo_write_init,               &
+                           pyo_write_final,              &
+                           pyo_write_header_info,        &
+                           pyo_write_structure_info,     &
+                           pyo_write_atom_sf_info,       &
+                           pyo_select_force_structures!, &
+
+  implicit none
+
+  !--------------------------------------------------------------------!
+  ! stp(i)         structural fingerprint basis setup for atom type i  !
+  ! r_min, r_max   lower and upper bound for atomic interactions       !
+  ! ts             training set reference                              !
+  !                                                                    !
+  ! nnb_max, nnb   max. and actual number of neighboring atoms         !
+  ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
+  !                neighboring atom                                    !
+  ! nbdist(i)      distance of the i-th neighbor                       !
+  !                                                                    !
+  ! sfval(i)         value of the i-th basis function                  !
+  ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
+  !                  with respect to the central atom                  !
+  !                  sfderiv_i(3,nsf_max)                              !
+  ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
+  !                  with respect to the coordinates of atom k         !
+  !                  sfderiv_j(3,nsf_max,nnb_max)                      !
+  !                                                                    !
+  ! E_coh          cohesive energy                                     !
+  ! nFiles_inv     = 1/inp%nStrucs                                     !
+  !                                                                    !
+  ! inFile         name of the input file for the generate.x program   !
+  ! cooFile        name of the currently active structure file         !
+  ! keyword        the last keyword read from the input file           !
+  !                                                                    !
+  ! do_debug       if .true., additional files containing debugging    !
+  !                info will be created                                !
+  !                                                                    !
+  ! u_*            file units                                          !
+  !--------------------------------------------------------------------!
+
+  type(InputData)                                :: inp
+
+  type(Setup),       dimension(:),   allocatable :: stp
+  double precision                               :: r_min, r_max
+  type(TrnSet)                                   :: ts
+
+  integer                                        :: nnb_max, nnb
+  double precision,  dimension(:,:), allocatable :: nbcoo
+  double precision,  dimension(:),   allocatable :: nbdist
+  integer,  dimension(:),   allocatable :: nblist
+  integer,           dimension(:),   allocatable :: nbtype
+
+  double precision, dimension(:),     allocatable :: sfval
+  double precision, dimension(:,:),   allocatable :: sfderiv_i
+  double precision, dimension(:,:,:), allocatable :: sfderiv_j
+
+  double precision                               :: E_coh
+  integer                                        :: ifile
+  double precision                               :: nFiles_inv
+
+  character(len=PATHLEN)                         :: inFile
+  character(len=PATHLEN)                         :: cooFile
+  character(len=LINELEN)                         :: keyword
+
+  integer                                        :: itype1
+  integer                                        :: itype, iatom
+
+  integer                                        :: iline
+  character(len=1024)                            :: line
+
+  integer                                        :: u_in, u_tng
+  logical                                        :: do_debug = .false.
+  integer                                        :: u_dbg, idbg
+
+  integer                                        :: u_pyo, max_nnb_trainset, pyo_forces_struc
+  integer, allocatable                           :: struc_write_force(:)
+
+  integer :: i
+
+  ! timing registers
+  integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
+
+  !-------------------------- initialization --------------------------!
+
+  call initialize(inFile)
+
+  inp = read_InpGenerate(inFile)
+  allocate(stp(inp%nTypes))
+  call load_symmfunc_setups(inp, stp)
+
+  ! call parse_input(inFile)
+
+  if (inp%do_timing) then
+     u_tng = io_unit()
+     call tng_init(unit=u_tng, file='generate.time', registers=3)
+     write(*,*) 'Timing info will be written to: ', 'generate.time'
+     write(*,*)
+  end if
+  if (do_debug) then
+     u_dbg = io_unit()
+     open(u_dbg, file='generate.debug', status='replace', action='write')
+  end if
+
+  ! get interaction range and max. number of atoms within range
+  call stp_get_range(inp%nTypes, stp, r_min, r_max)
+  nnb_max = lcl_nmax_nbdist(r_min, r_max)
+  allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nblist(nnb_max),nbtype(nnb_max))
+
+  ! initialize workspace for structural fingerprint basis:
+  call stp_init(inp%nTypes, stp, nnb_max)
+  if (inp%do_timing) call tng_timing('Structural fingerprint basis initialized.')
+
+  ! allocate workspace for basis function evaluation:
+  allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
+  sfval(:) = 0.0d0
+  sfderiv_i(:,:) = 0.0d0
+  sfderiv_j(:,:,:) = 0.0d0
+
+  call aeio_header('Generation of training set started')
+  write(*,*)
+
+  write(*,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
+  write(*,'(1x,"types                 : ")', advance='no')
+  do itype = 1, inp%nTypes
+     if (mod(itype,7) == 0) write(*,'(29x)')
+     write(*,'(A5,1x)', advance='no') inp%typeName(itype)
+  end do
+  write(*,*)
+  write(*,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
+  write(*,*)
+
+  !-------------- write basis function settings to stdout -------------!
+
+  call aeio_header("Structural fingerprint basis set-up")
+  write(*,*)
+
+  do itype1 = 1, inp%nTypes
+     call stp_print_info(stp(itype1))
+  end do
+
+  !----------- write training set header to the output file -----------!
+
+  ts = new_TrnSet(inp%nTypes, inp%typeName, inp%atomicEnergy, &
+                  inp%nStrucs, trim(inp%outFileName))
+
+  if (inp%do_timing) call tng_timing('Training set file started.')
+
+  !--------------- write pytorch force training header ----------------!
+  
+  if (inp%pyo_forces) then
+    u_pyo = io_unit()
+    call pyo_write_init(u_pyo, trim(inp%outFileName)//".forces")
+    call pyo_write_header_info(u_pyo, inp%nStrucs)
+    call pyo_select_force_structures(inp%nStrucs, inp%pyo_forces_percent, struc_write_force)
+    max_nnb_trainset = 0
+  endif
+
+  !------------------ iterate over coordinates files ------------------!
+
+  call aeio_header("Adding structures to the training set")
+  write(*,*)
+
+  u_in = io_unit()
+  open(u_in, file=inFile, status='old', action='read')
+  rewind(u_in)
+
+  iline = 0
+  do
+     ! forward until the FILES keyword:
+     call aeio_readline(u_in, iline, line)
+     read(line,*) keyword
+     if (trim(keyword) == 'FILES') then
+        read(u_in,*)
+        exit
+     end if
+  end do
+
+  ! header for stdout
+  write(*,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
+       'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
+
+  nFiles_inv = 1.0d0/dble(inp%nStrucs)
+  structures : do ifile = 1, inp%nStrucs
+
+     if (inp%do_timing) call tng_timing('Structure: '// io_adjustl(ifile))
+
+     call aeio_readline(u_in, iline, line)
+     cooFile = trim(line)
+
+     call geo_init(cooFile, 'xsf')
+     if (inp%do_timing) call tng_timing3(register=R_GEO)
+     if (.not. (hasForces .and. hasEnergy)) then
+        write(0,*) ">>>", hasForces, hasEnergy
+        write(0,*) "Error: incomplete output data in : ", trim(cooFile)
+        call finalize()
+        stop
+     end if
+
+     if (nTypes > inp%nTypes) then
+        write(*,*) 'Skipping ', trim(adjustl(cooFile)), &
+                   ': too many atomic species'
+        call geo_final()
+        cycle structures
+     end if
+
+     if (abs(cohesiveEnergy) /= 0.0d0) then
+        E_coh = cohesiveEnergy
+     else
+        ! if only the total energy is available, we have to calculate
+        ! the cohesive energy at this point
+        E_coh = totalEnergy
+        do iatom = 1, nAtoms
+           itype1 = atomType(iatom)
+           itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                  inp%nTypes, inp%typeName)
+           E_coh = E_coh - inp%atomicEnergy(itype1)
+        end do
+     end if
+
+     write(*,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
+          ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
+          trim(adjustl(cooFile))
+
+     call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
+     if (inp%do_timing) call tng_timing3(register=R_NBL)
+
+     ! write structure info (atoms, types, energy) to training set file:
+     call ts_write_structure_info(ts, cooFile, nAtoms, nTypes, E_coh)
+     
+     ! write structure info (atoms, types) to pytorch forces file:
+     if (inp%pyo_forces) then
+       pyo_forces_struc = struc_write_force(ifile)
+       call pyo_write_structure_info(u_pyo, cooFile, nAtoms, nTypes, pyo_forces_struc)
+     end if
+
+     atoms : do iatom = 1, nAtoms
+
+        ! determine the training atom type of atom `iatom' in global
+        ! index terms
+        itype1 = atomType(iatom)
+        itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                               inp%nTypes, inp%typeName)
+
+        ! assert that atom type is included in the set-ups:
+        if (itype1 == 0) then
+           write(0,*) "Error: not a valid structure    : ", trim(cooFile)
+           write(0,*) "       Additional species found."
+           call finalize()
+           stop
+        end if
+
+        ! write atom info (species, forces) to training set file:
+        call ts_write_atom_info(ts, itype1, cooCart(iatom), forCart(iatom))
+
+        ! get all atoms within cut-off:
+        nnb = nnb_max
+        call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nblist=nblist, nbtype=nbtype)
+
+        if (inp%do_timing) call tng_timing3(register=R_NBL)
+        write(*,'(1x,I6,2x,A2,2x,I6)') &
+             iatom, trim(atomTypeName(atomType(iatom))), nnb
+
+        ! convert atom types to global index:
+        do i = 1, nnb
+           nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
+                                    inp%nTypes, inp%typeName)
+           if (nbtype(i) == 0) then
+              write(0,*) "Error: atom type not found in setup."
+              call finalize()
+              stop
+           end if
+        end do
+
+        ! evaluate the structural fingerprint basis function set-up:
+        call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
+                      stp(itype1), sfval=sfval, sfderiv_i=sfderiv_i, &
+                      sfderiv_j=sfderiv_j)
+
+        if (do_debug) then
+           do idbg = 1, stp(itype1)%nsf
+              write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
+           end do
+           write(u_dbg,*)
+        end if
+
+        if (inp%do_timing) call tng_timing3(register=R_SF)
+
+        ! write basis function values and derivatives
+        ! to the training set file:
+        call ts_write_sf_info(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf))
+
+        ! write basis function derivatives and neighbor list to pytorch output
+        if (inp%pyo_forces .and. pyo_forces_struc==1) then
+          max_nnb_trainset = max(max_nnb_trainset, nnb)
+          call pyo_write_atom_sf_info(u_pyo, itype1, nnb, stp(itype1)%nsf, nblist(:nnb), &
+                                      sfderiv_i(1:3,1:stp(itype1)%nsf), &
+                                      sfderiv_j(1:3,1:stp(itype1)%nsf,1:nnb) )
+        end if
+
+     end do atoms
+
+     if (inp%do_timing) then
+        call tng_dump(R_GEO, 'time spent reading geometries (so far)')
+        call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
+        call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
+     end if
+
+     call lcl_final()
+     call geo_final()
+
+  end do structures
+  write(*,*)
+
+  if (inp%do_timing) then
+     call tng_timing('Loop over structures done.')
+     call tng_dump(R_GEO, 'total time spent reading geometries')
+     call tng_dump(R_NBL, 'total time spent in the neighbor list')
+     call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
+  end if
+
+  !--------- save basis function setups with final statistics ---------!
+
+  call ts_print_info(ts)
+
+  !----------------------------- finalize -----------------------------!
+
+  deallocate(nbcoo, nbdist, nblist, nbtype)
+  close(u_in)
+  
+  if (inp%pyo_forces) then
+    call pyo_write_final(u_pyo, max_nnb_trainset)
+  end if
+
+  call close_TrnSet(ts, stp=stp(1:inp%nTypes))
+  call finalize()
+
+
+contains !=============================================================!
+
+
+  subroutine initialize(inFile)
+
+    implicit none
+
+    character(len=*), intent(out) :: inFile
+
+    integer :: nargs
+    logical :: fexists
+
+    call aeio_header("generate.x - training set generation", char='=')
+    write(*,*)
+
+    call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+
+    nargs = command_argument_count()
+    if (nargs < 1) then
+       write(0,*) "Error: No input file provided."
+       call print_usage()
+       call finalize()
+       stop
+    end if
+
+    call get_command_argument(1, value=inFile)
+    inquire(file=trim(inFile), exist=fexists)
+    if (.not. fexists) then
+       write(0,*) "Error: File not found: ", trim(inFile)
+       call print_usage()
+       call finalize()
+       stop
+    end if
+
+  end subroutine initialize
+
+  !--------------------------------------------------------------------!
+
+  subroutine finalize()
+
+    implicit none
+
+    integer :: itype
+
+    if (allocated(sfval)) then
+       deallocate(sfval, sfderiv_i, sfderiv_j)
+    end if
+
+    if (allocated(stp)) then
+       call stp_final(inp%nTypes, stp)
+       do itype = 1, inp%nTypes
+          call del_Setup(stp(itype))
+       end do
+       deallocate(stp, inp%typeName, inp%atomicEnergy)
+    end if
+
+    if (ts%init) call close_TrnSet(ts)
+
+    if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
+
+    if (inp%do_timing) call tng_final()
+    if (do_debug)  close(u_dbg)
+
+    call aeio_header(aeio_timestamp(), char=' ')
+    call aeio_header("Training set generation done.", char='=')
+
+  end subroutine finalize
+
+  !--------------------------------------------------------------------!
+
+  subroutine print_usage()
+
+    implicit none
+
+    write(*,*)
+    write(*,*) "generate.x -- Generate training sets for use with `train.x'"
+    write(*,'(1x,70("-"))')
+    write(*,*) 'Usage: generate.x <input-file>'
+    write(*,*)
+    write(*,*) 'See the documentation or the source code for a description of the '
+    write(*,*) 'input file format.'
+    write(*,*)
+
+  end subroutine print_usage
+
+  !--------------------------------------------------------------------!
+
+  subroutine load_symmfunc_setups(inp, stp)
+
+    implicit none
+
+    type(InputData),           intent(in)  :: inp
+    type(Setup), dimension(:), intent(out) :: stp
+
+    integer :: i
+
+    do i = 1, inp%nTypes
+       stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
+       if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
+          write(0,*) "Error: Inconsistent atom type in setup:"
+          write(0,*) "       type expected : ", trim(inp%typeName(i))
+          write(0,*) "       type found    : ", trim(stp(i)%atomtype)
+          call finalize()
+          stop
+       end if
+    end do
+
+  end subroutine load_symmfunc_setups
+
+end program generate
diff -Naru src/makefiles/Makefile.ifort_intelmpi src_modified/makefiles/Makefile.ifort_intelmpi
--- src/makefiles/Makefile.ifort_intelmpi	2024-09-06 10:37:30
+++ src_modified/makefiles/Makefile.ifort_intelmpi	2024-09-06 10:37:30
@@ -27,11 +27,11 @@
 
 SUFFIX   = ifort_intelmpi
 
-FC       = mpiifort -c
-LD       = mpiifort
+FC       = mpiifx -traceback -check bounds -c
+LD       = mpiifx
 DEBUG    =
 FCFLAGS  = -DPARALLEL -O2 $(DEBUG)
-LDFLAGS  = -static-intel $(DEBUG)
+LDFLAGS  = -static-intel -DPARALLEL $(DEBUG)
 NUMLIB   = -Wl,--start-group \
            $(MKLROOT)/lib/intel64/libmkl_intel_lp64.a \
            $(MKLROOT)/lib/intel64/libmkl_core.a \
diff -Naru src/parallel.F90 src_modified/parallel.F90
--- src/parallel.F90	2024-09-06 10:37:30
+++ src_modified/parallel.F90	2024-09-06 16:26:38
@@ -3,7 +3,7 @@
 !-----------------------------------------------------------------------
 !+ This file is part of the AENET package.
 !+
-!+ Copyright (C) 2012-2019 Nongnuch Artrith and Alexander Urban
+!+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
 !+
 !+ This Source Code Form is subject to the terms of the Mozilla Public
 !+ License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -13,19 +13,12 @@
 !+ WITHOUT ANY WARRANTY; without even the implied warranty of
 !+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 !+ Mozilla Public License, v. 2.0, for more details.
-!+ ---------------------------------------------------------------------
-!+ If you make use of AENET for your publication, please cite:
-!+ [1] N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.
-!+ [2] J. Behler and M. Parrinello, Phys. Rev. Lett. 98 (2007) 146401.
-!+
-!+ If you used the Chebyshev descriptor, please cite:
-!+ [3] N. Artrith, A. Urban, and G. Ceder, PRB 96 (2017) 014112.
 !-----------------------------------------------------------------------
 !
 ! This module mainly provides generic interfaces to the FORTRAN 77 MPI
 ! bindings.  The MPI send, receive and broadcast operations are
 ! simplified for the case of a rank 0 master process and the single
-! communicator MPI_COMM_WORLD.
+! communicator mpi_comm_aenet.
 !
 ! The prodedures for sending and receiving derived types defined in
 ! this module only send primitive data types.  This is probably not
@@ -35,8 +28,28 @@
 ! 2011-11-10 Alexander Urban (AU), Nongnuch Artrith (NA)
 !-----------------------------------------------------------------------
 
+module aenet_mpimodule
+#ifdef PARALLEL
+   use mpi
+#endif
+!  use common_variables, only : mpi_comm_aenet_sub, myrank_sub, nprocs_sub
+  implicit none
+  !include 'mpif.h'
+  save
+#ifdef PARALLEL
+  !TYPE(mpi_comm), public :: mpi_comm_aenet = mpi_comm_world
+  integer, public :: mpi_comm_aenet = mpi_comm_world
+#endif
+end module aenet_mpimodule
 
+
+
+
 module parallel
+#ifdef PARALLEL
+  !use mpi_f08
+  use mpi
+#endif  
 
   use aeio,        only: aeio_header
 
@@ -54,14 +67,14 @@
 
   use trainset,    only: TrnSet,      &
                          new_TrnSet_info
+  use aenet_mpimodule,only:mpi_comm_aenet
 
   implicit none
   save
 
-#ifdef PARALLEL
-  include 'mpif.h'
-#endif
 
+!  include 'mpif.h'
+
   public::  pp_init,              &
             pp_final,             &
             pp_print_info,        &
@@ -88,7 +101,8 @@
             pp_bcast_NNPot,       &
             pp_bcast_coo,         &
             pp_bcast_latt,        &
-            pp_sum_weights
+            pp_sum_weights, &
+            set_isinit_false
 
   !------------------------------ public ------------------------------!
 
@@ -104,6 +118,7 @@
 
 #ifdef PARALLEL
   integer, dimension(MPI_STATUS_SIZE) :: status
+  !TYPE(MPI_Status):: status
 #endif
 
   !--------------------------------------------------------------------!
@@ -198,10 +213,22 @@
                       pp_sum_dn
   end interface
 
+  !--------------------------------------------------------------------!
+  !           training set file footer containing statistics           !
+  !--------------------------------------------------------------------!
 
+
+
+
 contains !=============================================================!
 
 
+  subroutine set_isinit_false()
+    implicit none
+    isInit = .false.
+    return
+  end subroutine set_isinit_false
+
   subroutine pp_init()
 
     implicit none
@@ -209,10 +236,10 @@
     if (isInit) return
 
 #ifdef PARALLEL
-    call MPI_Init(ierr)
+!    call MPI_Init(ierr)
 
-    call MPI_Comm_size(MPI_COMM_WORLD, ppSize, ierr)
-    call MPI_Comm_rank(MPI_COMM_WORLD, ppRank, ierr)
+    call mpi_comm_size(mpi_comm_aenet, ppSize, ierr)
+    call mpi_comm_rank(mpi_comm_aenet, ppRank, ierr)
 
     isParallel = .true.
 #endif
@@ -224,9 +251,103 @@
     end if
 
     isInit = .true.
+    
 
   end subroutine pp_init
 
+
+  subroutine pp_calc_and_Bcast_footer(ts, stp)
+
+    implicit none
+
+    type(TrnSet),intent(inout) :: ts
+    type(Setup), dimension(:), intent(inout) :: stp
+
+    real(8) :: E_max, E_min, E_av, E_avsum, E_avsum_sum,Etemp
+    integer :: nAtomsTot, nStrucs,ntemp
+    integer :: ierr, itype
+    integer :: neval,itemp
+    real(8), dimension(:), allocatable :: d2
+
+   !   calculate max, min, average
+    E_avsum = ts%E_av * dble(ts%nStrucs)
+#ifdef PARALLEL
+    call MPI_ALLREDUCE( ts%nAtomsTot, nAtomsTot, 1, MPI_INTEGER, MPI_SUM, mpi_comm_aenet, ierr )
+#endif
+    Etemp = ts%E_max
+    call pp_bcast(Etemp)
+    ts%E_max = max(ts%E_max,Etemp)
+#ifdef PARALLEL
+    call MPI_ALLREDUCE( ts%E_max, E_max, 1, MPI_DOUBLE_PRECISION, MPI_MAX, mpi_comm_aenet, ierr )
+#endif  
+    Etemp = ts%E_min
+    call pp_bcast(Etemp)
+    ts%E_min = min(ts%E_min,Etemp)
+
+#ifdef PARALLEL
+    call MPI_ALLREDUCE( ts%E_min, E_min, 1, MPI_DOUBLE_PRECISION, MPI_MIN, mpi_comm_aenet, ierr )
+#endif    
+    call MPI_ALLREDUCE( E_avsum, E_avsum_sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, mpi_comm_aenet, ierr )
+
+    itemp = ts%iStruc
+#ifdef PARALLEL
+    call MPI_ALLREDUCE( itemp, nStrucs, 1, MPI_INTEGER, MPI_SUM, mpi_comm_aenet, ierr )
+#endif
+
+    ts%nAtomsTot = nAtomsTot
+    ts%E_max = E_max
+    ts%E_min = E_min
+    ts%nStrucs = nStrucs
+    ts%iStruc = nStrucs
+    ts%E_av = E_avsum_sum / dble(ts%nStrucs)
+
+
+    if (ts%iStruc < ts%nStrucs) then
+       write(0,*) "Warning: writing footer to incomplete training set file."
+    end if
+
+    do itype = 1, ubound(stp,1)
+       stp(itype)%neval= max( stp(itype)%neval,0)
+#ifdef PARALLEL
+       call MPI_ALLREDUCE( stp(itype)%neval, neval, 1, MPI_INTEGER, MPI_SUM, mpi_comm_aenet, ierr )
+#endif
+       allocate(d2(1:ubound(stp(itype)%sfval_min,1)))
+#ifdef PARALLEL       
+       call MPI_ALLREDUCE( stp(itype)%sfval_min, d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_MIN, mpi_comm_aenet, ierr )
+#endif       
+       stp(itype)%sfval_min = d2
+       deallocate(d2)
+       allocate(d2(1:ubound(stp(itype)%sfval_max,1)))
+#ifdef PARALLEL       
+       call MPI_ALLREDUCE( stp(itype)%sfval_max, d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_MAX, mpi_comm_aenet, ierr )
+#endif       
+       stp(itype)%sfval_max = d2
+       deallocate(d2)
+       allocate(d2(1:ubound(stp(itype)%sfval_avg,1)))
+#ifdef PARALLEL       
+       call MPI_ALLREDUCE( stp(itype)%sfval_avg*stp(itype)%neval, &
+          d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_SUM, mpi_comm_aenet, ierr )
+#endif          
+       stp(itype)%sfval_avg = d2 / neval
+       deallocate(d2)
+       allocate(d2(1:ubound(stp(itype)%sfval_cov,1)))
+#ifdef PARALLEL       
+       call MPI_ALLREDUCE( stp(itype)%sfval_cov*stp(itype)%neval, &
+          d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_SUM, mpi_comm_aenet, ierr )
+#endif          
+       stp(itype)%sfval_cov = d2 / neval
+       deallocate(d2)
+
+       stp(itype)%neval = neval
+
+   !       write(*,*) 'CHECK', itype, stp(itype)%neval, &
+   !       stp(itype)%sfval_min(1), stp(itype)%sfval_max(1), stp(itype)%sfval_avg(1), &
+   !       stp(itype)%sfval_cov(1)
+
+    end do
+
+  end subroutine pp_calc_and_Bcast_footer    
+
   !--------------------------------------------------------------------!
 
   subroutine pp_final()
@@ -236,7 +357,7 @@
     if (.not. isInit) return
 
 #ifdef PARALLEL
-    call MPI_Finalize(ierr)
+!    call MPI_Finalize(ierr)
 #endif
 
     isInit     = .false.
@@ -367,6 +488,7 @@
     call pp_send(stp%nsf, dest)
     call pp_send(stp%nenv, dest)
     call pp_send(stp%ntypes_global, dest)
+    
 
     call pp_send(stp%neval, dest)
     call pp_send(stp%atomtype, dest)
@@ -376,6 +498,7 @@
 
     call pp_send(stp%envtypes, stp%nenv, dest)
     call pp_send(stp%gtype, stp%nenv, dest)
+
     call pp_send(stp%ltype, stp%ntypes_global, dest)
 
     call pp_send(stp%sf, stp%nsf, dest)
@@ -391,6 +514,9 @@
     call pp_send(stp%sfval_avg(1:stp%nsf), stp%nsf, dest)
     call pp_send(stp%sfval_cov(1:stp%nsf), stp%nsf, dest)
 
+    call pp_send(stp%init, dest)!added
+    call pp_send(stp%description, dest)!added
+
   end subroutine pp_send_Setup
 
   !--------------------------------------------------------------------!
@@ -401,7 +527,6 @@
 
     type(Setup) :: stp
     integer     :: isf, nsf, nenv, ntypes_global, nsfp
-
     if (.not. isParallel) return
 
     call pp_recv(nsf)
@@ -431,6 +556,9 @@
     call pp_recv(stp%sfval_avg(1:stp%nsf), nsf)
     call pp_recv(stp%sfval_cov(1:stp%nsf), nsf)
 
+    call pp_recv(stp%init)!added
+    call pp_recv(stp%description)!added
+
   end function pp_recv_Setup
 
   !--------------------------------------------------------------------!
@@ -723,6 +851,13 @@
 
     call pp_send(inp%mc_relax_final, dest)
 
+    call pp_send(inp%print_atomic_energies, dest)
+
+    call pp_send(inp%file, dest) !added
+    call pp_send(inp%outFileName, dest) !added
+    call pp_send(inp%verbosity, dest) !added  
+    call pp_send(inp%pyo_forces, dest) !added   
+
   end subroutine pp_send_InputData
 
   !--------------------------------------------------------------------!
@@ -833,6 +968,14 @@
 
     call pp_recv(inp%mc_relax_final)
 
+    call pp_recv(inp%print_atomic_energies)
+
+    call pp_recv(inp%file) !added
+    call pp_recv(inp%outFileName) !added
+
+    call pp_recv(inp%verbosity) !added    
+    call pp_recv(inp%pyo_forces) !added  
+
   end function pp_recv_InputData
 
   !--------------------------------------------------------------------!
@@ -956,7 +1099,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Barrier(MPI_COMM_WORLD, ierr)
+    call MPI_Barrier(mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_barrier
@@ -982,9 +1125,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, 1, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_INTEGER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, 1, MPI_INTEGER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_INTEGER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) val, root
@@ -1006,9 +1149,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_INTEGER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_INTEGER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_INTEGER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1029,9 +1172,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) val, root
@@ -1053,9 +1196,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1076,9 +1219,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, 1, MPI_LOGICAL, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_LOGICAL, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, 1, MPI_LOGICAL, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_LOGICAL, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) val, root
@@ -1100,9 +1243,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_LOGICAL, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_LOGICAL, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_LOGICAL, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_LOGICAL, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1127,9 +1270,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_CHARACTER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_CHARACTER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_CHARACTER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_CHARACTER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     n = root
@@ -1156,9 +1299,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, m, MPI_CHARACTER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, m, MPI_CHARACTER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, m, MPI_CHARACTER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, m, MPI_CHARACTER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1189,7 +1332,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, 1, MPI_INTEGER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, 1, MPI_INTEGER, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) val, dest
 #endif
@@ -1211,7 +1354,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, n, MPI_INTEGER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, n, MPI_INTEGER, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) n, val, dest
 #endif
@@ -1232,7 +1375,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, 1, MPI_DOUBLE_PRECISION, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, 1, MPI_DOUBLE_PRECISION, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) val, dest
 #endif
@@ -1254,7 +1397,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, n, MPI_DOUBLE_PRECISION, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, n, MPI_DOUBLE_PRECISION, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) n, val, dest
 #endif
@@ -1275,7 +1418,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, 1, MPI_LOGICAL, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, 1, MPI_LOGICAL, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) val, dest
 #endif
@@ -1299,7 +1442,7 @@
 
 #ifdef PARALLEL
     n = len(val)
-    call MPI_Send(val, n, MPI_CHARACTER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, n, MPI_CHARACTER, dest, tag, mpi_comm_aenet, ierr)
 #else
     n = dest
     write(*,*) val
@@ -1325,7 +1468,7 @@
 
 #ifdef PARALLEL
     m = len(val(1))
-    call MPI_Send(val, m*n, MPI_CHARACTER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, m*n, MPI_CHARACTER, dest, tag, mpi_comm_aenet, ierr)
 #else
     m = n*dest
     write(*,*) val
@@ -1357,10 +1500,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, 1, MPI_INTEGER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, 1, MPI_INTEGER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = src
@@ -1385,10 +1528,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, n, MPI_INTEGER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n, MPI_INTEGER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = n*src
@@ -1412,10 +1555,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, 1, MPI_DOUBLE_PRECISION, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, 1, MPI_DOUBLE_PRECISION, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = 1.0*src
@@ -1440,10 +1583,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, n, MPI_DOUBLE_PRECISION, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n, MPI_DOUBLE_PRECISION, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = 1.0d0*n*src
@@ -1467,10 +1610,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, 1, MPI_LOGICAL, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, 1, MPI_LOGICAL, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = (src == 1)
@@ -1497,10 +1640,10 @@
     n = len(val)
     if (present(src)) then
        call MPI_Recv(val, n, MPI_CHARACTER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n, MPI_CHARACTER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     n = src
@@ -1529,10 +1672,10 @@
     m = len(val(1))
     if (present(src)) then
        call MPI_Recv(val, n*m, MPI_CHARACTER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n*m, MPI_CHARACTER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     m = src
@@ -1562,7 +1705,7 @@
     buff = val
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, 1, MPI_INTEGER, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_i1
@@ -1582,7 +1725,7 @@
     buff(1:n) = val(1:n)
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, n, MPI_INTEGER, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_in
@@ -1601,7 +1744,7 @@
     buff = val
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, 1, MPI_DOUBLE_PRECISION, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_d1
@@ -1621,10 +1764,25 @@
     buff(1:n) = val(1:n)
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, n, MPI_DOUBLE_PRECISION, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_dn
 
 
 end module parallel
+
+
+
+
+subroutine set_mpi_aenet(mpi_comm_in)
+  use aenet_mpimodule
+  use parallel,only:set_isinit_false
+  !type(mpi_comm),intent(in)::mpi_comm_in
+  integer,intent(in)::mpi_comm_in
+  integer::ierr
+  call set_isinit_false()
+  call mpi_comm_dup(mpi_comm_in,mpi_comm_aenet,ierr)
+!  mpi_comm_aenet = mpi_comm
+  return
+end subroutine set_mpi_aenet
\ No newline at end of file
diff -Naru src/predict.F90 src_modified/predict.F90
--- src/predict.F90	2024-09-06 10:37:30
+++ src_modified/predict.F90	2024-09-06 10:37:30
@@ -33,7 +33,7 @@
   use aenet,     only: aenet_init,                     &
                        aenet_final,                    &
                        aenet_atomic_energy,            &
-                       aenet_atomic_energy_and_forces, &
+                       aenet_atomic_energy_and_forces_novirial, &
                        aenet_convert_atom_types,       &
                        aenet_free_atom_energy,         &
                        aenet_load_potential,           &
@@ -640,7 +640,7 @@
                             nblist=nblist, nbtype=nbtype)
 
        if (do_F) then
-          call aenet_atomic_energy_and_forces( &
+          call aenet_atomic_energy_and_forces_novirial( &
                coo_i, type_i, iatom, nnb, nbcoo, nbtype, nblist, &
                nAtoms, E_i, forCart, stat)
 #ifdef CHECK_FORCES
diff -Naru src/pytorchoutput_MPI.f90 src_modified/pytorchoutput_MPI.f90
--- src/pytorchoutput_MPI.f90	1970-01-01 09:00:00
+++ src_modified/pytorchoutput_MPI.f90	2024-09-06 10:37:30
@@ -0,0 +1,163 @@
+module pytorchoutput_MPI
+  use io,      only: io_adjustl, io_unit
+
+  implicit none
+  private
+  save
+
+  public :: pyo_write_structure_info_MPI,     &
+            pyo_write_atom_sf_info_MPI,&
+            pyo_loadandwrite       
+
+contains
+
+
+
+  !--------------------------------------------------------------------!
+  !--------------------------------------------------------------------!
+
+  subroutine pyo_write_structure_info_MPI(filename, natoms, ntypes, pyo_forces_struc,ifile)
+
+      implicit none
+  
+      integer, intent(in)          :: natoms, ntypes, pyo_forces_struc
+      character(len=*), intent(in) :: filename
+      integer,          intent(in)    :: ifile
+      integer,parameter :: pyo_unit = 1234
+
+      open(unit = pyo_unit, action = "write", status = "replace", file = 'ts.force.'//io_adjustl(ifile), form = "unformatted")    
+
+      write(pyo_unit) len_trim(filename)
+      write(pyo_unit) trim(filename)
+      write(pyo_unit) natoms, ntypes
+      write(pyo_unit) pyo_forces_struc
+      
+  end subroutine pyo_write_structure_info_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine pyo_write_atom_sf_info_MPI(itype, nnb, nsf, nblist, sfderiv_i, sfderiv_j,ifile)
+
+      implicit none
+
+      integer,                            intent(in) ::  nnb, nsf, itype
+      integer,          dimension(:),     intent(in) :: nblist
+      double precision, dimension(:,:),   intent(in) :: sfderiv_i
+      double precision, dimension(:,:,:), intent(in) :: sfderiv_j
+      integer,          intent(in)    :: ifile
+
+      double precision                               :: sfderiv_j_aux(nnb, nsf, 3), sfderiv_i_aux(nsf,3)
+
+      integer :: ineigh, isf, icoo
+      integer,parameter :: pyo_unit = 1234
+
+      !call pyo_write_init(u_pyo, trim(inp%outFileName)//".forces.tmp")
+      !call pyo_write_header_info(u_pyo, inp%nStrucs)
+      !call pyo_select_force_structures(inp%nStrucs, inp%pyo_forces_percent, struc_write_force)
+     
+
+      open(unit = pyo_unit, action = "write", file = 'ts.force.'//io_adjustl(ifile), form='unformatted', position='append')  
+
+      sfderiv_j_aux = 0.0d0
+      sfderiv_i_aux = 0.0d0
+      do ineigh = 1, nnb
+        do isf = 1, nsf
+          sfderiv_j_aux(ineigh, isf, :) = sfderiv_j(:, isf, ineigh)
+        enddo
+      enddo
+      do isf = 1, nsf
+        sfderiv_i_aux(isf,:) = sfderiv_i(:,isf)
+      enddo
+
+      write(pyo_unit) itype
+      write(pyo_unit) nsf, nnb
+      write(pyo_unit) nblist(1:nnb)
+      write(pyo_unit) sfderiv_i_aux(1:nsf,1:3)
+      write(pyo_unit) sfderiv_j_aux(1:nnb,1:nsf,1:3)
+      
+      
+  end subroutine pyo_write_atom_sf_info_MPI
+
+ 
+  subroutine pyo_loadandwrite(headfile)
+    implicit none
+    character(len=*),intent(in)::headfile
+    integer,parameter:: pyo_head = 902
+    integer::ifile
+    character(len=100)::filenameload
+    integer::l
+    integer::nAtoms,ntypes,pyo_forces_struc
+
+    integer,parameter :: pyo_unitall = 545
+    integer::nstrucs
+    integer,parameter::pyo_file = 1092
+    integer::iatom
+    integer::itype,nsf,nnb,max_nnb_trainset
+
+    double precision, allocatable,dimension(:,:):: sfderiv_i_aux
+    double precision, allocatable,dimension(:,:,:):: sfderiv_j_aux
+    integer,          allocatable,dimension(:) :: nblist
+
+    open (pyo_unitall, file='pyo.all', status='replace',form='unformatted')
+    open(unit = pyo_head,  status = "old", file = headfile, form = "unformatted")
+
+    
+
+    read(pyo_head) nstrucs
+    write(pyo_unitall) nstrucs
+
+    read(pyo_head) max_nnb_trainset
+
+    do ifile = 1, nStrucs
+      ! call pyo_write_structure_info_MPI(cooFile, nAtoms, nTypes, pyo_forces_struc,ifile)
+      open(unit = pyo_file,  status = "old", file = 'ts.force.'//io_adjustl(ifile), form = "unformatted")
+      read(pyo_file) l
+      filenameload = " "
+      l = min(l,len(filenameload))
+      read(pyo_file) filenameload(1:l)
+
+      read(pyo_file) natoms, ntypes
+      read(pyo_file) pyo_forces_struc
+
+      write(pyo_unitall) len_trim(filenameload)
+      write(pyo_unitall) trim(filenameload)
+      write(pyo_unitall) natoms, ntypes
+      write(pyo_unitall) pyo_forces_struc
+
+      atoms : do iatom = 1, nAtoms
+        if (pyo_forces_struc==1) then
+          !max_nnb_trainset = max(max_nnb_trainset, nnb)
+          !call pyo_write_atom_sf_info_MPI(itype1, nnb, stp(itype1)%nsf, nblist(:nnb), &
+          !                            sfderiv_i(1:3,1:stp(itype1)%nsf), &
+          !                            sfderiv_j(1:3,1:stp(itype1)%nsf,1:nnb) ,ifile)
+          read(pyo_file) itype
+          read(pyo_file) nsf, nnb
+          allocate(nblist(1:nnb))
+
+          read(pyo_file) nblist(1:nnb)
+          allocate(sfderiv_i_aux(1:nsf,1:3))
+          read(pyo_file) sfderiv_i_aux(1:nsf,1:3)
+          allocate(sfderiv_j_aux(1:nnb,1:nsf,1:3))
+          read(pyo_file) sfderiv_j_aux(1:nnb,1:nsf,1:3)
+
+          write(pyo_unitall) itype
+          write(pyo_unitall) nsf, nnb
+          write(pyo_unitall) nblist(1:nnb)
+          write(pyo_unitall) sfderiv_i_aux(1:nsf,1:3)
+          write(pyo_unitall) sfderiv_j_aux(1:nnb,1:nsf,1:3)
+          deallocate(nblist,sfderiv_i_aux,sfderiv_j_aux)
+        end if
+      end do atoms
+      close(pyo_file)
+    end do
+
+    
+    write(pyo_unitall) max_nnb_trainset
+
+    close(pyo_unitall)
+    close(pyo_head)
+
+
+  end subroutine
+
+end module pytorchoutput_MPI
\ No newline at end of file
diff -Naru src/sfsetup.f90 src_modified/sfsetup.f90
--- src/sfsetup.f90	2024-09-06 10:37:30
+++ src_modified/sfsetup.f90	2024-09-06 10:37:30
@@ -310,8 +310,10 @@
     end if
 
     ! connect local atom type IDs with global ones
+    
     allocate(stp%gtype(stp%nenv), stp%ltype(ntypes_global))
     call stp_set_global_types(stp, ntypes_global, global_types)
+    stp%ntypes_global = ntypes_global !added
 
     stp%init = .true.
 
@@ -781,8 +783,9 @@
     integer            :: nG_max
 
     if (isInit) then
-       write(0,*) "Error: module already initialized in `stp_init'."
-       stop
+      return
+      ! write(0,*) "Error: module already initialized in `stp_init'."
+      ! stop
     end if
 
     sftype = trim(stp(1)%sftype)
diff -Naru src/sub_generate.f90 src_modified/sub_generate.f90
--- src/sub_generate.f90	1970-01-01 09:00:00
+++ src_modified/sub_generate.f90	2024-09-06 10:37:30
@@ -0,0 +1,568 @@
+module aenet_generate 
+   use aenet_trainbin2ascii,only:trainbin2ascii_subroutine
+implicit none
+contains 
+
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2019 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!+ ---------------------------------------------------------------------
+!+ If you make use of AENET for your publication, please cite:
+!+ [1] N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.
+!+ [2] J. Behler and M. Parrinello, Phys. Rev. Lett. 98 (2007) 146401.
+!+
+!+ If you used the Chebyshev descriptor, please cite:
+!+ [3] N. Artrith, A. Urban, and G. Ceder, PRB 96 (2017) 014112.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+subroutine generate_subroutine(inFile,ionum)
+
+    use aeio,     only: aeio_readline,        &
+                        aeio_header,          &
+                        aeio_timestamp,       &
+                        aeio_print_copyright, &
+                        PATHLEN, LINELEN
+  
+    use geometry, only: geo_init,          &
+                        geo_final,         &
+                        geo_itype_of_name, &
+                        geo_type_conv,     &
+                        pbc,               &
+                        latticeVec,        &
+                        nAtoms,            &
+                        nTypes,            &
+                        atomType,          &
+                        atomTypeName,      &
+                        cooLatt,           &
+                        cooCart,           &
+                        forCart,           &
+                        hasEnergy,         &
+                        hasForces,         &
+                        cohesiveEnergy,    &
+                        totalEnergy
+  
+    use input,    only: InputData,         &
+                        read_InpGenerate,  &
+                        del_InputData
+  
+    use io,       only: io_adjustl,        &
+                        io_center,         &
+                        io_lower,          &
+                        io_readnext,       &
+                        io_unit
+  
+    use lclist,   only: lcl_init,          &
+                        lcl_final,         &
+                        lcl_print_info,    &
+                        lcl_nmax_nbdist,   &
+                        lcl_nbdist_cart
+  
+    use sfsetup,  only: Setup,                 &
+                        read_Setup_parameters, &
+                        save_Setup,            &
+                        del_Setup,             &
+                        stp_init,              &
+                        stp_final,             &
+                        stp_get_range,         &
+                        stp_print_info,        &
+                        stp_eval,              &
+                        nsf_max
+  
+    use timing,   only: tng_init,          &
+                        tng_final,         &
+                        tng_timing,        &
+                        tng_timing2,       &
+                        tng_timing3,       &
+                        tng_dump
+  
+    use trainset, only: TrnSet,                 &
+                        new_TrnSet,             &
+                        close_TrnSet,           &
+                        ts_print_info,          &
+                        ts_write_header,        &
+                        ts_write_sf_info,       &
+                        ts_write_atom_info,     &
+                        ts_write_structure_info
+  
+    use pytorchoutput, only: pyo_write_init,               &
+                             pyo_write_final,              &
+                             pyo_write_header_info,        &
+                             pyo_write_structure_info,     &
+                             pyo_write_atom_sf_info,       &
+                             pyo_select_force_structures!, &
+  
+    implicit none
+  
+    !--------------------------------------------------------------------!
+    ! stp(i)         structural fingerprint basis setup for atom type i  !
+    ! r_min, r_max   lower and upper bound for atomic interactions       !
+    ! ts             training set reference                              !
+    !                                                                    !
+    ! nnb_max, nnb   max. and actual number of neighboring atoms         !
+    ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
+    !                neighboring atom                                    !
+    ! nbdist(i)      distance of the i-th neighbor                       !
+    !                                                                    !
+    ! sfval(i)         value of the i-th basis function                  !
+    ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
+    !                  with respect to the central atom                  !
+    !                  sfderiv_i(3,nsf_max)                              !
+    ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
+    !                  with respect to the coordinates of atom k         !
+    !                  sfderiv_j(3,nsf_max,nnb_max)                      !
+    !                                                                    !
+    ! E_coh          cohesive energy                                     !
+    ! nFiles_inv     = 1/inp%nStrucs                                     !
+    !                                                                    !
+    ! inFile         name of the input file for the generate.x program   !
+    ! cooFile        name of the currently active structure file         !
+    ! keyword        the last keyword read from the input file           !
+    !                                                                    !
+    ! do_debug       if .true., additional files containing debugging    !
+    !                info will be created                                !
+    !                                                                    !
+    ! u_*            file units                                          !
+    !--------------------------------------------------------------------!
+  
+    type(InputData)                                :: inp
+  
+    type(Setup),       dimension(:),   allocatable :: stp
+    double precision                               :: r_min, r_max
+    type(TrnSet)                                   :: ts
+  
+    integer                                        :: nnb_max, nnb
+    double precision,  dimension(:,:), allocatable :: nbcoo
+    double precision,  dimension(:),   allocatable :: nbdist
+    integer,  dimension(:),   allocatable :: nblist
+    integer,           dimension(:),   allocatable :: nbtype
+  
+    double precision, dimension(:),     allocatable :: sfval
+    double precision, dimension(:,:),   allocatable :: sfderiv_i
+    double precision, dimension(:,:,:), allocatable :: sfderiv_j
+  
+    double precision                               :: E_coh
+    integer                                        :: ifile
+    double precision                               :: nFiles_inv
+
+    character(len=*),intent(in)                    :: inFile
+    integer,intent(in)                             :: ionum
+  
+    !character(len=PATHLEN)                         :: inFile
+    character(len=PATHLEN)                         :: cooFile
+    character(len=LINELEN)                         :: keyword
+  
+    integer                                        :: itype1
+    integer                                        :: itype, iatom
+  
+    integer                                        :: iline
+    character(len=1024)                            :: line
+  
+    integer                                        :: u_in, u_tng
+    logical                                        :: do_debug = .false.
+    integer                                        :: u_dbg, idbg
+  
+    integer                                        :: u_pyo, max_nnb_trainset, pyo_forces_struc
+    integer, allocatable                           :: struc_write_force(:)
+  
+    integer :: i
+  
+    ! timing registers
+    integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
+
+    character(len=1024)::outfilename_ascii
+    character(len=1024)::outFileName
+    logical ::to_bin,to_ascii
+  
+    !-------------------------- initialization --------------------------!
+  
+    !call initialize(inFile)
+  
+    inp = read_InpGenerate(inFile)
+    allocate(stp(inp%nTypes))
+    call load_symmfunc_setups(inp, stp)
+  
+    ! call parse_input(inFile)
+  
+    if (inp%do_timing) then
+       u_tng = io_unit()
+       call tng_init(unit=u_tng, file='generate.time', registers=3)
+       write(ionum,*) 'Timing info will be written to: ', 'generate.time'
+       write(ionum,*)
+    end if
+    if (do_debug) then
+       u_dbg = io_unit()
+       open(u_dbg, file='generate.debug', status='replace', action='write')
+    end if
+  
+    ! get interaction range and max. number of atoms within range
+    call stp_get_range(inp%nTypes, stp, r_min, r_max)
+    nnb_max = lcl_nmax_nbdist(r_min, r_max)
+    allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nblist(nnb_max),nbtype(nnb_max))
+  
+    ! initialize workspace for structural fingerprint basis:
+    call stp_init(inp%nTypes, stp, nnb_max)
+    if (inp%do_timing) call tng_timing('Structural fingerprint basis initialized.')
+  
+    ! allocate workspace for basis function evaluation:
+    allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
+    sfval(:) = 0.0d0
+    sfderiv_i(:,:) = 0.0d0
+    sfderiv_j(:,:,:) = 0.0d0
+  
+    call aeio_header('Generation of training set started')
+    write(ionum,*)
+  
+    write(ionum,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
+    write(*,'(1x,"types                 : ")', advance='no')
+    do itype = 1, inp%nTypes
+       if (mod(itype,7) == 0) write(*,'(29x)')
+       write(*,'(A5,1x)', advance='no') inp%typeName(itype)
+    end do
+    write(ionum,*)
+    write(ionum,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
+    write(ionum,*)
+  
+    !-------------- write basis function settings to stdout -------------!
+  
+    call aeio_header("Structural fingerprint basis set-up")
+    write(ionum,*)
+  
+    do itype1 = 1, inp%nTypes
+       !call stp_print_info(stp(itype1))
+    end do
+  
+    !----------- write training set header to the output file -----------!
+  
+    ts = new_TrnSet(inp%nTypes, inp%typeName, inp%atomicEnergy, &
+                    inp%nStrucs, trim(inp%outFileName))
+
+    outfilename_ascii = trim(inp%outFileName)//'.ascii'                    
+  
+    if (inp%do_timing) call tng_timing('Training set file started.')
+  
+    !--------------- write pytorch force training header ----------------!
+    
+    if (inp%pyo_forces) then
+      u_pyo = io_unit()
+      call pyo_write_init(u_pyo, trim(inp%outFileName)//".forces")
+      call pyo_write_header_info(u_pyo, inp%nStrucs)
+      call pyo_select_force_structures(inp%nStrucs, inp%pyo_forces_percent, struc_write_force)
+      max_nnb_trainset = 0
+    endif
+  
+    !------------------ iterate over coordinates files ------------------!
+  
+    call aeio_header("Adding structures to the training set")
+    write(ionum,*)
+  
+    u_in = io_unit()
+    open(u_in, file=inFile, status='old', action='read')
+    rewind(u_in)
+  
+    iline = 0
+    do
+       ! forward until the FILES keyword:
+       call aeio_readline(u_in, iline, line)
+       read(line,*) keyword
+       if (trim(keyword) == 'FILES') then
+          read(u_in,*)
+          exit
+       end if
+    end do
+  
+    ! header for stdout
+    write(*,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
+         'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
+  
+    nFiles_inv = 1.0d0/dble(inp%nStrucs)
+    structures : do ifile = 1, inp%nStrucs
+  
+       if (inp%do_timing) call tng_timing('Structure: '// io_adjustl(ifile))
+  
+       call aeio_readline(u_in, iline, line)
+       cooFile = trim(line)
+  
+       call geo_init(cooFile, 'xsf')
+       if (inp%do_timing) call tng_timing3(register=R_GEO)
+       if (.not. (hasForces .and. hasEnergy)) then
+          write(0,*) ">>>", hasForces, hasEnergy
+          write(0,*) "Error: incomplete output data in : ", trim(cooFile)
+          call finalize()
+          stop
+       end if
+  
+       if (nTypes > inp%nTypes) then
+          write(ionum,*) 'Skipping ', trim(adjustl(cooFile)), &
+                     ': too many atomic species'
+          call geo_final()
+          cycle structures
+       end if
+  
+       if (abs(cohesiveEnergy) /= 0.0d0) then
+          E_coh = cohesiveEnergy
+       else
+          ! if only the total energy is available, we have to calculate
+          ! the cohesive energy at this point
+          E_coh = totalEnergy
+          do iatom = 1, nAtoms
+             itype1 = atomType(iatom)
+             itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                    inp%nTypes, inp%typeName)
+             E_coh = E_coh - inp%atomicEnergy(itype1)
+          end do
+       end if
+  
+       write(*,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
+            ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
+            trim(adjustl(cooFile))
+  
+       call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
+       if (inp%do_timing) call tng_timing3(register=R_NBL)
+  
+       ! write structure info (atoms, types, energy) to training set file:
+       call ts_write_structure_info(ts, cooFile, nAtoms, nTypes, E_coh)
+       
+       ! write structure info (atoms, types) to pytorch forces file:
+       if (inp%pyo_forces) then
+         pyo_forces_struc = struc_write_force(ifile)
+         call pyo_write_structure_info(u_pyo, cooFile, nAtoms, nTypes, pyo_forces_struc)
+       end if
+  
+       atoms : do iatom = 1, nAtoms
+  
+          ! determine the training atom type of atom `iatom' in global
+          ! index terms
+          itype1 = atomType(iatom)
+          itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                 inp%nTypes, inp%typeName)
+  
+          ! assert that atom type is included in the set-ups:
+          if (itype1 == 0) then
+             write(0,*) "Error: not a valid structure    : ", trim(cooFile)
+             write(0,*) "       Additional species found."
+             call finalize()
+             stop
+          end if
+  
+          ! write atom info (species, forces) to training set file:
+          call ts_write_atom_info(ts, itype1, cooCart(iatom), forCart(iatom))
+  
+          ! get all atoms within cut-off:
+          nnb = nnb_max
+          call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nblist=nblist, nbtype=nbtype)
+  
+          if (inp%do_timing) call tng_timing3(register=R_NBL)
+          !write(*,'(1x,I6,2x,A2,2x,I6)') &
+          !     iatom, trim(atomTypeName(atomType(iatom))), nnb
+  
+          ! convert atom types to global index:
+          do i = 1, nnb
+             nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
+                                      inp%nTypes, inp%typeName)
+             if (nbtype(i) == 0) then
+                write(0,*) "Error: atom type not found in setup."
+                call finalize()
+                stop
+             end if
+          end do
+  
+          ! evaluate the structural fingerprint basis function set-up:
+          call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
+                        stp(itype1), sfval=sfval, sfderiv_i=sfderiv_i, &
+                        sfderiv_j=sfderiv_j)
+  
+          if (do_debug) then
+             do idbg = 1, stp(itype1)%nsf
+                write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
+             end do
+             write(u_dbg,*)
+          end if
+  
+          if (inp%do_timing) call tng_timing3(register=R_SF)
+  
+          ! write basis function values and derivatives
+          ! to the training set file:
+          call ts_write_sf_info(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf))
+  
+          ! write basis function derivatives and neighbor list to pytorch output
+          if (inp%pyo_forces .and. pyo_forces_struc==1) then
+            max_nnb_trainset = max(max_nnb_trainset, nnb)
+            call pyo_write_atom_sf_info(u_pyo, itype1, nnb, stp(itype1)%nsf, nblist(:nnb), &
+                                        sfderiv_i(1:3,1:stp(itype1)%nsf), &
+                                        sfderiv_j(1:3,1:stp(itype1)%nsf,1:nnb) )
+          end if
+  
+       end do atoms
+  
+       if (inp%do_timing) then
+          call tng_dump(R_GEO, 'time spent reading geometries (so far)')
+          call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
+          call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
+       end if
+  
+       call lcl_final()
+       call geo_final()
+  
+    end do structures
+    write(ionum,*)
+  
+    if (inp%do_timing) then
+       call tng_timing('Loop over structures done.')
+       call tng_dump(R_GEO, 'total time spent reading geometries')
+       call tng_dump(R_NBL, 'total time spent in the neighbor list')
+       call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
+    end if
+  
+    !--------- save basis function setups with final statistics ---------!
+  
+    call ts_print_info(ts)
+  
+    !----------------------------- finalize -----------------------------!
+  
+    deallocate(nbcoo, nbdist, nblist, nbtype)
+    close(u_in)
+    
+    if (inp%pyo_forces) then
+      call pyo_write_final(u_pyo, max_nnb_trainset)
+    end if
+
+    to_bin = .false.
+    to_ascii = .true.
+    outFileName = inp%outFileName
+
+    call close_TrnSet(ts, stp=stp(1:inp%nTypes))
+    call finalize()
+
+    call trainbin2ascii_subroutine(trim(outFileName), trim(outfilename_ascii),to_bin, to_ascii)
+  
+  
+  
+  contains !=============================================================!
+  
+  
+    subroutine initialize(inFile)
+  
+      implicit none
+  
+      character(len=*), intent(out) :: inFile
+  
+      integer :: nargs
+      logical :: fexists
+  
+      call aeio_header("generate.x - training set generation", char='=')
+      write(ionum,*)
+  
+      call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+  
+      nargs = command_argument_count()
+      if (nargs < 1) then
+         write(0,*) "Error: No input file provided."
+         call print_usage()
+         call finalize()
+         stop
+      end if
+  
+      call get_command_argument(1, value=inFile)
+      inquire(file=trim(inFile), exist=fexists)
+      if (.not. fexists) then
+         write(0,*) "Error: File not found: ", trim(inFile)
+         call print_usage()
+         call finalize()
+         stop
+      end if
+  
+    end subroutine initialize
+  
+    !--------------------------------------------------------------------!
+  
+    subroutine finalize()
+  
+      implicit none
+  
+      integer :: itype
+  
+      if (allocated(sfval)) then
+         deallocate(sfval, sfderiv_i, sfderiv_j)
+      end if
+  
+      if (allocated(stp)) then
+         call stp_final(inp%nTypes, stp)
+         do itype = 1, inp%nTypes
+            call del_Setup(stp(itype))
+         end do
+         deallocate(stp, inp%typeName, inp%atomicEnergy)
+      end if
+  
+      if (ts%init) call close_TrnSet(ts)
+  
+      if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
+  
+      if (inp%do_timing) call tng_final()
+      if (do_debug)  close(u_dbg)
+  
+      call aeio_header(aeio_timestamp(), char=' ')
+      call aeio_header("Training set generation done.", char='=')
+  
+    end subroutine finalize
+  
+    !--------------------------------------------------------------------!
+  
+    subroutine print_usage()
+  
+      implicit none
+  
+      write(ionum,*)
+      write(ionum,*) "generate.x -- Generate training sets for use with `train.x'"
+      write(*,'(1x,70("-"))')
+      write(ionum,*) 'Usage: generate.x <input-file>'
+      write(ionum,*)
+      write(ionum,*) 'See the documentation or the source code for a description of the '
+      write(ionum,*) 'input file format.'
+      write(ionum,*)
+  
+    end subroutine print_usage
+  
+    !--------------------------------------------------------------------!
+  
+    subroutine load_symmfunc_setups(inp, stp)
+  
+      implicit none
+  
+      type(InputData),           intent(in)  :: inp
+      type(Setup), dimension(:), intent(out) :: stp
+  
+      integer :: i
+  
+      do i = 1, inp%nTypes
+         stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
+         if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
+            write(0,*) "Error: Inconsistent atom type in setup:"
+            write(0,*) "       type expected : ", trim(inp%typeName(i))
+            write(0,*) "       type found    : ", trim(stp(i)%atomtype)
+            call finalize()
+            stop
+         end if
+      end do
+  
+    end subroutine load_symmfunc_setups
+  
+   end subroutine generate_subroutine
+
+
+
+ 
+end module
\ No newline at end of file
diff -Naru src/sub_generate_MPI.f90 src_modified/sub_generate_MPI.f90
--- src/sub_generate_MPI.f90	1970-01-01 09:00:00
+++ src_modified/sub_generate_MPI.f90	2024-09-06 10:37:30
@@ -0,0 +1,723 @@
+module aenet_generate_MPI 
+   use aenet_trainbin2ascii,only:trainbin2ascii_subroutine
+implicit none
+contains 
+
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2019 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!+ ---------------------------------------------------------------------
+!+ If you make use of AENET for your publication, please cite:
+!+ [1] N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.
+!+ [2] J. Behler and M. Parrinello, Phys. Rev. Lett. 98 (2007) 146401.
+!+
+!+ If you used the Chebyshev descriptor, please cite:
+!+ [3] N. Artrith, A. Urban, and G. Ceder, PRB 96 (2017) 014112.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+subroutine generate_subroutine_MPI(inFile,ionum)
+
+    use aeio,     only: aeio_readline,        &
+                        aeio_header,          &
+                        aeio_timestamp,       &
+                        aeio_print_copyright, &
+                        PATHLEN, LINELEN
+  
+    use geometry, only: geo_init,          &
+                        geo_final,         &
+                        geo_itype_of_name, &
+                        geo_type_conv,     &
+                        pbc,               &
+                        latticeVec,        &
+                        nAtoms,            &
+                        nTypes,            &
+                        atomType,          &
+                        atomTypeName,      &
+                        cooLatt,           &
+                        cooCart,           &
+                        forCart,           &
+                        hasEnergy,         &
+                        hasForces,         &
+                        cohesiveEnergy,    &
+                        totalEnergy
+  
+    use input,    only: InputData,         &
+                        read_InpGenerate,  &
+                        del_InputData
+  
+    use io,       only: io_adjustl,        &
+                        io_center,         &
+                        io_lower,          &
+                        io_readnext,       &
+                        io_unit
+  
+    use lclist,   only: lcl_init,          &
+                        lcl_final,         &
+                        lcl_print_info,    &
+                        lcl_nmax_nbdist,   &
+                        lcl_nbdist_cart
+  
+    use sfsetup,  only: Setup,                 &
+                        read_Setup_parameters, &
+                        save_Setup,            &
+                        del_Setup,             &
+                        stp_init,              &
+                        stp_final,             &
+                        stp_get_range,         &
+                        stp_print_info,        &
+                        stp_eval,              &
+                        nsf_max
+  
+    use timing,   only: tng_init,          &
+                        tng_final,         &
+                        tng_timing,        &
+                        tng_timing2,       &
+                        tng_timing3,       &
+                        tng_dump
+  
+    use trainset, only: TrnSet,                 &
+                        new_TrnSet,             &
+                        close_TrnSet,           &
+                        ts_print_info,          &
+                        ts_write_header,        &
+                        ts_write_sf_info,       &
+                        ts_write_atom_info,     &
+                        ts_write_structure_info
+  
+    use pytorchoutput, only: pyo_write_init,               &
+                             pyo_write_final,              &
+                             pyo_write_header_info,        &
+                             pyo_write_structure_info,     &
+                             pyo_write_atom_sf_info,       &
+                             pyo_select_force_structures!, &
+   use pytorchoutput_MPI, only: pyo_write_structure_info_MPI,     &
+                             pyo_write_atom_sf_info_MPI,&
+                             pyo_loadandwrite
+
+    use trainset_MPI, only: new_TrnSet_MPI,             &
+                             close_TrnSet_MPI,           &
+                             ts_write_header_MPI,        &
+                             ts_write_sf_info_MPI,       &
+                             ts_write_atom_info_MPI,     &
+                             ts_write_structure_info_MPI,&
+                             ts_parallel_footer_MPI,&
+                             ts_loadandwrite_structure_info_MPI
+
+    use parallel,    only: pp_init,                &
+                         pp_final,               &
+                         pp_bcast,               &
+                         pp_barrier,             &
+                         ppMaster,               &
+                         ppRank,                 &
+                         ppSize,                 &
+                         pp_bcast_InputData,     &
+                         pp_bcast_Setup                             
+  
+    implicit none
+  
+    !--------------------------------------------------------------------!
+    ! stp(i)         structural fingerprint basis setup for atom type i  !
+    ! r_min, r_max   lower and upper bound for atomic interactions       !
+    ! ts             training set reference                              !
+    !                                                                    !
+    ! nnb_max, nnb   max. and actual number of neighboring atoms         !
+    ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
+    !                neighboring atom                                    !
+    ! nbdist(i)      distance of the i-th neighbor                       !
+    !                                                                    !
+    ! sfval(i)         value of the i-th basis function                  !
+    ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
+    !                  with respect to the central atom                  !
+    !                  sfderiv_i(3,nsf_max)                              !
+    ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
+    !                  with respect to the coordinates of atom k         !
+    !                  sfderiv_j(3,nsf_max,nnb_max)                      !
+    !                                                                    !
+    ! E_coh          cohesive energy                                     !
+    ! nFiles_inv     = 1/inp%nStrucs                                     !
+    !                                                                    !
+    ! inFile         name of the input file for the generate.x program   !
+    ! cooFile        name of the currently active structure file         !
+    ! keyword        the last keyword read from the input file           !
+    !                                                                    !
+    ! do_debug       if .true., additional files containing debugging    !
+    !                info will be created                                !
+    !                                                                    !
+    ! u_*            file units                                          !
+    !--------------------------------------------------------------------!
+  
+    type(InputData)                                :: inp
+  
+    type(Setup),       dimension(:),   allocatable :: stp
+    double precision                               :: r_min, r_max
+    type(TrnSet)                                   :: ts
+  
+    integer                                        :: nnb_max, nnb
+    double precision,  dimension(:,:), allocatable :: nbcoo
+    double precision,  dimension(:),   allocatable :: nbdist
+    integer,  dimension(:),   allocatable :: nblist
+    integer,           dimension(:),   allocatable :: nbtype
+  
+    double precision, dimension(:),     allocatable :: sfval
+    double precision, dimension(:,:),   allocatable :: sfderiv_i
+    double precision, dimension(:,:,:), allocatable :: sfderiv_j
+  
+    double precision                               :: E_coh
+    integer                                        :: ifile
+    double precision                               :: nFiles_inv
+
+    character(len=*),intent(in)                    :: inFile
+    integer,intent(in)                             :: ionum
+  
+    !character(len=PATHLEN)                         :: inFile
+    character(len=PATHLEN)                         :: cooFile
+    character(len=LINELEN)                         :: keyword
+  
+    integer                                        :: itype1
+    integer                                        :: itype, iatom
+  
+    integer                                        :: iline
+    character(len=1024)                            :: line
+  
+    integer                                        :: u_in, u_tng
+    logical                                        :: do_debug = .false.
+    integer                                        :: u_dbg, idbg
+  
+    integer                                        :: u_pyo, max_nnb_trainset, pyo_forces_struc
+    integer, allocatable                           :: struc_write_force(:)
+  
+  
+    integer :: i, j, l
+    logical :: lexist
+    ! timing registers
+    integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
+
+    character(len=1024)::outfilename_ascii
+    character(len=1024)::outFileName
+    logical ::to_bin,to_ascii
+
+    logical :: stopnow
+    character(len=262144)                           :: longline
+  
+    integer rename, status
+    integer::N_do_forces
+  
+  !-------------------------- initialization --------------------------!
+
+    if (ppMaster) then
+      call system( 'rm -f ts.* 2> /dev/null' )
+    end if
+ 
+    call initialize_MPI()
+  
+    if (ppMaster) inp = read_InpGenerate(inFile)
+    call pp_bcast_InputData(inp)
+
+    allocate(stp(inp%nTypes))
+    call load_symmfunc_setups_MPI(inp, stp)
+  
+    ! call parse_input(inFile)
+  
+    if (inp%do_timing .and. ppMaster) then
+       u_tng = io_unit()
+       call tng_init(unit=u_tng, file='generate.time', registers=3)
+       write(ionum,*) 'Timing info will be written to: ', 'generate.time'
+       write(ionum,*)
+    end if
+    if (do_debug .and. ppMaster) then
+       u_dbg = io_unit()
+       open(u_dbg, file='generate.debug', status='replace', action='write')
+    end if
+  
+    ! get interaction range and max. number of atoms within range
+    call stp_get_range(inp%nTypes, stp, r_min, r_max)
+    nnb_max = lcl_nmax_nbdist(r_min, r_max)
+    allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nblist(nnb_max),nbtype(nnb_max))
+  
+    ! initialize workspace for structural fingerprint basis:
+    call stp_init(inp%nTypes, stp, nnb_max)
+    if (inp%do_timing) call tng_timing('Structural fingerprint basis initialized.')
+  
+    ! allocate workspace for basis function evaluation:
+    allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
+    sfval(:) = 0.0d0
+    sfderiv_i(:,:) = 0.0d0
+    sfderiv_j(:,:,:) = 0.0d0
+
+    if (ppMaster) then
+      call aeio_header('Generation of training set started')
+      write(ionum,*)
+   
+      write(ionum,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
+      write(*,'(1x,"types                 : ")', advance='no')
+      do itype = 1, inp%nTypes
+         if (mod(itype,7) == 0) write(*,'(29x)')
+         write(*,'(A5,1x)', advance='no') inp%typeName(itype)
+      end do
+      write(ionum,*)
+      write(ionum,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
+      write(ionum,*)
+    end if
+  
+    !-------------- write basis function settings to stdout -------------!
+    if (ppMaster) then
+      call aeio_header("Structural fingerprint basis set-up")
+      write(ionum,*)
+  
+      do itype1 = 1, inp%nTypes
+       call stp_print_info(stp(itype1))
+      end do
+   end if
+  
+    !----------- write training set header to the output file -----------!
+  
+    ts = new_TrnSet_MPI(inp%nTypes, inp%typeName, inp%atomicEnergy, &
+                    inp%nStrucs, trim(inp%outFileName))
+
+    outfilename_ascii = trim(inp%outFileName)//'.ascii'                    
+  
+    if (inp%do_timing .and. ppMaster) call tng_timing('Training set file started.')
+  
+    !--------------- write pytorch force training header ----------------!
+
+    call pp_barrier()
+
+    if (inp%pyo_forces) then
+      u_pyo = io_unit()
+      if (ppMaster) then
+         !call pyo_write_init(u_pyo, trim(inp%outFileName)//".forces.tmp")
+         call pyo_write_init(u_pyo, "ts.forces.tmp")
+         call pyo_write_header_info(u_pyo, inp%nStrucs)
+         call pyo_select_force_structures(inp%nStrucs, inp%pyo_forces_percent, struc_write_force)
+         N_do_forces = ubound(struc_write_force,1)
+      end if
+      call pp_bcast(N_do_forces)
+      if (ppMaster) then
+      else
+         allocate(struc_write_force(N_do_forces))
+      end if
+      do i=1,N_do_forces
+         call pp_bcast(struc_write_force(i))
+      end do
+      max_nnb_trainset = 0
+    endif
+  
+    !------------------ iterate over coordinates files ------------------!
+  
+    if (ppMaster) then
+      call aeio_header("Adding structures to the training set")
+      write(ionum,*)
+    end if
+  
+    u_in = io_unit()
+    open(u_in, file=inFile, status='old', action='read')
+    rewind(u_in)
+  
+    iline = 0
+    do
+       ! forward until the FILES keyword:
+       call aeio_readline(u_in, iline, line)
+       read(line,*) keyword
+       if (trim(keyword) == 'FILES') then
+          read(u_in,*)
+          exit
+       end if
+    end do
+  
+    if (ppMaster) then
+    ! header for stdout
+      write(*,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
+            'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
+   
+    end if
+
+    stopnow = .false.
+
+    call pp_barrier()
+
+
+
+    nFiles_inv = 1.0d0/dble(inp%nStrucs)
+    structures : do ifile = 1, inp%nStrucs
+  
+       if (inp%do_timing .and. ppMaster) call tng_timing('Structure: '// io_adjustl(ifile))
+  
+       call aeio_readline(u_in, iline, line)
+       cooFile = trim(line)
+
+       if ( mod(ifile-1,ppSize) .ne. ppRank ) cycle
+  
+       call geo_init(cooFile, 'xsf')
+       if (inp%do_timing) call tng_timing3(register=R_GEO)
+       if (.not. (hasForces .and. hasEnergy)) then
+          write(0,*) ">>>", hasForces, hasEnergy
+          write(0,*) "Error: incomplete output data in : ", trim(cooFile)
+          !call finalize()
+          stop
+       end if
+  
+       if (nTypes > inp%nTypes) then
+          if (ppMaster) then
+            write(ionum,*) 'Skipping ', trim(adjustl(cooFile)), &
+                     ': too many atomic species'
+          end if
+          call geo_final()
+          cycle structures
+       end if
+  
+       if (abs(cohesiveEnergy) /= 0.0d0) then
+          E_coh = cohesiveEnergy
+       else
+          ! if only the total energy is available, we have to calculate
+          ! the cohesive energy at this point
+          E_coh = totalEnergy
+          do iatom = 1, nAtoms
+             itype1 = atomType(iatom)
+             itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                    inp%nTypes, inp%typeName)
+             E_coh = E_coh - inp%atomicEnergy(itype1)
+          end do
+       end if
+  
+       if (ppMaster) then
+         write(*,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
+            ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
+            trim(adjustl(cooFile))
+       end if
+            
+       call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
+       if (inp%do_timing .and. ppMaster) call tng_timing3(register=R_NBL)
+  
+       ! write structure info (atoms, types, energy) to training set file:
+       call ts_write_structure_info_MPI(ts, cooFile, nAtoms, nTypes, E_coh,ifile)
+       
+       ! write structure info (atoms, types) to pytorch forces file:
+       if (inp%pyo_forces ) then
+         pyo_forces_struc = struc_write_force(ifile)
+         call pyo_write_structure_info_MPI(cooFile, nAtoms, nTypes, pyo_forces_struc,ifile)
+       end if
+  
+       atoms : do iatom = 1, nAtoms
+  
+          ! determine the training atom type of atom `iatom' in global
+          ! index terms
+          itype1 = atomType(iatom)
+          itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                 inp%nTypes, inp%typeName)
+  
+          ! assert that atom type is included in the set-ups:
+          if (itype1 == 0) then
+             write(0,*) "Error: not a valid structure    : ", trim(cooFile)
+             write(0,*) "       Additional species found."
+             !call finalize()
+             stop
+          end if
+  
+          ! write atom info (species, forces) to training set file:
+          call ts_write_atom_info_MPI(ts, itype1, cooCart(iatom), forCart(iatom),ifile)
+  
+          ! get all atoms within cut-off:
+          nnb = nnb_max
+          call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nblist=nblist, nbtype=nbtype)
+  
+          if (inp%do_timing .and. ppMaster) call tng_timing3(register=R_NBL)
+          !write(*,'(1x,I6,2x,A2,2x,I6)') &
+          !     iatom, trim(atomTypeName(atomType(iatom))), nnb
+  
+          ! convert atom types to global index:
+          do i = 1, nnb
+             nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
+                                      inp%nTypes, inp%typeName)
+             if (nbtype(i) == 0) then
+                write(0,*) "Error: atom type not found in setup."
+                call finalize_MPI()
+                stop
+             end if
+          end do
+  
+          ! evaluate the structural fingerprint basis function set-up:
+          call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
+                        stp(itype1), sfval=sfval, sfderiv_i=sfderiv_i, &
+                        sfderiv_j=sfderiv_j)
+  
+          if (do_debug .and. ppMaster) then
+             do idbg = 1, stp(itype1)%nsf
+                write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
+             end do
+             write(u_dbg,*)
+          end if
+  
+          if (inp%do_timing) call tng_timing3(register=R_SF)
+  
+          ! write basis function values and derivatives
+          ! to the training set file:
+          call ts_write_sf_info_MPI(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf),ifile)
+  
+          ! write basis function derivatives and neighbor list to pytorch output
+          if (inp%pyo_forces .and. pyo_forces_struc==1) then
+            max_nnb_trainset = max(max_nnb_trainset, nnb)
+            call pyo_write_atom_sf_info_MPI(itype1, nnb, stp(itype1)%nsf, nblist(:nnb), &
+                                        sfderiv_i(1:3,1:stp(itype1)%nsf), &
+                                        sfderiv_j(1:3,1:stp(itype1)%nsf,1:nnb) ,ifile)
+          end if
+  
+       end do atoms
+  
+       if (inp%do_timing) then
+          call tng_dump(R_GEO, 'time spent reading geometries (so far)')
+          call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
+          call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
+       end if
+  
+       call lcl_final()
+       call geo_final()
+  
+    end do structures
+    if (ppMaster) write(ionum,*)
+  
+    if (inp%do_timing) then
+       call tng_timing('Loop over structures done.')
+       call tng_dump(R_GEO, 'total time spent reading geometries')
+       call tng_dump(R_NBL, 'total time spent in the neighbor list')
+       call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
+    end if
+  
+    !--------- save basis function setups with final statistics ---------!
+  
+    if (ppMaster) call ts_print_info(ts)
+  
+    !----------------------------- finalize -----------------------------!
+  
+    deallocate(nbcoo, nbdist, nblist, nbtype)
+    close(u_in)
+    
+    if (inp%pyo_forces .and. ppMaster) then
+      call pyo_write_final(u_pyo, max_nnb_trainset)
+    end if
+
+
+    call pp_barrier()
+
+    if (ppMaster) then
+     do ifile = 1, inp%nStrucs
+        call ts_loadandwrite_structure_info_MPI(ifile)
+     end do
+    end if
+  
+    call ts_parallel_footer_MPI(ts, stp)
+
+    if (inp%pyo_forces .and. ppMaster) then
+      call pyo_loadandwrite("ts.forces.tmp")
+      !call pyo_loadandwrite(trim(inp%outFileName)//".forces.tmp")
+    end if
+
+
+
+    call close_TrnSet_MPI(ts, stp=stp(1:inp%nTypes))
+
+
+    l = 5000
+    call pp_barrier()
+    if (ppMaster) then
+     status = rename( "ts.all",adjustl(trim(inp%outFileName))) !rename the file
+        do ifile = 1, inp%nStrucs
+           open(10001, file='ts.'//io_adjustl(ifile))
+           close(10001, status="delete")
+        end do
+    end if
+
+    if (inp%pyo_forces .and. ppMaster) then
+      status = rename( "pyo.all",trim(inp%outFileName)//".forces") !rename the file
+      do ifile = 1, inp%nStrucs
+         open(10001, file='ts.force.'//io_adjustl(ifile))
+         close(10001, status="delete")
+      end do
+    end if
+  
+    call pp_barrier()
+    call finalize_MPI()
+
+
+    to_bin = .false.
+    to_ascii = .true.
+    outFileName = inp%outFileName
+    call trainbin2ascii_subroutine(trim(outFileName), trim(outfilename_ascii),to_bin, to_ascii)
+  
+
+    return
+
+    call finalize()
+
+
+  
+  contains !=============================================================!
+  
+  
+  subroutine initialize_MPI()
+
+    implicit none
+
+!    character(len=*), intent(out) :: inFile
+
+    integer :: nargs
+    logical :: fexists
+    logical :: stopnow
+
+    call pp_init()
+
+!    stopnow = .false.
+
+    if (ppMaster) then
+
+       call aeio_header("generate.x - training set generation", char='=')
+       write(ionum,*)
+
+       call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+
+!       nargs = command_argument_count()
+!       if (nargs < 1) then
+!          write(0,*) "Error: No input file provided."
+!          call print_usage()
+!          stopnow = .true.
+!       end if
+
+!       call get_command_argument(1, value=inFile)
+!       inquire(file=trim(inFile), exist=fexists)
+!       if (.not. fexists) then
+!          write(0,*) "Error: File not found: ", trim(inFile)
+!          stopnow = .true.
+!       end if
+
+   end if
+!   stopnow = .true.
+
+!    call pp_bcast(stopnow)
+!    if (stopnow) then
+!       call finalize_MPI()
+!       stop
+!    end if
+
+   ! call pp_bcast(inFile)
+
+  end subroutine initialize_MPI
+
+    !--------------------------------------------------------------------!
+  
+  subroutine finalize_MPI()
+
+    implicit none
+
+    integer :: itype
+
+    if (allocated(sfval)) then
+       deallocate(sfval, sfderiv_i, sfderiv_j)
+    end if
+
+    if (allocated(stp)) then
+       call stp_final(inp%nTypes, stp)
+       do itype = 1, inp%nTypes
+          call del_Setup(stp(itype))
+       end do
+       deallocate(stp, inp%typeName, inp%atomicEnergy)
+    end if
+
+    if (ts%init) call close_TrnSet_MPI(ts)
+
+    if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
+
+    if (inp%do_timing .and. ppMaster ) call tng_final()
+    if (do_debug .and. ppMaster )  close(u_dbg)
+
+    if (ppMaster) then
+       call aeio_header(aeio_timestamp(), char=' ')
+       call aeio_header("Training set generation done.", char='=')
+    end if
+
+    call pp_final()
+
+  end subroutine finalize_MPI
+
+  
+    !--------------------------------------------------------------------!
+  
+    subroutine print_usage()
+  
+      implicit none
+  
+      write(ionum,*)
+      write(ionum,*) "generate.x -- Generate training sets for use with `train.x'"
+      write(*,'(1x,70("-"))')
+      write(ionum,*) 'Usage: generate.x <input-file>'
+      write(ionum,*)
+      write(ionum,*) 'See the documentation or the source code for a description of the '
+      write(ionum,*) 'input file format.'
+      write(ionum,*)
+  
+    end subroutine print_usage
+  
+    !--------------------------------------------------------------------!
+  
+  subroutine load_symmfunc_setups_MPI(inp, stp)
+
+    implicit none
+
+    type(InputData),           intent(in)  :: inp
+    type(Setup), dimension(:), intent(out) :: stp
+    logical :: stopnow
+    integer :: i
+
+    stopnow = .false.
+    
+   
+    if(ppMaster) then 
+      do i = 1, inp%nTypes
+         stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
+         if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
+            write(0,*) "Error: Inconsistent atom type in setup:"
+            write(0,*) "       type expected : ", trim(inp%typeName(i))
+            write(0,*) "       type found    : ", trim(stp(i)%atomtype)
+            stopnow = .true.
+         end if
+      end do
+   end if
+
+   call pp_barrier()
+   
+
+   do i = 1, inp%nTypes
+      call pp_bcast_Setup(stp(i))
+   end do
+
+   
+   call pp_barrier()
+
+
+
+    call pp_bcast(stopnow)
+    if (stopnow) then
+       call finalize_MPI()
+       stop
+    end if
+
+  end subroutine load_symmfunc_setups_MPI
+
+ end subroutine generate_subroutine_MPI
+
+
+
+ 
+end module
\ No newline at end of file
diff -Naru src/sub_nnASCII2bin.f90 src_modified/sub_nnASCII2bin.f90
--- src/sub_nnASCII2bin.f90	1970-01-01 09:00:00
+++ src_modified/sub_nnASCII2bin.f90	2024-09-06 10:37:30
@@ -0,0 +1,383 @@
+module aenet_nnASCII2bin
+   implicit none
+   contains 
+
+subroutine nnASCII2bin_subroutine(infile, outfile, to_bin, to_ascii)
+
+    implicit none
+    
+    character(len=*),intent(in) :: infile, outfile
+    logical,intent(in)             :: to_bin, to_ascii
+    
+    
+    
+    !call initialize(infile, outfile, to_bin, to_ascii)
+    
+    if (to_ascii .and. .not. to_bin) then
+        call bin2ascii(infile, outfile)
+    else if (to_bin .and. .not. to_ascii) then
+        call ascii2bin(infile, outfile)
+    endif
+    
+    
+    contains
+    
+    subroutine initialize(infile, outfile, to_bin, to_ascii)
+    
+        implicit none
+    
+        character(len=*), intent(out) :: infile, outfile
+        integer :: iarg, nargs
+        character(len=100) :: arg
+        logical, intent(out) :: to_bin, to_ascii
+    
+        nargs = command_argument_count()
+        if (nargs < 1) then
+           write(0,*) "Error: No input file provided."
+           call finalize()
+           stop
+        end if
+    
+        infile = ' '
+        outfile = ' '
+    
+        to_bin = .true.
+        to_ascii = .false.
+        
+        iarg = 1
+        do while(iarg <= nargs)
+           call get_command_argument(iarg, value=arg)
+           select case(trim(arg))
+           case('--to-binary')
+              to_bin = .true.
+              to_ascii = .false.
+           case('--to-ascii')
+              to_ascii = .true.
+              to_bin = .false.
+           case default
+              if (len_trim(infile) == 0) then
+                 infile = trim(arg)
+              else if (len_trim(outfile) == 0) then
+                 outfile = trim(arg)
+              else
+                 write(0,*) 'Error: Unknown argument: ', trim(arg)
+                 call finalize()
+                 stop
+              end if
+           end select
+           iarg = iarg + 1
+        end do
+    
+        if ((len(infile) == 0) .or. (len(outfile) == 0))then
+           write(0,*) 'Error: No input file specified.'
+           call finalize()
+           stop
+        end if
+    
+    end subroutine initialize
+    
+      !--------------------------------------------------------------------!
+    
+    subroutine finalize()
+    
+        implicit none
+    
+    end subroutine finalize
+    
+      !--------------------------------------------------------------------!
+    
+    subroutine ascii2bin(infile, outfile)
+        implicit none
+    
+        character(len=*), intent(in)  :: infile, outfile
+    
+        integer              :: nlayers, nnodesmax, Wsize, nvalues
+        integer, allocatable :: nnodes(:), fun(:), iw(:), iv(:)
+        real*8, allocatable  :: W(:)
+    
+        character(len=1024)           :: description
+        character(len=100)            :: sftype
+        character(len=2)              :: atomtype
+        character(len=2), allocatable :: envtypes(:)
+        real*8                        :: rc_min, rc_max
+        integer                       :: nsf, nsfparam, neval, nenv
+        integer, allocatable          :: sf(:), sfenv(:,:)
+        real*8, allocatable           :: sfparam(:,:), sfval_min(:), sfval_max(:), sfval_avg(:), sfval_cov(:)
+    
+        character(len=1024)           :: file
+        logical                       :: normalized
+        real*8                        :: scale, shift, E_min, E_max, E_avg
+        integer                       :: ntypes, natomtot, nstrucs
+        character(len=2), allocatable :: type_names(:)
+        real*8, allocatable           :: E_atom(:)
+    
+    
+        open(unit = 1, action = "read", status = "old", file = infile)
+        open(unit = 2, action = "write", status = "replace", file = outfile, form = "unformatted")
+    
+    
+        ! Network information
+        read(1,*) nlayers
+        read(1,*) nnodesmax
+        read(1,*) Wsize
+        read(1,*) nvalues
+    
+        allocate(nnodes(nlayers), fun(nlayers-1), iw(nlayers), iv(nlayers), W(Wsize))
+    
+        read(1,*) nnodes(:)
+        read(1,*) fun(:)
+        read(1,*) iw(:)
+        read(1,*) iv(:)
+        read(1,*) W(:)
+    
+    
+        write(2) nlayers
+        write(2) nnodesmax
+        write(2) Wsize
+        write(2) nvalues
+        write(2) nnodes(:)
+        write(2) fun(:)
+        write(2) iw(:)
+        write(2) iv(:)
+        write(2) W(:)
+    
+    
+        deallocate(nnodes, fun, iw, iv, W)
+    
+    
+    
+        ! Structural Fingerprint setup information
+        read(1,*) description
+        read(1,*) atomtype
+        read(1,*) nenv
+    
+        allocate(envtypes(nenv))
+    
+        read(1,*) envtypes(:)
+        read(1,*) rc_min
+        read(1,*) rc_max
+        read(1,*) sftype
+        read(1,*) nsf
+        read(1,*) nsfparam
+    
+        allocate(sf(nsf), sfparam(nsfparam,nsf), sfenv(2,nsf), sfval_min(nsf), &
+                 sfval_max(nsf), sfval_avg(nsf), sfval_cov(nsf))
+    
+        read(1,*) sf(:)
+        read(1,*) sfparam(:,:)
+        read(1,*) sfenv(:,:)
+        read(1,*) neval
+        read(1,*) sfval_min
+        read(1,*) sfval_max
+        read(1,*) sfval_avg
+        read(1,*) sfval_cov
+    
+        !print*, sfparam(:,1)
+    
+    
+        write(2) description
+        write(2) atomtype
+        write(2) nenv
+        write(2) envtypes(:)
+        write(2) rc_min
+        write(2) rc_max
+        write(2) sftype
+        write(2) nsf
+        write(2) nsfparam
+        write(2) sf(:)
+        write(2) sfparam(:,:)
+        write(2) sfenv(:,:)
+        write(2) neval
+        write(2) sfval_min
+        write(2) sfval_max
+        write(2) sfval_avg
+        write(2) sfval_cov
+    
+        deallocate(sf, sfparam, sfenv, sfval_min, sfval_max, sfval_avg, sfval_cov)
+    
+    
+    
+        ! Trainset information
+        read(1,*) file
+        read(1,*) normalized
+        read(1,*) scale
+        read(1,*) shift
+        read(1,*) ntypes
+    
+        allocate(type_names(ntypes), E_atom(ntypes))
+    
+        read(1,*) type_names(:)
+        read(1,*) E_atom(:)
+        read(1,*) natomtot
+        read(1,*) nstrucs
+        read(1,*) E_min, E_max, E_avg
+    
+    
+        write(2) file
+        write(2) normalized
+        write(2) scale
+        write(2) shift
+        write(2) ntypes
+        write(2) type_names(:)
+        write(2) E_atom(:)
+        write(2) natomtot
+        write(2) nstrucs
+        write(2) E_min, E_max, E_avg
+    
+        deallocate(type_names, E_atom)
+    
+    
+        close(unit = 1)
+        close(unit = 2)
+    
+    end subroutine ascii2bin
+    
+      !--------------------------------------------------------------------!
+    
+    subroutine bin2ascii(infile, outfile)
+        implicit none
+    
+        character(len=*), intent(in)  :: infile, outfile
+    
+        integer              :: nlayers, nnodesmax, Wsize, nvalues
+        integer, allocatable :: nnodes(:), fun(:), iw(:), iv(:)
+        real*8, allocatable  :: W(:)
+    
+        character(len=1024)           :: description
+        character(len=100)            :: sftype
+        character(len=2)              :: atomtype
+        character(len=2), allocatable :: envtypes(:)
+        real*8                        :: rc_min, rc_max
+        integer                       :: nsf, nsfparam, neval, nenv
+        integer, allocatable          :: sf(:), sfenv(:,:)
+        real*8, allocatable           :: sfparam(:,:), sfval_min(:), sfval_max(:), sfval_avg(:), sfval_cov(:)
+    
+        character(len=1024)           :: file
+        logical                       :: normalized
+        real*8                        :: scale, shift, E_min, E_max, E_avg
+        integer                       :: ntypes, natomtot, nstrucs
+        character(len=2), allocatable :: type_names(:)
+        real*8, allocatable           :: E_atom(:)
+    
+    
+        open(unit = 1, action = "read", status = "old", file = infile, form = "unformatted")
+        open(unit = 2, action = "write", status = "replace", file = outfile)
+    
+    
+        ! Network information
+        read(1) nlayers
+        read(1) nnodesmax
+        read(1) Wsize
+        read(1) nvalues
+    
+        allocate(nnodes(nlayers), fun(nlayers-1), iw(nlayers), iv(nlayers), W(Wsize))
+    
+        read(1) nnodes(:)
+        read(1) fun(:)
+        read(1) iw(:)
+        read(1) iv(:)
+        read(1) W(:)
+    
+    
+        write(2,*) nlayers
+        write(2,*) nnodesmax
+        write(2,*) Wsize
+        write(2,*) nvalues
+        write(2,*) nnodes(:)
+        write(2,*) fun(:)
+        write(2,*) iw(:)
+        write(2,*) iv(:)
+        write(2,*) W(:)
+    
+        deallocate(nnodes, fun, iw, iv, W)
+    
+    
+    
+        ! Structural Fingerprint setup information
+        read(1) description
+        read(1) atomtype
+        read(1) nenv
+    
+        allocate(envtypes(nenv))
+    
+        read(1) envtypes(:)
+        read(1) rc_min
+        read(1) rc_max
+        read(1) sftype
+        read(1) nsf
+        read(1) nsfparam
+    
+        allocate(sf(nsf), sfparam(nsfparam,nsf), sfenv(2,nsf), sfval_min(nsf), &
+                 sfval_max(nsf), sfval_avg(nsf), sfval_cov(nsf))
+    
+        read(1) sf(:)
+        read(1) sfparam(:,:)
+        read(1) sfenv(:,:)
+        read(1) neval
+        read(1) sfval_min
+        read(1) sfval_max
+        read(1) sfval_avg
+        read(1) sfval_cov
+    
+    
+    
+        write(2,*) description
+        write(2,*) atomtype
+        write(2,*) nenv
+        write(2,"(a)") envtypes(:)
+        write(2,*) rc_min
+        write(2,*) rc_max
+        write(2,*) sftype
+        write(2,*) nsf
+        write(2,*) nsfparam
+        write(2,*) sf(:)
+        write(2,*) sfparam(:,:)
+        write(2,*) sfenv(:,:)
+        write(2,*) neval
+        write(2,*) sfval_min
+        write(2,*) sfval_max
+        write(2,*) sfval_avg
+        write(2,*) sfval_cov
+    
+        deallocate(sf, sfparam, sfenv, sfval_min, sfval_max, sfval_avg, sfval_cov)
+    
+    
+    
+        ! Trainset information
+        read(1) file
+        read(1) normalized
+        read(1) scale
+        read(1) shift
+        read(1) ntypes
+    
+        allocate(type_names(ntypes), E_atom(ntypes))
+    
+        read(1) type_names(:)
+        read(1) E_atom(:)
+        read(1) natomtot
+        read(1) nstrucs
+        read(1) E_min, E_max, E_avg
+    
+    
+        write(2,*) file
+        write(2,*) normalized
+        write(2,*) scale
+        write(2,*) shift
+        write(2,*) ntypes
+        write(2,*) type_names(:)
+        write(2,*) E_atom(:)
+        write(2,*) natomtot
+        write(2,*) nstrucs
+        write(2,*) E_min, E_max, E_avg
+    
+        deallocate(type_names, E_atom)
+    
+    
+        close(unit = 1)
+        close(unit = 2)
+    
+    end subroutine bin2ascii
+    
+   end subroutine nnASCII2bin_subroutine
+
+end module aenet_nnASCII2bin
\ No newline at end of file
diff -Naru src/sub_trainbin2ASCII.f90 src_modified/sub_trainbin2ASCII.f90
--- src/sub_trainbin2ASCII.f90	1970-01-01 09:00:00
+++ src_modified/sub_trainbin2ASCII.f90	2024-09-06 10:37:30
@@ -0,0 +1,492 @@
+module aenet_trainbin2ascii
+    implicit none
+    contains 
+
+subroutine trainbin2ascii_subroutine(infile, outfile,to_bin, to_ascii)
+
+implicit none
+
+character(len=*),intent(in)    :: infile, outfile
+logical,intent(in)                :: to_bin, to_ascii
+
+!integer,intent(in)                             :: ionum
+
+!call initialize(infile, outfile, to_bin, to_ascii)
+
+if (to_ascii .and. .not. to_bin) then
+    call bin2ascii(infile, outfile)
+else if (to_bin .and. .not. to_ascii) then
+    call ascii2bin(infile, outfile)
+endif
+
+
+contains
+
+subroutine initialize(infile, outfile, to_bin, to_ascii)
+
+    implicit none
+
+    character(len=*), intent(out) :: infile, outfile
+    integer :: iarg, nargs
+    character(len=100) :: arg
+    logical, intent(out) :: to_bin, to_ascii
+
+    nargs = command_argument_count()
+    if (nargs < 1) then
+       write(0,*) "Error: No input file provided."
+       call finalize()
+       stop
+    end if
+
+    infile = ' '
+    outfile = ' '
+
+    to_bin = .false.
+    to_ascii = .true.
+    
+    iarg = 1
+    do while(iarg <= nargs)
+       call get_command_argument(iarg, value=arg)
+       select case(trim(arg))
+       case('--to-binary')
+          to_bin = .false.
+          to_ascii = .true.
+       case('--to-ascii')
+          to_ascii = .false.
+          to_bin = .true.
+       case default
+          if (len_trim(infile) == 0) then
+             infile = trim(arg)
+          else if (len_trim(outfile) == 0) then
+             outfile = trim(arg)
+          else
+             write(0,*) 'Error: Unknown argument: ', trim(arg)
+             call finalize()
+             stop
+          end if
+       end select
+       iarg = iarg + 1
+    end do
+
+    if ((len(infile) == 0) .or. (len(outfile) == 0))then
+       write(0,*) 'Error: No input file specified.'
+       call finalize()
+       stop
+    end if
+
+end subroutine initialize
+
+  !--------------------------------------------------------------------!
+
+subroutine finalize()
+
+    implicit none
+
+end subroutine finalize
+
+  !--------------------------------------------------------------------!
+
+subroutine ascii2bin(infile, outfile)
+    implicit none
+
+    character(len=*), intent(in)  :: infile, outfile
+
+    integer                       :: ntypestot, nstrucs, istruc
+    real*8                        :: E_scale, E_shift
+    logical                       :: normalized
+    character(len=2), allocatable :: type_names(:)
+    real*8, allocatable           :: E_atom(:)
+
+    integer                       :: length, natoms, ntypes, iatom, itype, jtype, nsf
+    real*8                        :: energy, cooCart(3), forCart(3)
+    character(len=1024)           :: filename
+    real*8, allocatable           :: sfval(:)
+
+    integer                       :: natomtot, nenv, neval, nsfparam
+    real*8                        :: E_avg, E_min, E_max, rc_min, rc_max
+    logical                       :: has_setups
+    character(len=1024)           :: description
+    character(len=2)              :: atomtype
+    character(len=100)            :: sftype
+    character(len=2), allocatable :: envtypes(:)
+    integer, allocatable          :: sf(:), sfenv(:,:)
+    real*8, allocatable           :: sfparam(:,:), sfval_min(:), sfval_max(:), sfval_avg(:), sfval_cov(:)
+
+    !integer,intent(in)                             :: ionum
+
+
+
+    open(unit = 1, action = "read", status = "old", file = infile)
+    open(unit = 2, action = "write", status = "replace", file = outfile, form = "unformatted")
+
+    ! Read header
+    read(1,*) ntypestot
+    read(1,*) nstrucs
+    allocate(type_names(ntypestot), E_atom(ntypestot))
+    read(1,*) type_names(:)
+    read(1,*) E_atom(:)
+    read(1,*) normalized
+    read(1,*) E_scale
+    read(1,*) E_shift
+
+    write(2) ntypestot
+    write(2) nstrucs
+    write(2) type_names(:)
+    write(2) E_atom(:)
+    write(2) normalized
+    write(2) E_scale
+    write(2) E_shift
+
+
+
+
+    ! Read dataset fingerprints
+    do istruc = 1, nstrucs
+        read(1,*) length
+        length = min(length, len(filename))
+        read(1,*) filename(1:length)
+        read(1,*) natoms, ntypes
+        read(1,*) energy
+
+        write(2) length
+        write(2) filename(1:length)
+        write(2) natoms, ntypes
+        write(2) energy
+
+        do iatom = 1, natoms
+            read(1,*) itype
+            read(1,*) cooCart(:)
+            read(1,*) forCart(:)
+            read(1,*) nsf
+            allocate(sfval(nsf))
+            read(1,*) sfval(1:nsf)
+
+            write(2) itype
+            write(2) cooCart(:)
+            write(2) forCart(:)
+            write(2) nsf
+            write(2) sfval(1:nsf)
+
+            deallocate(sfval)
+        enddo
+
+    enddo
+
+    ! Read footer information of the fingerprint setups
+    read(1,*) natomtot
+    read(1,*) E_avg, E_min, E_max
+    read(1,*) has_setups
+
+    write(2) natomtot
+    write(2) E_avg, E_min, E_max
+    write(2) has_setups
+
+    do jtype = 1, ntypestot
+        read(1,*) itype
+        read(1,*) description
+        read(1,*) atomtype
+        read(1,*) nenv
+
+        allocate(envtypes(nenv))
+
+        read(1,*) envtypes(:)
+        read(1,*) rc_min
+        read(1,*) rc_max
+        read(1,*) sftype
+        read(1,*) nsf
+        read(1,*) nsfparam
+
+        allocate(sf(nsf), sfparam(nsfparam,nsf), sfenv(2,nsf), sfval_min(nsf), &
+                 sfval_max(nsf), sfval_avg(nsf), sfval_cov(nsf))
+
+        read(1,*) sf(:)
+        read(1,*) sfparam(:,:)
+        read(1,*) sfenv(:,:)
+        read(1,*) neval
+        read(1,*) sfval_min
+        read(1,*) sfval_max
+        read(1,*) sfval_avg
+        read(1,*) sfval_cov
+
+
+
+        write(2) itype
+        write(2) description
+        write(2) atomtype
+        write(2) nenv
+        write(2,"(a)") envtypes(:)
+        write(2) rc_min
+        write(2) rc_max
+        write(2) sftype
+        write(2) nsf
+        write(2) nsfparam
+        write(2) sf(:)
+        write(2) sfparam(:,:)
+        write(2) sfenv(:,:)
+        write(2) neval
+        write(2) sfval_min
+        write(2) sfval_max
+        write(2) sfval_avg
+        write(2) sfval_cov
+
+        deallocate(sf, sfparam, sfenv, sfval_min, sfval_max, sfval_avg, sfval_cov, envtypes)
+    enddo
+
+    close(unit = 1)
+    close(unit = 2)
+
+end subroutine ascii2bin
+
+  !--------------------------------------------------------------------!
+
+subroutine bin2ascii(infile, outfile)
+    implicit none
+
+    character(len=*), intent(in)  :: infile, outfile
+
+    integer                       :: i, ntypestot, nstrucs, istruc
+    real*8                        :: E_scale, E_shift
+    logical                       :: normalized
+    character(len=2), allocatable :: type_names(:)
+    real*8, allocatable           :: E_atom(:)
+
+    integer                       :: length, natoms, ntypes, iatom, itype, jtype, nsf
+    real*8                        :: energy, cooCart(3), forCart(3)
+    character(len=1024)           :: filename
+    real*8, allocatable           :: sfval(:)
+
+    integer                       :: natomtot, nenv, neval, nsfparam
+    real*8                        :: E_avg, E_min, E_max, rc_min, rc_max
+    logical                       :: has_setups
+    character(len=1024)           :: description
+    character(len=2)              :: atomtype
+    character(len=100)            :: sftype
+    character(len=2), allocatable :: envtypes(:)
+    integer, allocatable          :: sf(:), sfenv(:,:)
+    real*8, allocatable           :: sfparam(:,:), sfval_min(:), sfval_max(:), sfval_avg(:), sfval_cov(:)
+    !integer,intent(in)                             :: ionum
+    integer::num,num1,num2,j
+
+
+
+    open(unit = 1, action = "read", status = "old", file = infile, form = "unformatted")
+    open(unit = 2, action = "write", status = "replace", file = outfile)
+
+    ! Read header
+    read(1) ntypestot
+    read(1) nstrucs
+    allocate(type_names(ntypestot), E_atom(ntypestot))
+    read(1) type_names(:)
+    read(1) E_atom(:)
+    read(1) normalized
+    read(1) E_scale
+    read(1) E_shift
+
+    write(2,*) ntypestot
+    write(2,*) nstrucs
+    write(2,"(100a4)") type_names(:)
+    write(2,*) E_atom(:)
+    write(2,*) normalized
+    write(2,*) E_scale
+    write(2,*) E_shift
+
+    close(unit=1)
+
+
+    ! Read footer information of the fingerprint setups
+    open(unit = 1, action = "read", status = "old", file = infile, form = "unformatted")
+
+    do i = 1, 7
+        read(1)
+    enddo
+    do istruc = 1, nstrucs
+        read(1) 
+        read(1) 
+        read(1) natoms, ntypes
+        read(1)
+
+        do iatom = 1, natoms
+            read(1) 
+            read(1) 
+            read(1) 
+            read(1) 
+            read(1) 
+        enddo
+
+    enddo
+
+
+    read(1) natomtot
+    read(1) E_avg, E_min, E_max
+    read(1) has_setups
+
+    write(2,*) natomtot
+    write(2,*) E_avg, E_min, E_max
+    write(2,*) has_setups
+
+    do jtype = 1, ntypestot
+        read(1) itype
+        read(1) description
+        read(1) atomtype
+        read(1) nenv
+
+        allocate(envtypes(nenv))
+
+        read(1) envtypes(:)
+        read(1) rc_min
+        read(1) rc_max
+        read(1) sftype
+        read(1) nsf
+        read(1) nsfparam
+
+        allocate(sf(nsf), sfparam(nsfparam,nsf), sfenv(2,nsf), sfval_min(nsf), &
+                 sfval_max(nsf), sfval_avg(nsf), sfval_cov(nsf))
+        
+        read(1) sf(:)
+        read(1) sfparam(:,:)
+        read(1) sfenv(:,:)
+        read(1) neval
+        read(1) sfval_min
+        read(1) sfval_max
+        read(1) sfval_avg
+        read(1) sfval_cov
+
+
+
+        write(2,*) itype
+        write(2,"(a)") description
+        write(2,"(a)") atomtype
+        write(2,*) nenv
+        write(2,"(a)") envtypes(:)
+        write(2,*) rc_min
+        write(2,*) rc_max
+        write(2,"(a)") sftype
+        write(2,*) nsf
+        write(2,*) nsfparam
+        num = ubound(sf,1)
+        do i=1,num
+            write(2,"(i6)",ADVANCE='NO') sf(i)
+        end do
+        write(2,*)
+        num1 = ubound(sfparam,1)
+        num2 = ubound(sfparam,2)
+        do j=1,num2
+            do i=1,num1
+                write(2,"(e20.10)",ADVANCE='NO') sfparam(i,j)
+            end do
+        end do
+        write(2,*)
+        !write(2,*) sf(:)
+        !write(2,*) sfparam(:,:)
+        num1 = ubound(sfenv,1)
+        num2 = ubound(sfenv,2)
+        do j=1,num2
+            do i=1,num1
+                write(2,"(i6)",ADVANCE='NO') sfenv(i,j)
+            end do
+        end do
+        write(2,*)
+        !write(2,*) sfenv(:,:)
+        write(2,*) neval
+        
+        num = ubound(sfval_min,1)
+        do i=1,num
+            write(2,"(g20.10)",ADVANCE='NO') sfval_min(i)
+        end do
+        write(2,*)
+        do i=1,num
+            write(2,"(g20.10)",ADVANCE='NO') sfval_max(i)
+        end do
+        write(2,*)
+        do i=1,num
+            write(2,"(g20.10)",ADVANCE='NO') sfval_avg(i)
+        end do
+        write(2,*)
+        do i=1,num
+            write(2,"(g20.10)",ADVANCE='NO') sfval_cov(i)
+        end do
+        write(2,*)
+        
+        !write(2,*) sfval_min
+        !write(2,*) sfval_max
+        !write(2,*) sfval_avg
+        !write(2,*) sfval_cov
+
+        deallocate(sf, sfparam, sfenv, sfval_min, sfval_max, sfval_avg, sfval_cov, envtypes)
+    enddo
+
+    close(unit = 1)
+
+
+    ! Read dataset fingerprints
+    open(unit = 1, action = "read", status = "old", file = infile, form = "unformatted")
+
+    do i = 1, 7
+        read(1)
+    enddo
+
+    do istruc = 1, nstrucs
+        read(1) length
+        length = min(length, len(filename))
+        read(1) filename(1:length)
+        read(1) natoms, ntypes
+        read(1) energy
+
+        write(2,*) length
+        write(2,*) filename(1:length)
+        write(2,*) natoms, ntypes
+        write(2,*) energy
+
+        do iatom = 1, natoms
+            read(1) itype
+            read(1) cooCart(:)
+            read(1) forCart(:)
+            read(1) nsf
+            allocate(sfval(nsf))
+            read(1) sfval(1:nsf)
+
+            write(2,*) itype
+            write(2,*) cooCart(:)
+            write(2,*) forCart(:)
+            write(2,*) nsf
+                    
+            do i=1,nsf
+                write(2,"(g20.10)",ADVANCE='NO') sfval(i)
+            end do
+            write(2,*)
+
+            !write(2,*) sfval(1:nsf)
+
+            deallocate(sfval)
+        enddo
+
+    enddo
+
+    close(unit = 1)
+
+
+
+    close(unit = 2)
+
+end subroutine bin2ascii
+
+subroutine normalize_sfval(nsf, sfval_avg, sfval_cov, sfval)
+    implicit none
+    integer, intent(in)   :: nsf
+    real*8, intent(in)    :: sfval_avg(:), sfval_cov(:)
+    real*8, intent(inout) :: sfval(:)
+
+    integer               :: isf
+    real*8                :: shift, scale
+
+    do isf = 1, nsf
+        shift = sfval_avg(isf)
+        scale = 1.0d0/sqrt(sfval_cov(isf) - shift**2)
+        sfval(isf) = ( sfval(isf) -shift )*scale
+    enddo
+
+end subroutine normalize_sfval
+
+end subroutine trainbin2ascii_subroutine
+
+end module 
\ No newline at end of file
diff -Naru src/trainbin2ASCII_modified.f90 src_modified/trainbin2ASCII_modified.f90
--- src/trainbin2ASCII_modified.f90	1970-01-01 09:00:00
+++ src_modified/trainbin2ASCII_modified.f90	2024-09-06 10:37:30
@@ -0,0 +1,72 @@
+program trainbin2ASCII_modified
+    use aenet_trainbin2ascii
+    implicit none
+
+    character(len=1024) :: infile, outfile
+    logical             :: to_bin, to_ascii
+
+    call initialize(infile, outfile, to_bin, to_ascii)
+    call trainbin2ascii_subroutine(infile, outfile,to_bin, to_ascii)
+
+    contains 
+
+    subroutine initialize(infile, outfile, to_bin, to_ascii)
+
+        implicit none
+    
+        character(len=*), intent(out) :: infile, outfile
+        integer :: iarg, nargs
+        character(len=100) :: arg
+        logical, intent(out) :: to_bin, to_ascii
+    
+        nargs = command_argument_count()
+        if (nargs < 1) then
+           write(0,*) "Error: No input file provided."
+           call finalize()
+           stop
+        end if
+    
+        infile = ' '
+        outfile = ' '
+    
+        to_bin = .false.
+        to_ascii = .true.
+        
+        iarg = 1
+        do while(iarg <= nargs)
+           call get_command_argument(iarg, value=arg)
+           select case(trim(arg))
+           case('--to-binary')
+              to_bin = .false.
+              to_ascii = .true.
+           case('--to-ascii')
+              to_ascii = .false.
+              to_bin = .true.
+           case default
+              if (len_trim(infile) == 0) then
+                 infile = trim(arg)
+              else if (len_trim(outfile) == 0) then
+                 outfile = trim(arg)
+              else
+                 write(0,*) 'Error: Unknown argument: ', trim(arg)
+                 call finalize()
+                 stop
+              end if
+           end select
+           iarg = iarg + 1
+        end do
+    
+        if ((len(infile) == 0) .or. (len(outfile) == 0))then
+           write(0,*) 'Error: No input file specified.'
+           call finalize()
+           stop
+        end if
+    
+    end subroutine initialize
+
+    subroutine finalize()
+
+        implicit none
+    
+    end subroutine finalize
+end program
\ No newline at end of file
diff -Naru src/trainset_MPI.f90 src_modified/trainset_MPI.f90
--- src/trainset_MPI.f90	1970-01-01 09:00:00
+++ src_modified/trainset_MPI.f90	2024-09-06 10:37:30
@@ -0,0 +1,543 @@
+!-----------------------------------------------------------------------
+!           trainset.f90 - handling of the training set file
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!-----------------------------------------------------------------------
+! 2013-05-09 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+module trainset_MPI
+
+  use aeio,    only: aeio_header,           &
+                     TYPELEN, PATHLEN
+
+  use io,      only: io_adjustl,            &
+                     io_unit
+
+  use sfsetup, only: Setup,                 &
+                     save_Setup,            &
+                     load_Setup,            &
+                     del_Setup,             &
+                     stp_init,              &
+                     stp_final,             &
+                     stp_normalize,         &
+                     stp_assert_moduleinit, &
+                     stp_nsf_max
+
+  use trainset, only: TrnSet
+
+  use parallel,    only: pp_init,                &
+                         pp_final,               &
+                         pp_bcast,               &
+                         pp_barrier,             &
+                         ppMaster,               &
+                         ppRank,                 &
+                         ppSize,&
+                         pp_calc_and_bcast_footer
+
+  implicit none
+  private
+  save
+
+  public  :: new_TrnSet_MPI,          &
+             close_TrnSet_MPI,        &
+             save_TrnSet_info_MPI,    &
+             ts_write_atom_info_MPI,  &
+             ts_write_header_MPI,     &
+             ts_write_sf_info_MPI,    &
+             ts_write_structure_info_MPI, &
+             ts_write_footer_MPI,     &
+             ts_parallel_footer_MPI,   &
+             ts_loadandwrite_structure_info_MPI
+
+  private :: ts_assert_init,          &
+             ts_assert_writemode,     &
+             ts_assert_readmode
+
+  !--------------------------------------------------------------------!
+  ! Basis function values and derivatives may be read and written      !
+  ! either using a basis function setup [type(Setup)] or directly into !
+  ! double precision arrays of the correct dimensions.                 !
+  !--------------------------------------------------------------------!
+
+contains
+
+  function new_TrnSet_MPI(nTypes, typeName, E_atom, nStrucs, file, scale, &
+                      shift) result(ts)
+
+    implicit none
+
+    integer,                             intent(in) :: nTypes
+    character(len=*), dimension(nTypes), intent(in) :: typeName
+    double precision, dimension(nTypes), intent(in) :: E_atom
+    integer,                             intent(in) :: nStrucs
+    character(len=*),                    intent(in) :: file
+    double precision, optional,          intent(in) :: scale
+    double precision, optional,          intent(in) :: shift
+    type(TrnSet)                                    :: ts
+
+    logical :: fexists
+
+!    if (ppMaster) then
+!       inquire(file=trim(adjustl(file)), exist=fexists)
+!       if (fexists) then
+!          write(0,*) 'Error: file already exists: ', trim(adjustl(file))
+!          stop
+!       end if
+!    end if
+
+    allocate(ts%typeName(nTypes), ts%E_atom(nTypes))
+
+    ts%file               = trim(adjustl(file))
+    ts%nTypes             = nTypes
+    ts%typeName(1:nTypes) = typeName(1:nTypes)
+    ts%E_atom(1:nTypes)   = E_atom(1:nTypes)
+    ts%nStrucs            = nStrucs
+    ts%iStruc             = 0
+    if (present(scale) .and. present(shift)) then
+       ts%normalized = .true.
+       ts%scale = scale
+       ts%shift = shift
+    else
+       ts%normalized = .false.
+       ts%scale = 1.0d0
+       ts%shift = 0.0d0
+    end if
+
+    ts%unit   = io_unit()
+!    open(ts%unit, file=trim(ts%file), status='new', action='write', &
+!         form='unformatted')
+
+    ts%nAtomsTot = 0
+
+    ts%mode = 'write'
+    ts%init = .true.
+
+    call ts_write_header_MPI(ts)
+
+  end function new_TrnSet_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine close_TrnSet_MPI(ts, stp, status)
+
+    implicit none
+
+    type(TrnSet),                        intent(inout) :: ts
+    type(Setup), dimension(:), optional, intent(in)    :: stp
+    character(len=*),          optional, intent(in)    :: status
+
+    if (.not. ts%init) return
+
+    if (trim(ts%mode) == 'write') then
+       if (present(stp)) then
+          call ts_write_footer_MPI(ts, stp=stp)
+       else
+          call ts_write_footer_MPI(ts)
+       end if
+    end if
+
+    if ((trim(ts%mode)=='read') .or. (trim(ts%mode)=='write')) then
+       if (present(status)) then
+          close(ts%unit, status=trim(status))
+       else
+          close(ts%unit)
+       end if
+    end if
+
+    deallocate(ts%typeName, ts%E_atom)
+    ts%init   = .false.
+
+  end subroutine close_TrnSet_MPI
+
+  !--------------------------------------------------------------------!
+  !              only training set info - no actual data               !
+  !--------------------------------------------------------------------!
+
+  subroutine save_TrnSet_info_MPI(ts, file, unit)
+
+    implicit none
+
+    type(TrnSet),               intent(in) :: ts
+    character(len=*), optional, intent(in) :: file
+    integer,          optional, intent(in) :: unit
+
+    integer :: u
+
+    call ts_assert_init(ts)
+    call ts_assert_readmode(ts)
+
+    if (present(unit)) then
+       u = unit
+    else if (present(file)) then
+       u = io_unit()
+       open(u, file=trim(file), status='replace', &
+            form='unformatted', action='write')
+    else
+       write(0,*) "Error: neither unit nor file specified in `save_TrnSet_info()'."
+       stop
+    end if
+
+    write(u) ts%file
+    write(u) ts%normalized
+    write(u) ts%scale
+    write(u) ts%shift
+    write(u) ts%nTypes
+    write(u) ts%typeName(1:ts%nTypes)
+    write(u) ts%E_atom(1:ts%nTypes)
+    write(u) ts%nAtomsTot
+    write(u) ts%nStrucs
+    write(u) ts%E_min, ts%E_max, ts%E_av
+
+    if (.not. present(unit)) close(u)
+
+  end subroutine save_TrnSet_info_MPI
+
+  !--------------------------------------------------------------------!
+
+  function new_TrnSet_info_MPI(nTypes) result(ts)
+
+    implicit none
+
+    integer,                             intent(in) :: nTypes
+    type(TrnSet)                                    :: ts
+
+    allocate(ts%typeName(nTypes), ts%E_atom(nTypes))
+
+    ts%nTypes     = nTypes
+    ts%normalized = .false.
+    ts%scale      = 1.0d0
+    ts%shift      = 1.0d0
+    ts%file       = ''
+    ts%unit       = -1
+    ts%nAtomsTot  = 0
+    ts%nStrucs    = 0
+    ts%iStruc     = 0
+
+    ts%init = .true.
+    ts%mode = 'info'
+
+  end function new_TrnSet_info_MPI
+
+  !--------------------------------------------------------------------!
+  !                      training set file header                      !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_header_MPI(ts)
+
+    implicit none
+
+    type(TrnSet), intent(inout) :: ts
+    integer :: ts_unit = 1234
+    integer :: ts_unitall = 12345
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    if (ppMaster) then
+       open (ts_unit, file='ts.header', form='unformatted', position='append')
+       write(ts_unit) ts%nTypes
+       write(ts_unit) ts%nStrucs
+       write(ts_unit) ts%typeName(:)
+       write(ts_unit) ts%E_atom(:)
+       write(ts_unit) ts%normalized
+       write(ts_unit) ts%scale
+       write(ts_unit) ts%shift
+       close(ts_unit)
+
+       open (ts_unitall, file='ts.all', form='unformatted', status='replace')
+       write(ts_unitall) ts%nTypes
+       write(ts_unitall) ts%nStrucs
+       write(ts_unitall) ts%typeName(:)
+       write(ts_unitall) ts%E_atom(:)
+       write(ts_unitall) ts%normalized
+       write(ts_unitall) ts%scale
+       write(ts_unitall) ts%shift
+       close(ts_unitall)
+    end if
+
+  end subroutine ts_write_header_MPI
+
+  !--------------------------------------------------------------------!
+  !           training set file footer containing statistics           !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_parallel_footer_MPI(ts, stp)
+
+    implicit none
+
+    type(TrnSet),                        intent(inout) :: ts
+    type(Setup), dimension(:), intent(inout) :: stp
+
+   call pp_calc_and_bcast_footer(ts,stp)
+
+  end subroutine ts_parallel_footer_MPI
+
+  subroutine ts_write_footer_MPI(ts, stp)
+
+    implicit none
+
+    type(TrnSet),                        intent(inout) :: ts
+    type(Setup), dimension(:), optional, intent(in) :: stp
+
+    integer :: itype, nTypes
+    logical :: has_setups
+    integer :: ts_unit = 1234
+    integer :: ts_unitall = 12345
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    if (ppMaster) then
+
+       open (ts_unit, file='ts.footer', form='unformatted', position='append')
+       open (ts_unitall, file='ts.all', form='unformatted', position='append')
+
+       write(ts_unit) ts%nAtomsTot
+       write(ts_unitall) ts%nAtomsTot
+       write(ts_unit) ts%E_av, ts%E_min, ts%E_max
+       write(ts_unitall) ts%E_av, ts%E_min, ts%E_max
+!       write(5678,*) ts%nAtomsTot
+!       write(5678,*) ts%E_av, ts%E_min, ts%E_max
+!
+       if (present(stp)) then
+          nTypes = size(stp(:))
+          if (nTypes /= ts%nTypes) then
+             write(0,*) "Error: wrong size of array stp in `ts_read_footer()'."
+             stop
+          end if
+          has_setups = .true.
+          write(ts_unit) has_setups
+          write(ts_unitall) has_setups
+!          write(5678,*) has_setups
+          do itype = 1, ts%nTypes
+             write(ts_unit) itype
+             write(ts_unitall) itype
+!             write(5678,*) itype
+             call save_Setup(stp(itype), unit=ts_unit)
+             call save_Setup(stp(itype), unit=ts_unitall)
+          end do
+       else
+          has_setups = .false.
+!          write(5678,*) has_setups
+          write(ts_unit) has_setups
+          write(ts_unitall) has_setups
+       end if
+
+       close(ts_unit)
+       close(ts_unitall)
+
+    end if
+
+  end subroutine ts_write_footer_MPI
+
+  subroutine ts_loadandwrite_structure_info_MPI(ifile)
+
+   implicit none
+
+   integer:: nAtoms
+   integer:: nTypes
+   double precision:: energy
+   integer,          intent(in)    :: ifile
+   integer :: ts_unit = 1234
+   integer :: ts_unitall = 12345
+   character(len=100)::filenameload
+   integer::iatom
+   integer::itype
+   double precision, dimension(3):: cooCart
+   double precision, dimension(3):: forCart
+
+   integer:: nsf
+   double precision, dimension(:),allocatable:: sfval
+
+   double precision :: E_atom
+   integer::l
+
+
+   open (ts_unitall, file='ts.all', form='unformatted', position='append')
+   open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', status='old')
+
+   read(ts_unit) l
+   filenameload = " "
+   l = min(l,len(filenameload))
+   read(ts_unit) filenameload(1:l)
+
+   write(ts_unitall) len_trim(filenameload)
+   write(ts_unitall) trim(filenameload)
+
+
+
+   read(ts_unit) nAtoms, nTypes
+   write(ts_unitall) nAtoms, nTypes
+
+   read(ts_unit) energy
+   write(ts_unitall) energy
+
+   atoms : do iatom = 1, nAtoms
+
+      read(ts_unit) itype
+      write(ts_unitall) itype
+
+      read(ts_unit) cooCart(1:3)
+      write(ts_unitall) cooCart(1:3)
+      read(ts_unit) forCart(1:3)
+      write(ts_unitall) forCart(1:3)
+
+      read(ts_unit) nsf
+      write(ts_unitall) nsf
+      allocate(sfval(1:nsf))
+
+      read(ts_unit) sfval(1:nsf)
+      write(ts_unitall) sfval(1:nsf)
+      deallocate(sfval)
+
+   end do atoms
+
+   close(ts_unit)
+   close(ts_unitall)
+
+
+ end subroutine ts_loadandwrite_structure_info_MPI
+
+  !--------------------------------------------------------------------!
+  !              data from structures in the training set              !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_structure_info_MPI(ts, filename, nAtoms, nTypes, energy, ifile)
+
+    implicit none
+
+    type(TrnSet),     intent(inout) :: ts
+    character(len=*), intent(in)    :: filename
+    integer,          intent(in)    :: nAtoms
+    integer,          intent(in)    :: nTypes
+    double precision, intent(in)    :: energy
+    integer,          intent(in)    :: ifile
+    integer :: ts_unit = 1234
+
+    double precision :: E_atom
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    if (ts%iStruc >= ts%nStrucs) then
+       write(0,*) "Error: too many files for training set."
+       stop
+    else
+       ts%iStruc = ts%iStruc + 1
+    end if
+
+    open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', position='append')
+    write(ts_unit) len_trim(filename)
+    write(ts_unit) trim(filename)
+    write(ts_unit) nAtoms, nTypes
+    write(ts_unit) energy
+    close(ts_unit)
+
+    ! energy stats
+    E_atom = energy/dble(nAtoms)
+    if (ts%iStruc > 1) then
+       ts%E_min = min(ts%E_min, E_atom)
+       ts%E_max = max(ts%E_max, E_atom)
+       ts%E_av  = ts%E_av + E_atom/dble(ts%nStrucs)
+    else
+       ts%E_min = E_atom
+       ts%E_max = E_atom
+       ts%E_av  = E_atom/dble(ts%nStrucs)
+    end if
+
+    ! keep track of the atoms in the training set
+    ts%nAtomsTot = ts%nAtomsTot + nAtoms
+
+  end subroutine ts_write_structure_info_MPI
+
+
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_atom_info_MPI(ts, itype, cooCart, forCart, ifile)
+
+    implicit none
+
+    type(TrnSet),                   intent(inout) :: ts
+    integer,                        intent(in)    :: itype
+    double precision, dimension(3), intent(in)    :: cooCart
+    double precision, dimension(3), intent(in)    :: forCart
+    integer,          intent(in)    :: ifile
+    integer :: ts_unit = 1234
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', position='append')
+    write(ts_unit) itype
+    write(ts_unit) cooCart(1:3)
+    write(ts_unit) forCart(1:3)
+    close(ts_unit)
+
+  end subroutine ts_write_atom_info_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_sf_info_MPI(ts, nsf, sfval, ifile)
+
+    implicit none
+
+    type(TrnSet),                       intent(inout) :: ts
+    integer,                            intent(in)    :: nsf
+    double precision, dimension(nsf),   intent(in)    :: sfval
+    integer,          intent(in)    :: ifile
+    integer :: ts_unit = 1234
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', position='append')
+    write(ts_unit) nsf
+    write(ts_unit) sfval(1:nsf)
+    close(ts_unit)
+
+  end subroutine ts_write_sf_info_MPI
+
+  !--------------------------------------------------------------------!
+  !                            state checks                            !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_assert_init(ts)
+    implicit none
+    type(TrnSet), intent(in) :: ts
+    if (.not. ts%init) then
+       write(0,*) "Error: training set not initialized."
+       stop
+    end if
+  end subroutine ts_assert_init
+
+  subroutine ts_assert_writemode(ts)
+    implicit none
+    type(TrnSet), intent(in) :: ts
+    if (trim(ts%mode) /= 'write') then
+       write(0,*) "Error: training set not in 'write' mode."
+       stop
+    end if
+  end subroutine ts_assert_writemode
+
+  subroutine ts_assert_readmode(ts)
+    implicit none
+    type(TrnSet), intent(in) :: ts
+    if (trim(ts%mode) /= 'read') then
+       write(0,*) "Error: training set not in 'read' mode."
+       stop
+    end if
+  end subroutine ts_assert_readmode
+
+end module trainset_MPI
